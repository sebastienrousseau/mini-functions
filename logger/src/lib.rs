//! # Core Log functionality
//!
//! Log provides an easy way to log a message to the console with a simple, readable output format.
//!
#![warn(missing_docs)]
#![forbid(unsafe_code)]
// Copyright Â© 2022-2023 Mini Functions. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT

use std::{
    fmt::{self, Write},
    io,
};

// use std::sync::RwLock;
// extern crate date;
// use self::date::Date;

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum LogFormat {
    COMMON,
    JSON,
    CEF,
    ELF,
    W3C,
    GELF,
}

impl fmt::Display for LogFormat {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LogFormat::CEF => write!(f, "CEF"),
            LogFormat::COMMON => write!(f, "COMMON"),
            LogFormat::ELF => write!(f, "ELF"),
            LogFormat::GELF => write!(f, "GELF"),
            LogFormat::JSON => write!(f, "JSON"),
            LogFormat::W3C => write!(f, "W3C"),
        }
    }
}

/// Implements [`Log`] to log a message to the console with a simple, readable output format.
///
/// # Arguments
///
/// * `session_id` - A string slice that holds a session ID. The session ID is a unique identifier for the current session. A random GUID (Globally Unique Identifier) is generated by default.
/// * `time` - A string slice that holds the timestamp in ISO 8601 format.
/// * `level` - A string slice that holds the level (INFO, WARN, ERROR, etc.).
/// * `component` - A string slice that holds the component name.
/// * `description` - A string slice that holds the description of the log message.
///
///

#[derive(Debug, Clone, PartialEq, PartialOrd)]
/// An enumeration of the different levels that a log message can have.
/// Each variant of the enumeration represents a different level of
/// importance.
///
/// # Arguments
///
/// * `ALL` - The log level is set to all.
/// * `DEBUG` - The log level is set to debug.
/// * `DISABLED` - The log level is set to disabled.
/// * `ERROR` - The log level is set to error.
/// * `FATAL` - The log level is set to fatal.
/// * `INFO` - The log level is set to info.
/// * `NONE` - The log level is set to none.
/// * `TRACE` - The log level is set to trace.
/// * `VERBOSE` - The log level is set to verbose.
/// * `WARNING` - The log level is set to warning.
///
pub enum LogLevel {
    ALL,
    DEBUG,
    DISABLED,
    ERROR,
    FATAL,
    INFO,
    NONE,
    TRACE,
    VERBOSE,
    WARNING,
}

/// Implements [`LogLevel`] to display the log level as a string. It
/// allows the LogLevel enumeration to be used with the write! and
/// print! macros. It provides a human-readable string representation of
/// the variant, that will be used when displaying the log message.
impl fmt::Display for LogLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LogLevel::ALL => write!(f, "ALL"),
            LogLevel::DEBUG => write!(f, "DEBUG"),
            LogLevel::DISABLED => write!(f, "DISABLED"),
            LogLevel::ERROR => write!(f, "ERROR"),
            LogLevel::FATAL => write!(f, "FATAL"),
            LogLevel::INFO => write!(f, "INFO"),
            LogLevel::NONE => write!(f, "NONE"),
            LogLevel::TRACE => write!(f, "TRACE"),
            LogLevel::VERBOSE => write!(f, "VERBOSE"),
            LogLevel::WARNING => write!(f, "WARNING"),
        }
    }
}

#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, PartialOrd)]
/// The `Log` struct provides an easy way to log a message to the
/// console. It contains a set of defined fields to create a simple,
/// log message with a readable output format.
///
/// # Arguments
///
/// * `session_id` - A string that holds a session ID. The session ID is a unique identifier for the current session. A random GUID (Globally Unique Identifier) is generated by default.
/// * `time` - A string that holds the timestamp in ISO 8601 format.
/// * `level` - A string that holds the level (INFO, WARN, ERROR, etc.).
/// * `component` - A string that holds the component name.
/// * `description` - A string that holds the description of the log message.
///
pub struct Log {
    pub session_id: String,
    pub time: String,
    pub level: LogLevel,
    pub component: String,
    pub description: String,
    pub format: LogFormat,
}

/// This implementation allows the Log struct to be created with default
/// values. It creates a new instance of the Log struct with empty
/// strings for the session_id, time, component and description fields,
///  and LogLevel::INFO for level field. This is useful when creating a
/// new instance of the Log struct. It allows the struct to be created
/// with default values, and then the fields can be set to the desired
/// values.
impl Default for Log {
    fn default() -> Log {
        Log {
            session_id: String::default(),
            time: String::default(),
            level: LogLevel::INFO,
            component: String::default(),
            description: String::default(),
            format: LogFormat::COMMON,
        }
    }
}

impl Log {
    /// Logs a message to the console using a pre-allocated buffer to
    /// reduce memory allocation and flush the output buffer to ensure
    /// that the message is written immediately.
    ///
    /// # Errors
    ///
    /// This function will panic if an error occurs when writing to the
    /// pre-allocated buffer or flushing the output buffer.
    ///
    pub fn log(&self) {
        let mut log_message = String::with_capacity(256);
        match self.format {
        LogFormat::COMMON => write!(
        log_message,
        "SessionID={} Timestamp={} Description={} Level={} Component={} Format={}",
        self.session_id, self.description, self.time, self.level, self.component, self.format
        )
        .expect("Unable to write log message"),
        LogFormat::JSON => write!(
        log_message,
        "{{\"SessionID\":\"{}\",\"Timestamp\":\"{}\",\"Level\":\"{}\",\"Component\":\"{}\",\"Description\":\"{}\"}} Format={}",
        self.session_id, self.time, self.level, self.component, self.description, self.format
        )
        .expect("Unable to write log message"),
        LogFormat::CEF => write!(
        log_message,
                "CEF:0|{}|{}|{}|{}|{}|{}",
        self.session_id, self.time, self.level, self.component, self.description, self.format
        )
        .expect("Unable to write log message"),
        LogFormat::ELF => write!(
        log_message,
        "ELF:0|{}|{}|{}|{}|{}|{}",
        self.session_id, self.time, self.level, self.component, self.description, self.format
        )
        .expect("Unable to write log message"),
        LogFormat::W3C => write!(
        log_message,
        "W3C:0|{}|{}|{}|{}|{}|{}",
        self.session_id, self.time, self.level, self.component, self.description, self.format
        )
        .expect("Unable to write log message"),
        LogFormat::GELF => write!(
        log_message,
        "GELF:0|{}|{}|{}|{}|{}|{}",
        self.session_id, self.time, self.level, self.component, self.description, self.format
        )
        .expect("Unable to write log message"),
        }
        println!("{log_message}");
        io::Write::flush(&mut io::stdout()).expect("Unable to flush stdout");
    }

    /// Creates a new instance of the `Log` struct with the provided parameters.
    ///
    /// # Parameters
    /// * `component`: A string slice representing the component.
    /// * `description`: A string slice representing the log description.
    /// * `format`: A string slice representing the log format.
    /// * `level`: A string slice representing the log level.
    /// * `session_id`: A string slice representing the session ID.
    /// * `time`: A string slice representing the timestamp.
    ///
    /// # Returns
    ///
    /// A new instance of the `Log` struct with the provided parameters.
    #[must_use]
    pub fn new(
        session_id: &str,
        time: &str,
        level: &LogLevel,
        component: &str,
        description: &str,
        format: &LogFormat,
    ) -> Self {
        Self {
            session_id: session_id.to_string(),
            time: time.to_string(),
            level: level.clone(),
            component: component.to_string(),
            description: description.to_string(),
            format: format.clone(),
        }
    }
}

impl fmt::Display for Log {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.format {
            LogFormat::COMMON => {
                write!(
                    f,
                    "SessionID={} Timestamp={} Description={} Level={} Component={}",
                    self.session_id, self.time, self.description, self.level, self.component
                )
                .expect("Unable to write log message");
                Ok(())
            }
            LogFormat::JSON => {
                write!(
                f,
                "{{\"SessionID\":\"{}\",\"Timestamp\":\"{}\",\"Level\":\"{}\",\"Component\":\"{}\",\"Description\":\"{}\",\"Format\":\"JSON\"}}",
                self.session_id, self.time, self.level, self.component, self.description)
                .expect("Unable to write log message");
                Ok(())
            }
            LogFormat::CEF => {
                write!(
                    f,
                    "CEF:0|{}|{}|{}|{}|{}|CEF",
                    self.session_id, self.time, self.level, self.component, self.description
                )
                .expect("Unable to write log message");
                Ok(())
            }
            LogFormat::ELF => {
                write!(
                    f,
                    "ELF:0|{}|{}|{}|{}|{}|ELF",
                    self.session_id, self.time, self.level, self.component, self.description
                )
                .expect("Unable to write log message");
                Ok(())
            }
            LogFormat::W3C => {
                write!(
                    f,
                    "W3C:0|{}|{}|{}|{}|{}|W3C",
                    self.session_id, self.time, self.level, self.component, self.description
                )
                // self.session_id, self.time, self.level, self.component, self.description)
                .expect("Unable to write log message");
                Ok(())
            }
            LogFormat::GELF => {
                write!(
                    f,
                    r#"{{
                            "version": "1.1",
                            "host": "{}",
                            "short_message": "{}",
                            "level": "{:?}",
                            "timestamp": "{}",
                            "_component": "{}",
                            "_session_id": "{}"
                        }}"#,
                    self.component,
                    self.description,
                    self.level,
                    self.time,
                    self.component,
                    self.session_id
                )
                .expect("Unable to write log message");
                Ok(())
            }
        }
    }
}
