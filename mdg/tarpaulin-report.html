<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","benches","cjwt.rs"],"content":"extern crate criterion;\nuse claims::Claims;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nextern crate cjwt;\nuse self::cjwt::{Algorithm, Header, JWT};\n\nfn bench_to_string_benchmark(c: \u0026mut Criterion) {\n    let jwt = JWT::default();\n\n    c.bench_function(\"to_string\", move |b| b.iter(|| jwt.to_string()));\n}\n\nfn bench_default_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"default\", |b| b.iter(|| JWT::default));\n}\n\nfn bench_decode_benchmark(c: \u0026mut Criterion) {\n    let secret: \u0026[u8; 6] = b\"secret\";\n    let header = Header::default();\n    let claims = Claims::default();\n\n    let token = JWT::encode(header, claims, secret).unwrap();\n    let mut jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token,\n    };\n\n    c.bench_function(\"decode\", move |b| b.iter(|| jwt.decode(secret)));\n}\n\nfn bench_generate_benchmark(c: \u0026mut Criterion) {\n    let secret = b\"secret\";\n    c.bench_function(\"generate\", |b| {\n        b.iter(|| JWT::generate(black_box(secret)).unwrap())\n    });\n}\n\n// fn bench_generate_benchmark(c: \u0026mut Criterion) {\n//     c.bench_function(\"generate\", |b| b.iter(|| JWT::generate()));\n// }\n\nfn bench_get_token_benchmark(c: \u0026mut Criterion) {\n    let jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n    let result = JWT::get_token(jwt);\n    c.bench_function(\"get_token\", move |b| b.iter(|| result.clone()));\n}\n\nfn bench_claims_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"claims\", move |b| b.iter(|| JWT::claims));\n}\n\nfn bench_get_token_length_benchmark(c: \u0026mut Criterion) {\n    let jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n    let result = JWT::get_token_length(jwt);\n    c.bench_function(\"get_token_length\", move |b| b.iter(|| result));\n}\n\nfn bench_get_token_header_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"get_token_header\", move |b| {\n        let jwt = JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: Some(\"example_kid\".to_string()),\n                typ: Some(\"example_type\".to_string()),\n                cty: Some(\"example_cty\".to_string()),\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::get_token_header(jwt);\n        b.iter(|| result.clone())\n    });\n}\n\nfn bench_encode_benchmark(c: \u0026mut Criterion) {\n    let secret = b\"secret\";\n    let header = JWT::default().header;\n    let claims = JWT::default().claims;\n\n    c.bench_function(\"encode\", move |b| {\n        b.iter(|| {\n            JWT::encode(\n                black_box(header.clone()),\n                black_box(claims.clone()),\n                black_box(secret),\n            )\n        })\n    });\n}\nfn bench_validate_benchmark(c: \u0026mut Criterion) {\n    let secret = b\"secret\";\n    let jwt = JWT {\n        header: Header {\n            alg: Some(Algorithm::HS256),\n            kid: Some(\"example_kid\".to_string()),\n            typ: Some(\"example_type\".to_string()),\n            cty: Some(\"example_cty\".to_string()),\n        },\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n\n    c.bench_function(\"validate\", move |b| {\n        b.iter(|| JWT::validate(black_box(\u0026jwt), black_box(secret)));\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_claims_benchmark,\n    bench_decode_benchmark,\n    bench_default_benchmark,\n    bench_encode_benchmark,\n    bench_generate_benchmark,\n    bench_get_token_benchmark,\n    bench_get_token_header_benchmark,\n    bench_get_token_length_benchmark,\n    bench_to_string_benchmark,\n    bench_validate_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","examples","cjwt.rs"],"content":"extern crate cjwt;\nextern crate jwt;\n\nuse self::cjwt::{Algorithm, Header, JWT};\nuse claims::Claims;\n\nfn main() {\n    // Constants for the JWT struct examples.\n    const HD_ALG: Algorithm = Algorithm::HS384;\n    const HD_KID: \u0026str = \"jwt-kid\";\n    const HD_TYP: \u0026str = \"jwt-typ\";\n    const HD_CTY: \u0026str = \"jwt-cty\";\n\n    // Create a Header struct with default method.\n    let hd: Header = Header::default();\n    println!(\"ðŸ¦€ Header::default():             âœ… {hd:?}\\n\");\n\n    // Create a Header struct with default method and replace values.\n    let mut hdrv: Header = Header::default();\n    Header::default().alg = std::mem::replace(\u0026mut hdrv.alg, Some(HD_ALG));\n    Header::default().kid = std::mem::replace(\u0026mut hdrv.kid, Some(HD_KID.to_string()));\n    Header::default().typ = std::mem::replace(\u0026mut hdrv.typ, Some(HD_TYP.to_string()));\n    Header::default().cty = std::mem::replace(\u0026mut hdrv.cty, Some(HD_CTY.to_string()));\n    println!(\"ðŸ¦€ Header::default():             âœ… {hdrv:?}\\n\");\n\n    // Create a JWT struct with default method.\n    let jd: JWT = JWT::default();\n    println!(\"ðŸ¦€ JWT::default():                âœ… {jd:?}\\n\");\n\n    // Create a JWT struct with default method and replace values.\n    let mut jdrv: JWT = JWT::default();\n    JWT::default().header.alg = std::mem::replace(\u0026mut jdrv.header.alg, Some(HD_ALG));\n    JWT::default().header.kid = std::mem::replace(\u0026mut jdrv.header.kid, Some(HD_KID.to_string()));\n    JWT::default().header.typ = std::mem::replace(\u0026mut jdrv.header.typ, Some(HD_TYP.to_string()));\n    JWT::default().header.cty = std::mem::replace(\u0026mut jdrv.header.cty, Some(HD_CTY.to_string()));\n    println!(\"ðŸ¦€ JWT::default():                âœ… {jdrv:?}\\n\");\n\n    // Encode a JWT struct.\n    let encoded: String = JWT::encode(hdrv, claims::Claims::default(), b\"secret\").unwrap();\n    println!(\"ðŸ¦€ encode():                      âœ… {encoded:?}\\n\");\n\n    // Extract the token field from the passed JWT struct and return it.\n    let jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n    let result = JWT::get_token(jwt);\n    println!(\"ðŸ¦€ get_token():                       âœ… {result:?}\\n\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for working with JSON Web Tokens (JWTs) and JSON Web Signatures (JWSs)\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-cjwt.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! JOT is a struct that holds the JWT token and its associated claims. It provides a set of utility functions for working with JSON Web Tokens (JWTs) and JSON Web Signatures (JWSs).\n//!\n//! ## Features\n//!\n//! - [x] JWT token generation\n//! - [x] JWT token validation\n//! - [x] JWT token signing\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cjwt.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cjwt.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"cjwt\"]\n#![crate_type = \"lib\"]\n\nextern crate base64;\nextern crate claims;\nextern crate dtt;\nextern crate hmac;\nextern crate idk;\nextern crate jwt;\nextern crate serde;\nextern crate serde_json;\nextern crate sha2;\n\nuse self::claims::Claims;\nuse idk::jwt::JwtError;\n\nuse base64::{engine::general_purpose, Engine as _};\nuse hmac::{Hmac, Mac};\nuse serde::{Deserialize, Serialize};\nuse sha2::Sha256;\nuse std::{fmt, string::ToString};\n\n/// JWT is a struct that holds the JWT token and its associated claims.\n/// Provides a set of utility functions for working with JSON Web Tokens\n/// (JWTs) and JSON Web Signatures (JWSs).\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct JWT {\n    /// The header of the JWT.\n    pub header: Header,\n    /// The claims associated with the JWT.\n    pub claims: Claims,\n    /// The signature of the JWT.\n    pub signature: Vec\u003cu8\u003e,\n    /// The JWT token.\n    pub token: String,\n}\n/// The Header struct contains the header of the JWT.\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct Header {\n    /// Indicates the algorithm used to sign the JWT. Defaults to HS256.\n    /// See the Algorithm enum for a list of supported algorithms.\n    pub alg: Option\u003cAlgorithm\u003e,\n    /// Indicates the key used to sign the JWT. This is used to select\n    /// a specific key for a given JWT.\n    pub kid: Option\u003cString\u003e,\n    /// Indicates the media type of the JWT. Defaults to JWT.\n    pub typ: Option\u003cString\u003e,\n    /// Indicates the content type.\n    pub cty: Option\u003cString\u003e,\n}\n\n/// The Algorithm enum contains a list of supported algorithms.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Algorithm {\n    /// HMAC using SHA-256 hash algorithm.\n    HS256,\n\n    /// HMAC using SHA-384 hash algorithm.\n    HS384,\n\n    /// HMAC using SHA-512 hash algorithm.\n    HS512,\n\n    /// RSASSA-PKCS1-v1_5 using SHA-256 hash algorithm.\n    RS256,\n\n    /// RSASSA-PKCS1-v1_5 using SHA-384 hash algorithm.\n    RS384,\n\n    /// RSASSA-PKCS1-v1_5 using SHA-512 hash algorithm.\n    RS512,\n\n    /// ECDSA using P-256 and SHA-256.\n    ES256,\n\n    /// ECDSA using P-384 and SHA-384.\n    ES384,\n\n    /// ECDSA using P-521 and SHA-512.\n    ES512,\n}\n\nimpl ToString for Algorithm {\n    /// Converts an Algorithm enum to a string.\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            Algorithm::HS256 =\u003e \"HS256\".to_string(),\n            Algorithm::HS384 =\u003e \"HS384\".to_string(),\n            Algorithm::HS512 =\u003e \"HS512\".to_string(),\n            Algorithm::RS256 =\u003e \"RS256\".to_string(),\n            Algorithm::RS384 =\u003e \"RS384\".to_string(),\n            Algorithm::RS512 =\u003e \"RS512\".to_string(),\n            Algorithm::ES256 =\u003e \"ES256\".to_string(),\n            Algorithm::ES384 =\u003e \"ES384\".to_string(),\n            Algorithm::ES512 =\u003e \"ES512\".to_string(),\n        }\n    }\n}\n\nimpl Default for Algorithm {\n    /// Returns the default algorithm, HS256.\n    fn default() -\u003e Self {\n        Algorithm::HS256\n    }\n}\n\nimpl Default for JWT {\n    /// Returns a default JWT struct.\n    fn default() -\u003e Self {\n        JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: None,\n                typ: None,\n                cty: None,\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: String::default(),\n        }\n    }\n}\n\nimpl Default for Header {\n    /// Returns a default Header struct.\n    fn default() -\u003e Self {\n        Header {\n            alg: Some(Algorithm::HS256),\n            kid: None,\n            typ: Some(\"JWT\".to_string()),\n            cty: None,\n        }\n    }\n}\n\nimpl JWT {\n    /// Claims returns a default Claims struct.\n    pub fn claims() -\u003e Claims {\n        Claims::default()\n    }\n    /// Decodes a JWT token. takes a mutable reference to a JWT struct\n    /// and a reference to a slice of bytes representing a secret, and\n    /// it returns a Result containing a string or an Error variant.\n    /// The function splits the JWT stored in the token field of the\n    /// JWT struct into its header, claims, and signature, decodes the\n    /// header and claims from base64, deserializes the header and\n    /// claims from JSON, and then verifies the JWT's signature using\n    /// the provided secret.\n    ///\n    /// # Arguments\n    ///\n    /// * `secret` - A byte array containing the secret used to sign\n    /// the JWT.\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(String)` - The decoded JWT as a string.\n    /// * `Err(Error)` - An error if the JWT is invalid or if there was\n    /// a problem decoding it.\n    ///\n    pub fn decode(\u0026mut self, secret: \u0026[u8]) -\u003e Result\u003cString, JwtError\u003e {\n        let jwt = \u0026self.token;\n        {\n            // Split the JWT into its header, claims, and signature\n            // let (header_b64, claims_b64_signature_b64) = jwt.split_once('.').unwrap();\n            let (header_b64, claims_b64_signature_b64) = match jwt.split_once('.') {\n                Some(tuple) =\u003e tuple,\n                None =\u003e return Err(JwtError::DecodeError(\"Invalid JWT\".to_string())),\n            };\n\n            let (claims_b64, inner_signature_b64) =\n                claims_b64_signature_b64.split_once('.').unwrap();\n\n            // Base64-decode the header and claims\n            let header_json = general_purpose::STANDARD.decode(header_b64)?;\n            let claims_json = general_purpose::STANDARD.decode(claims_b64)?;\n\n            // Allocate Vec of references to slices\n            let header_json_tmp = header_json.as_slice();\n            let claims_json = claims_json.as_slice();\n\n            // Deserialize the header and claims from JSON\n            let _decoded_header: Header = serde_json::from_slice(header_json_tmp)?;\n            let _decoded_claims: Claims = serde_json::from_slice(claims_json)?;\n\n            // Sign the JWT with the secret\n            type HmacSha256 = Hmac\u003cSha256\u003e;\n            let mut hmac = HmacSha256::new_from_slice(secret).unwrap();\n            hmac.update(jwt.as_bytes());\n            let signature = hmac.finalize();\n            let signature_b64 = general_purpose::STANDARD.encode(signature.into_bytes());\n\n            // Compare the signature to the signature in the JWT\n            if signature_b64 != inner_signature_b64 {\n                return Err(JwtError::SignatureInvalid(signature_b64));\n            }\n            Ok(jwt.to_string())\n        }\n    }\n\n    /// Encodes a JWT token using the provided header, claims, and\n    /// secret. It returns a Result containing a string or an Error\n    /// variant. The function serializes the header and claims to JSON,\n    /// base64-encodes the header and claims, concatenates the encoded\n    /// header, claims, and separators, and then signs the JWT with the\n    /// provided secret.\n    pub fn encode(header: Header, claims: Claims, secret: \u0026[u8]) -\u003e Result\u003cString, JwtError\u003e {\n        // Serialize the header and claims to JSON\n        let header_json = serde_json::to_string(\u0026header)?;\n        let claims_json = serde_json::to_string(\u0026claims)?;\n\n        // Base64-encode the header and claims\n        let header_b64 = general_purpose::STANDARD.encode(header_json.as_bytes());\n        let claims_b64 = general_purpose::STANDARD.encode(claims_json.as_bytes());\n\n        // Concatenate the encoded header, claims, and separators\n        let jwt = format!(\"{header_b64}.{claims_b64}.\");\n\n        // Sign the JWT with the secret\n        type HmacSha256 = Hmac\u003cSha256\u003e;\n        let mut hmac = HmacSha256::new_from_slice(secret)?;\n        hmac.update(jwt.as_bytes());\n        let signature = hmac.finalize();\n\n        // Base64-encode the signature and concatenate it with the JWT\n        let signature_b64 = general_purpose::STANDARD.encode(signature.into_bytes());\n        let jwt = format!(\"{jwt}.{signature_b64}\");\n\n        Ok(jwt)\n    }\n\n    /// Generates a JWT token.\n    pub fn generate(secret: \u0026[u8]) -\u003e Result\u003cString, JwtError\u003e {\n        let claims = Claims::default();\n        let header = Header::default();\n        JWT::encode(header, claims, secret)\n    }\n\n    /// Returns the token field of the JWT struct.\n    pub fn get_token(jwt: JWT) -\u003e String {\n        jwt.token\n    }\n\n    /// Returns the header field of the JWT struct.\n    pub fn get_token_header(jwt: JWT) -\u003e Header {\n        jwt.header\n    }\n\n    /// Get the token length.\n    pub fn get_token_length(jwt: JWT) -\u003e usize {\n        jwt.token.len()\n    }\n\n    /// Validates a JWT token.\n    pub fn validate(\u0026self, secret: \u0026[u8]) -\u003e Result\u003c(), JwtError\u003e {\n        let jwt = \u0026self.token;\n        {\n            // Split the JWT into its header, claims, and signature\n            // let (header_b64, claims_b64_signature_b64) = jwt.split_once('.').unwrap();\n            let (header_b64, claims_b64_signature_b64) = match jwt.split_once('.') {\n                Some(tuple) =\u003e tuple,\n                None =\u003e return Err(JwtError::DecodeError(\"Invalid JWT\".to_string())),\n            };\n\n            let (claims_b64, inner_signature_b64) =\n                claims_b64_signature_b64.split_once('.').unwrap();\n\n            // Base64-decode the header and claims\n            let header_json = general_purpose::STANDARD.decode(header_b64)?;\n            let claims_json = general_purpose::STANDARD.decode(claims_b64)?;\n\n            // Allocate Vec of references to slices\n            let header_json_tmp = header_json.as_slice();\n            let claims_json = claims_json.as_slice();\n\n            // Deserialize the header and claims from JSON\n            let _decoded_header: Header = serde_json::from_slice(header_json_tmp)?;\n            let _decoded_claims: Claims = serde_json::from_slice(claims_json)?;\n\n            // Sign the JWT with the secret\n            type HmacSha256 = Hmac\u003cSha256\u003e;\n            let mut hmac = HmacSha256::new_from_slice(secret)?;\n            hmac.update(jwt.as_bytes());\n            let signature = hmac.finalize();\n\n            // Verify the signature\n            let mut hmac = HmacSha256::new_from_slice(secret)?;\n            hmac.update(inner_signature_b64.as_bytes());\n            let inner_signature = hmac.finalize();\n            if signature != inner_signature {\n                return Err(JwtError::InvalidSignature(\"Invalid signature\".to_string()));\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for JWT {\n    /// Formats the JWT struct for printing.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(\n            f,\n            \"JWT {{ header: {}, claims: {}, signature: {:?}, token: {} }}\",\n            self.header, self.claims, self.signature, self.token\n        )\n    }\n}\n\nimpl fmt::Display for Header {\n    /// Formats the Header struct for printing.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(\n            f,\n            \"Header {{ alg: {:?}, kid: {:?}, typ: {:?}, cty: {:?} }}\",\n            self.alg, self.kid, self.typ, self.cty\n        )\n    }\n}\n","traces":[{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":98},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","tests","cjwt.rs"],"content":"#[cfg(test)]\n\n// FIXME: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate cjwt;\n    extern crate claims;\n\n    use self::cjwt::{Algorithm, Header, JWT};\n    use self::claims::Claims;\n\n    #[test]\n    fn test_header_default() {\n        let header = Header::default();\n        assert_eq!(header.alg, Some(Algorithm::HS256));\n        assert_eq!(header.kid, None);\n        assert_eq!(header.typ, Some(\"JWT\".to_string()));\n        assert_eq!(header.cty, None);\n    }\n\n    #[test]\n    fn test_encode() {\n        let secret: \u0026[u8; 6] = b\"secret\";\n        let header = Header::default();\n        let claims = Claims::default();\n        let result = JWT::encode(header, claims, secret);\n        assert!(result.is_ok(), \"{}\", true);\n    }\n    #[test]\n    fn test_decode() {\n        let mut jwt = JWT::default();\n        let secret: \u0026[u8; 6] = b\"secret\";\n        let header = Header::default();\n        let claims = Claims::default();\n        let encoded_result = JWT::encode(header, claims, secret);\n        let encoded = encoded_result.unwrap();\n        jwt.token.clone_from(\u0026encoded);\n        let decoded = JWT::decode(\u0026mut jwt, secret);\n        if let Ok(decoded_token) = decoded {\n            assert_eq!(decoded_token, encoded);\n        }\n    }\n\n    #[test]\n    fn test_default() {\n        let jwt = JWT::default();\n        assert_eq!(jwt.header.alg, Some(Algorithm::HS256));\n    }\n\n    #[test]\n    fn test_generate() {\n        let secret = b\"secret\";\n        let jwt = JWT::generate(secret);\n        assert!(jwt.is_ok());\n        let token = jwt.unwrap();\n        assert!(!token.is_empty());\n    }\n\n    #[test]\n    fn test_get_token() {\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::get_token(jwt);\n        assert_eq!(result, \"example_token\");\n    }\n\n    #[test]\n    fn test_get_token_header() {\n        let jwt = JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: Some(\"example_kid\".to_string()),\n                typ: Some(\"example_type\".to_string()),\n                cty: Some(\"example_cty\".to_string()),\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::get_token_header(jwt);\n        assert_eq!(result.alg, Some(Algorithm::HS256));\n        assert_eq!(result.kid, Some(\"example_kid\".to_string()));\n        assert_eq!(result.typ, Some(\"example_type\".to_string()));\n        assert_eq!(result.cty, Some(\"example_cty\".to_string()));\n    }\n    #[test]\n    fn test_get_token_length() {\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"token\".to_string(),\n        };\n        let result = JWT::get_token_length(jwt);\n        assert_eq!(result, 5);\n    }\n    #[test]\n    fn test_validate_success() {\n        let secret: \u0026[u8; 6] = b\"secret\";\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::validate(\u0026jwt, secret);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_validate_with_empty_signature() {\n        // Create a JWT with valid claims and an empty signature\n        let secret = b\"secret\";\n        let jwt = JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: Some(\"example_kid\".to_string()),\n                typ: Some(\"example_type\".to_string()),\n                cty: Some(\"example_cty\".to_string()),\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n\n        // Test validating the JWT\n        let result = jwt.validate(secret);\n        assert!(result.is_err());\n    }\n    #[test]\n    fn test_to_string() {\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = jwt.to_string();\n        assert_eq!(result, \"JWT { header: Header { alg: Some(HS256), kid: None, typ: Some(\\\"JWT\\\"), cty: None }, claims: Claims {  }, signature: [], token: example_token }\");\n    }\n    #[test]\n    fn test_claims_default() {\n        let claims = self::JWT::claims();\n        assert!(claims.is_empty(), \"{}\", true);\n    }\n\n    #[test]\n    fn test_algorithm_variants() {\n        assert!(matches!(Algorithm::HS256, Algorithm::HS256));\n        assert!(matches!(Algorithm::HS384, Algorithm::HS384));\n        assert!(matches!(Algorithm::HS512, Algorithm::HS512));\n        assert!(matches!(Algorithm::RS256, Algorithm::RS256));\n        assert!(matches!(Algorithm::RS384, Algorithm::RS384));\n        assert!(matches!(Algorithm::RS512, Algorithm::RS512));\n        assert!(matches!(Algorithm::ES256, Algorithm::ES256));\n        assert!(matches!(Algorithm::ES384, Algorithm::ES384));\n        assert!(matches!(Algorithm::ES512, Algorithm::ES512));\n    }\n\n    #[test]\n    fn test_algorithm_default() {\n        let algorithm = Algorithm::default();\n        assert_eq!(algorithm, Algorithm::HS256);\n    }\n    #[test]\n    fn test_algorithm_to_string() {\n        let algorithm = Algorithm::default();\n        assert_eq!(algorithm.to_string(), \"HS256\");\n\n        let algorithm_hs384 = Algorithm::HS384;\n        assert_eq!(algorithm_hs384.to_string(), \"HS384\");\n\n        let algorithm_hs512 = Algorithm::HS512;\n        assert_eq!(algorithm_hs512.to_string(), \"HS512\");\n\n        let algorithm_rs256 = Algorithm::RS256;\n        assert_eq!(algorithm_rs256.to_string(), \"RS256\");\n\n        let algorithm_rs384 = Algorithm::RS384;\n        assert_eq!(algorithm_rs384.to_string(), \"RS384\");\n\n        let algorithm_rs512 = Algorithm::RS512;\n        assert_eq!(algorithm_rs512.to_string(), \"RS512\");\n\n        let algorithm_es256 = Algorithm::ES256;\n        assert_eq!(algorithm_es256.to_string(), \"ES256\");\n\n        let algorithm_es384 = Algorithm::ES384;\n        assert_eq!(algorithm_es384.to_string(), \"ES384\");\n\n        let algorithm_es512 = Algorithm::ES512;\n        assert_eq!(algorithm_es512.to_string(), \"ES512\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","benches","claims.rs"],"content":"extern crate claims;\nuse self::claims::Claims;\n\nextern crate criterion;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn memory_usage_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"memory_usage\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            let memory_usage = std::mem::size_of_val(\u0026claims);\n            black_box(memory_usage);\n        });\n    });\n}\nfn set_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"set_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n\n        b.iter(|| {\n            claims.set_claim(key, value);\n        });\n    });\n}\n\nfn get_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"get_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.get_claim(key);\n        });\n    });\n}\n\nfn remove_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"remove_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.remove_claim(key);\n        });\n    });\n}\n\nfn has_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"has_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.has_claim(key);\n        });\n    });\n}\n\nfn clear_claims_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"clear_claims\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.clear_claims();\n        });\n    });\n}\n\nfn len_and_is_empty_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"len_and_is_empty\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.len();\n            claims.is_empty();\n        });\n    });\n}\n\nfn scale_claim_benchmark(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"set_claim\");\n    for i in [10, 100, 1000, 10000, 100000].iter() {\n        group.bench_with_input(format!(\"{i} claims\"), i, |b, i| {\n            let mut claims = Claims::new();\n            let key = \"key\";\n            let value = \"value\";\n            b.iter(|| {\n                for _ in 0..*i {\n                    claims.set_claim(key, value);\n                }\n            });\n        });\n    }\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    clear_claims_benchmark,\n    get_claim_benchmark,\n    has_claim_benchmark,\n    len_and_is_empty_benchmark,\n    memory_usage_benchmark,\n    remove_claim_benchmark,\n    scale_claim_benchmark,\n    set_claim_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","examples","claims.rs"],"content":"extern crate claims;\nuse self::claims::Claims;\n\nfn main() {\n    // Create a new instance of Claims\n    let mut claims = Claims::new();\n\n    // Set claims\n    claims.set_claim(\"aud\", \"https://example.com\");\n    claims.set_claim(\"custom\", \"admin\");\n    claims.set_claim(\"did\", \"did:example:123456789\");\n    claims.set_claim(\"iss\", \"https://issuer.com\");\n    claims.set_claim(\"jti\", \"abc123\");\n    claims.set_claim(\"sub\", \"user123\");\n    claims.set_claim(\"vc\", \"Ed25519Signature2018\");\n    claims.set_claim(\"vp\", \"B7AC971B05D791F0EB5FCE3B8A3296F1D68A63199714A2993AAD6E2F3D10F4E4425576AA4D97B80B617D5A182B519E9A021DEEDE9BFFBC3499F902DDC5CA163F\");\n\n    // Get claims\n    let audience = claims.get_claim(\"aud\").unwrap();\n    let custom = claims.get_claim(\"custom\").unwrap();\n    let did = claims.get_claim(\"did\").unwrap();\n    let issuer = claims.get_claim(\"iss\").unwrap();\n    let jwt_id = claims.get_claim(\"jti\").unwrap();\n    let subject = claims.get_claim(\"sub\").unwrap();\n    let credential = claims.get_claim(\"vc\").unwrap();\n    let proof = claims.get_claim(\"vp\").unwrap();\n\n    println!(\"ðŸ¦€ Claims::get_claim() for 'aud':       âœ… {audience}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'custom':    âœ… {custom}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'did':       âœ… {did}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'iss':       âœ… {issuer}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'jti':       âœ… {jwt_id}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'sub':       âœ… {subject}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'vc':        âœ… {credential}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'vp':        âœ… {proof}\");\n\n    // Remove claims\n    let audience = claims.get_claim(\"aud\").unwrap().to_owned();\n    claims.remove_claim(\"aud\");\n    println!(\"ðŸ¦€ Claims::remove_claim():              âœ… {audience}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for accessing and manipulating claims of a JSON Web Token (JWT)\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-claims.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/claims)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The Claims library holds JSON Web Token (JWT) claims. It provides an\n//! RFC7519 compliant implementation of JSON Web Tokens (JWT) and JSON\n//! Web Signature (JWS) for Rust.\n//!\n//! The [**`Claims`**](./struct.Claims.html) type is provided to hold\n//! the claims of a JWT. The claims are stored in a `HashMap` and can be\n//! accessed using the `get_claim`, `set_claim`, `remove_claim`, and\n//! `has_claim` methods.\n//!\n//! ## Features\n//!\n//! The following table lists the optional reserved claims that are\n//! supported:\n//!\n//! | Claim | Description |\n//! | --- | --- |\n//! | `aud` (Audience) | Identifies the recipients that the JWT is intended for. |\n//! | `custom` (Custom) | Custom claims are used to share information between parties that agree on using them and are neither registered or public claims. |\n//! | `did` (Decentralized Identifier) | A string value that uniquely identifies a subject. |\n//! | `exp` (Expiration Time) | Identifies the expiration time on or after which the JWT MUST NOT be accepted for processing. |\n//! | `iat` (Issued At) | Identifies the time at which the JWT was issued. |\n//! | `iss` (Issuer) | Identifies the principal that issued the JWT. |\n//! | `jti` (JWT ID) | Provides a unique identifier for the JWT. |\n//! | `nbf` (Not Before) | Identifies the time before which the JWT MUST NOT be accepted for processing. |\n//! | `sub` (Subject) | Identifies the principal that is the subject of the JWT. |\n//! | `vc` (Verifiable Credential) | A Credential that is tamper-evident and has authorship that can be cryptographically verified. |\n//! | `vp` (Verifiable Presentation) | A Presentation that is tamper-evident and has authorship that can be cryptographically verified. |\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! ## Examples\n//!\n//! ```rust\n//! use self::claims::Claims;\n//! use std::collections::HashMap;\n//!\n//! // Create a new instance of Claims\n//! let mut claims = Claims::new();\n//!\n//! // Set a claim\n//! claims.set_claim(\"name\", \"John Doe\");\n//!\n//! // Get a claim\n//! let name = claims.get_claim(\"name\").unwrap(); // returns \"John Doe\"\n//!\n//! // Remove a claim\n//! claims.remove_claim(\"name\");\n//!\n//! // Clear all claims\n//! claims.clear_claims();\n//!\n//! // Has a claim\n//! let has_claim = claims.has_claim(\"name\"); // returns false\n//!\n//! // Get the number of claims\n//! let len = claims.len(); // returns 0\n//!\n//! // Is the claims empty?\n//! let is_empty = claims.is_empty(); // returns true\n//!\n//! // Get the claims as a HashMap\n//! let claims_map: \u0026HashMap\u003cString, String\u003e = claims.get_claims();\n//!\n//! ```\n//!\n//! ## Links\n//! * [RFC 7519](https://tools.ietf.org/html/rfc7519)\n//! * [JSON Web Token (JWT)](https://jwt.io/)\n//!\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-claims.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-claims.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"claims\"]\n#![crate_type = \"lib\"]\n\nextern crate serde;\nuse serde::{Deserialize, Serialize};\n\nuse std::collections::HashMap;\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\n/// The Claims struct holds the claims of a JSON Web Token (JWT).\n///\n/// A JWT is a compact, URL-safe means of representing claims to be\n/// transferred between two parties. It consists of a header, a payload,\n/// and a signature. The payload is where the claims are stored.\n///\n/// The claims in a JWT are encoded as a JSON object and can be used to\n/// convey information such as the identity of an end user, the\n/// expiration time of the token, and more.\n///\n/// The Claims struct provides a convenient way to manipulate the claims\n/// of a JWT in Rust. It stores the claims as a HashMap\u003cString, String\u003e,\n/// allowing for fast and efficient access to each claim.\npub struct Claims {\n    /// The claims of the JWT as a HashMap.\n    pub claims: HashMap\u003cString, String\u003e,\n}\n\nimpl Claims {\n    /// Creates a new instance of the `Claims` struct with an empty\n    /// HashMap of claims.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let claims = Claims::new();\n    /// assert!(claims.claims.is_empty());\n    /// ```\n    pub fn new() -\u003e Claims {\n        Claims {\n            claims: HashMap::new(),\n        }\n    }\n    /// Adds or updates a claim in the `Claims` struct with the given key and value.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.get_claim(\"sub\"), Some(\u0026String::from(\"1234567890\")));\n    /// ```\n    pub fn set_claim(\u0026mut self, key: \u0026str, value: \u0026str) {\n        self.claims.insert(key.to_string(), value.to_string());\n    }\n    /// Gets a claim from the `Claims` struct with the given key.\n    ///\n    /// Returns `None` if the key does not exist in the `Claims`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.get_claim(\"sub\"), Some(\u0026String::from(\"1234567890\")));\n    /// ```\n    pub fn get_claim(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026String\u003e {\n        self.claims.get(key)\n    }\n    //// Removes a claim from the `Claims` struct with the given key.\n    ///\n    /// Returns the value of the claim that was removed, if any.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.remove_claim(\"sub\"), Some(\"1234567890\".to_owned()));\n    /// ```\n    pub fn remove_claim(\u0026mut self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.claims.remove(key)\n    }\n    /// Clears all claims from the `Claims` struct.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// claims.clear_claims();\n    /// assert!(claims.claims.is_empty());\n    /// ```\n    pub fn clear_claims(\u0026mut self) {\n        self.claims.clear();\n    }\n    /// Checks if a claim with the given key exists in the `Claims` struct.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert!(claims.has_claim(\"sub\"));\n    /// ```\n    pub fn has_claim(\u0026self, key: \u0026str) -\u003e bool {\n        self.claims.contains_key(key)\n    }\n    /// Get the number of claims in the `Claims` struct.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.len(), 1);\n    /// ```\n    pub fn len(\u0026self) -\u003e usize {\n        self.claims.len()\n    }\n    /// Checks if the `Claims` struct is empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// assert!(claims.is_empty());\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert!(!claims.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.claims.is_empty()\n    }\n    /// Get a reference to the HashMap of claims in the `Claims` struct.\n    /// This is useful if you need to iterate over the claims.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// claims.set_claim(\"name\", \"John Doe\");\n    /// for (key, value) in claims.get_claims() {\n    ///    println!(\"{}: {}\", key, value);\n    /// }\n    /// ```\n    pub fn get_claims(\u0026self) -\u003e \u0026HashMap\u003cString, String\u003e {\n        \u0026self.claims\n    }\n}\n\n/// Implement the `Display` trait for `Claims`.\nimpl std::fmt::Display for Claims {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let claims: Vec\u003cString\u003e = self\n            .claims\n            .iter()\n            .map(|(k, v)| format!(\"{k}: {v}\"))\n            .collect();\n\n        write!(f, \"Claims {{ {} }}\", claims.join(\", \"))\n    }\n}\n\n/// Implement the `Default` trait for `Claims`.\nimpl Default for Claims {\n    /// Create a new instance of `Claims`.\n    fn default() -\u003e Self {\n        Claims {\n            claims: HashMap::new(),\n        }\n    }\n}\n","traces":[{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":25},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","tests","claims.rs"],"content":"#[cfg(test)]\n\nmod tests {\n\n    extern crate claims;\n    extern crate dtt;\n\n    use self::claims::Claims;\n    use self::dtt::DateTime;\n\n    #[test]\n    fn test_claims() {\n        const CL_AUD: \u0026str = \"MINI-FUNCTIONS-CLAIMS-AUD\";\n        const CL_CUSTOM: \u0026str = \"MINI-FUNCTIONS-CLAIMS-CUSTOM\";\n        const CL_DID: \u0026str = \"MINI-FUNCTIONS-CLAIMS-DID\";\n        const CL_ISS: \u0026str = \"MINI-FUNCTIONS-CLAIMS-ISS\";\n        const CL_JTI: \u0026str = \"MINI-FUNCTIONS-CLAIMS-JTI\";\n        const CL_SUB: \u0026str = \"MINI-FUNCTIONS-CLAIMS-SUB\";\n        const CL_VC: \u0026str = \"MINI-FUNCTIONS-CLAIMS-VC\";\n        const CL_VP: \u0026str = \"MINI-FUNCTIONS-CLAIMS-VP\";\n\n        let date = DateTime::new();\n        let iso = date.iso_8601;\n\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", CL_AUD);\n        claims.set_claim(\"custom\", CL_CUSTOM);\n        claims.set_claim(\"did\", CL_DID);\n        claims.set_claim(\"exp\", \u0026iso);\n        claims.set_claim(\"iat\", \u0026iso);\n        claims.set_claim(\"iss\", CL_ISS);\n        claims.set_claim(\"jti\", CL_JTI);\n        claims.set_claim(\"nbf\", \u0026iso);\n        claims.set_claim(\"sub\", CL_SUB);\n        claims.set_claim(\"vc\", CL_VC);\n        claims.set_claim(\"vp\", CL_VP);\n\n        assert_eq!(claims.get_claim(\"aud\").unwrap(), CL_AUD);\n        assert_eq!(claims.get_claim(\"custom\").unwrap(), CL_CUSTOM);\n        assert_eq!(claims.get_claim(\"did\").unwrap(), CL_DID);\n        assert_eq!(claims.get_claim(\"exp\").unwrap(), \u0026iso.to_string());\n        assert_eq!(claims.get_claim(\"iat\").unwrap(), \u0026iso.to_string());\n        assert_eq!(claims.get_claim(\"iss\").unwrap(), CL_ISS);\n        assert_eq!(claims.get_claim(\"jti\").unwrap(), CL_JTI);\n        assert_eq!(claims.get_claim(\"nbf\").unwrap(), \u0026iso.to_string());\n        assert_eq!(claims.get_claim(\"sub\").unwrap(), CL_SUB);\n        assert_eq!(claims.get_claim(\"vc\").unwrap(), CL_VC);\n        assert_eq!(claims.get_claim(\"vp\").unwrap(), CL_VP);\n    }\n    #[test]\n    fn test_get_claim() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        assert_eq!(\n            claims.get_claim(\"aud\").unwrap(),\n            \"MINI-FUNCTIONS-CLAIMS-AUD\"\n        );\n        assert!(claims.get_claim(\"non-existent-claim\").is_none());\n    }\n    #[test]\n    fn test_remove_claim() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.remove_claim(\"aud\");\n        assert!(claims.get_claim(\"aud\").is_none());\n    }\n\n    #[test]\n    fn test_clear_claims() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        claims.clear_claims();\n        assert_eq!(claims.len(), 0);\n    }\n    #[test]\n    fn test_has_claim() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        assert!(claims.has_claim(\"aud\"));\n        assert!(!claims.has_claim(\"non-existent-claim\"));\n    }\n\n    #[test]\n    fn test_len() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        assert_eq!(claims.len(), 2);\n    }\n    #[test]\n    fn test_is_empty() {\n        let mut claims = Claims::new();\n        assert!(claims.is_empty());\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        assert!(!claims.is_empty());\n    }\n\n    #[test]\n    fn test_get_claims() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        let retrieved_claims = claims.get_claims();\n        assert_eq!(\n            retrieved_claims.get(\"aud\").unwrap(),\n            \"MINI-FUNCTIONS-CLAIMS-AUD\"\n        );\n        assert_eq!(\n            retrieved_claims.get(\"custom\").unwrap(),\n            \"MINI-FUNCTIONS-CLAIMS-CUSTOM\"\n        );\n    }\n    #[test]\n    fn test_display_trait() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        let display_output = format!(\"{claims}\");\n        assert!(display_output.contains(\"aud: MINI-FUNCTIONS-CLAIMS-AUD\"));\n        assert!(display_output.contains(\"custom: MINI-FUNCTIONS-CLAIMS-CUSTOM\"));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let claims = Claims::default();\n        assert_eq!(claims.claims.len(), 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","benches","cmn.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\n\npub use cmn::Constants;\npub use cmn::Words;\n\npub struct Common;\n\nimpl Common {\n    pub fn new() -\u003e Self {\n        Common\n    }\n    pub fn constants(\u0026self) -\u003e Constants {\n        Constants\n    }\n    pub fn words(\u0026self) -\u003e Words {\n        Words::new()\n    }\n}\n\nimpl Default for Common {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nfn bench_common(c: \u0026mut Criterion) {\n    c.bench_function(\"common\", |b| {\n        b.iter(|| {\n            let common = black_box(Common::default());\n            black_box(common.constants());\n            black_box(common.words());\n        });\n    });\n}\n\ncriterion_group!(benches, bench_common);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","examples","cmn.rs"],"content":"extern crate cmn;\npub use cmn::Constants;\npub use cmn::Words;\n\nfn main() {\n    // Constants\n    let constants = Constants.constants();\n    for constant in constants {\n        println!(\n            \"ðŸ¦€ Constants::constant(): âœ… Name: {} Value: {}\",\n            constant.name, constant.value\n        );\n    }\n\n    // Words\n    let words = Words::new();\n    let words_list = words.words_list();\n    println!(\"ðŸ¦€ Words::new():          âœ… {:?}\", words_list[0]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","src","constants.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse serde::{Deserialize, Serialize};\n\n/// Contains several commonly used mathematical and cryptographic\n/// constants.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Constant {\n    /// The name of the constant.\n    pub name: \u0026'static str,\n\n    /// The value of the constant.\n    pub value: String,\n}\n/// The `Constants` structure holds mathematical and hash constants.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Constants;\n\nimpl Constants {\n    /// Returns a vector of tuples with the constant name and its value.\n    pub fn constants(\u0026self) -\u003e Vec\u003cConstant\u003e {\n        vec![\n            Constant {\n                name: \"EULER\",\n                value: EULER.to_string(),\n            },\n            Constant {\n                name: \"HASH_ALGORITHM\",\n                value: HASH_ALGORITHM.to_string(),\n            },\n            Constant {\n                name: \"HASH_COST\",\n                value: HASH_COST.to_string(),\n            },\n            Constant {\n                name: \"HASH_LENGTH\",\n                value: HASH_LENGTH.to_string(),\n            },\n            Constant {\n                name: \"PHI\",\n                value: PHI.to_string(),\n            },\n            Constant {\n                name: \"PI\",\n                value: PI.to_string(),\n            },\n            Constant {\n                name: \"PLANCK\",\n                value: PLANCK.to_string(),\n            },\n            Constant {\n                name: \"SQRT5\",\n                value: SQRT5.to_string(),\n            },\n            Constant {\n                name: \"SPECIAL_CHARS\",\n                value: format!(\"{SPECIAL_CHARS:?}\"),\n            },\n        ]\n    }\n}\n\n/// Enum to represent the different constant values.\n#[derive(Debug, Clone, Serialize)]\npub enum ConstantValue {\n    /// A float value represented as `f64`.\n    Float(f64),\n    /// A string value.\n    String(String),\n    /// An unsigned 32-bit integer value represented as `u32`.\n    U32(u32),\n    /// An unsigned integer with the size of a pointer represented as `usize`.\n    Usize(usize),\n    /// An array of characters represented as `\u0026'static [char]`.\n    CharArray(\u0026'static [char]),\n}\n\n/// The mathematical constant `E`, the base of the natural logarithm.\npub const EULER: f64 = std::f64::consts::E;\n\n/// The hash algorithm used. The default is Blake3.\npub const HASH_ALGORITHM: \u0026str = \"Blake3\";\n\n/// The cost of the hash algorithm. The default is 8.\npub const HASH_COST: u32 = 8;\n\n/// The length of the hash. The default is 32.\npub const HASH_LENGTH: usize = 32;\n\n/// The mathematical constant `Ï†` or the golden ratio.\npub const PHI: f64 = (1.0 + SQRT5) / 2.0;\n\n/// The mathematical constant `Ï€`.\npub const PI: f64 = std::f64::consts::PI;\n\n/// The Planck constant, `h`.\npub const PLANCK: f64 = 6.626_070_15e-34_f64;\n\n/// A set of special characters.\npub const SPECIAL_CHARS: \u0026[char] = \u0026[\n    '!', '@', '#', '$', '%', '^', '\u0026', '*', '(', ')', '_', '+', '=', '[', ']', '{', '}', '|', ';',\n    ':', '\"', '\u003c', '\u003e', ',', '.', '?', '/', '~', '`',\n];\n\n/// The square root of 5.\npub const SQRT5: f64 = 2.236_067_977_499_79_f64;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! A Rust library for accessing a collection of mathematical and cryptographic constants\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-cmn.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/cmn.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/cmn)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/cmn)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/cmn)\n//! [![License](https://img.shields.io/crates/l/cmn.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Common (CMN), a Rust library designed for developers who are looking\n//! for a comprehensive collection of mathematical and cryptographic\n//! constants.\n//!\n//!`CMN` is a modern, fast, and user-friendly library that makes it easy\n//! to access a wide range of mathematical and cryptographic constants,\n//! including the mathematical constant \"Euler\", the hash algorithm\n//! used, the cost of the hash algorithm, the length of the hash, the\n//! mathematical constant \"Phi\", the mathematical constant \"Pi\", the\n//! Planck constant, a set of special characters, and much more.\n//!\n//! ## Features\n//!\n//! The following table lists the Constants available in the Common\n//! library.\n//!\n//! | Constants | Description |\n//! | --- | --- |\n//! | `EULER` | Euler's constant is a mathematical constant approximately equal to 2.71828. |\n//! | `HASH_ALGORITHM` | The hash algorithm used to generate the hash. The default is Blake3. |\n//! | `HASH_COST` | The cost of the hash. |\n//! | `HASH_LENGTH` | The length of the hash. |\n//! | `PHI` | The golden ratio is a number approximately equal to 1.618033988749895. |\n//! | `PI` | Pi is the ratio of a circle's circumference to its diameter. |\n//! | `PLANCK` | Planck's constant is a physical constant that is approximately equal to 6.62607015 Ã— 10âˆ’34 joule seconds. |\n//! | `SQRT5` | The square root of 5 is a number approximately equal to 2.23606797749979. |\n//! | `SPECIAL_CHARS` | A list of special characters. |\n//!\n//! The following table lists the dictionaries available in the Common\n//! library.\n//!\n//! | Words | Description |\n//! | --- | --- |\n//! | `words` | Contains a dictionary of common words. |\n//!\n//! ## Usage\n//!\n//! Common can be any `serde::Serialize` or `serde::Deserialize` types\n//!\n//! ## Examples\n//!\n//! ```rust\n//!\n//! // Import the Common libraries\n//! use self::cmn::Constants;\n//! use self::cmn::Words;\n//!\n//! // Constants\n//! let constants = Constants.constants();\n//! for constant in constants {\n//!     println!(\"Name: {} Value: {}\", constant.name, constant.value);\n//! }\n//!\n//! // Words\n//! let words = Words::new();\n//! let words_list = words.words_list();\n//! assert_eq!(words_list[0], \"aboard\");\n//!\n//! ```\n//!\n#![warn(missing_docs)]\n#![forbid(unsafe_code)]\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cmn.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cmn.svg\",\n    html_root_url = \"https://docs.rs/cmn\"\n)]\n#![crate_name = \"cmn\"]\n#![crate_type = \"lib\"]\n\nextern crate serde;\npub use serde::{Deserialize, Serialize};\n\n/// The `constants` module contains the `Constants` structure, which\n/// provides a collection of constant values that are used throughout\n/// the library.\npub mod constants;\n\n/// The `words` module contains the `Words` structure, which provides a\n/// collection of words that are used throughout the library.\npub mod words;\n\npub use constants::Constants;\npub use words::Words;\n\n/// The `Common` structure provides a central location to store data\n/// that is commonly used throughout the library. The structure\n/// implements the `Serialize` and `Deserialize` traits from the `serde`\n/// crate to enable serialization and deserialization of the data.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Common;\n\nimpl Common {\n    /// Creates a new instance of the `Common` structure.\n    pub fn new() -\u003e Self {\n        Self\n    }\n    /// Returns the `Constants` instance.\n    pub fn constants(\u0026self) -\u003e Constants {\n        Constants\n    }\n    /// Returns a new instance of the `Words` structure.\n    pub fn words(\u0026self) -\u003e Words {\n        Words::new()\n    }\n}\n\nimpl Default for Common {\n    /// Creates a new instance of the `Common` structure by calling\n    /// `Self::new()`.\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","src","words.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n/// Contains several words for use in generating passphrases.\npub struct Words;\n\nimpl Words {\n    /// Creates a new instance of `Words`.\n    pub fn new() -\u003e Self {\n        Words\n    }\n    /// Returns a list of words for use in generating passphrases.\n    pub fn words_list(\u0026self) -\u003e \u0026'static [\u0026'static str] {\n        WORD_LIST\n    }\n}\n\nimpl Default for Words {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// The list of words.\npub const WORD_LIST: \u0026[\u0026str] = \u0026[\n    \"aboard\", \"abode\", \"abort\", \"abound\", \"about\", \"above\", \"abroad\", \"abrupt\", \"absent\", \"absorb\",\n    \"absurd\", \"abuse\", \"accent\", \"accept\", \"access\", \"accord\", \"accuse\", \"ace\", \"ache\", \"aching\",\n    \"acid\", \"acidic\", \"acorn\", \"acre\", \"across\", \"act\", \"action\", \"active\", \"actor\", \"actual\",\n    \"acute\", \"adapt\", \"add\", \"added\", \"addict\", \"adept\", \"adhere\", \"adjust\", \"admire\", \"admit\",\n    \"adam\", \"afghan\", \"alaska\", \"alice\", \"allah\", \"amazon\", \"andrew\", \"anglo\", \"angola\", \"antony\",\n    \"adobe\", \"adopt\", \"adrift\", \"adult\", \"adverb\", \"advert\", \"aerial\", \"afar\", \"affair\", \"affect\",\n    \"afford\", \"afield\", \"afloat\", \"afraid\", \"afresh\", \"after\", \"again\", \"age\", \"agency\", \"agenda\",\n    \"agent\", \"aghast\", \"agile\", \"ago\", \"agony\", \"agree\", \"agreed\", \"ahead\", \"aid\", \"aide\", \"aim\",\n    \"air\", \"airman\", \"airy\", \"akin\", \"alarm\", \"albeit\", \"album\", \"alert\", \"alibi\", \"alien\",\n    \"alight\", \"align\", \"alike\", \"alive\", \"alkali\", \"all\", \"alley\", \"allied\", \"allow\", \"alloy\",\n    \"ally\", \"almond\", \"almost\", \"aloft\", \"alone\", \"along\", \"aloof\", \"aloud\", \"alpha\", \"alpine\",\n    \"also\", \"altar\", \"alter\", \"always\", \"amaze\", \"amber\", \"ambush\", \"amen\", \"amend\", \"amid\",\n    \"amidst\", \"amiss\", \"among\", \"amount\", \"ample\", \"amuse\", \"anchor\", \"and\", \"anew\", \"angel\",\n    \"anger\", \"angle\", \"angry\", \"animal\", \"ankle\", \"annoy\", \"annual\", \"answer\", \"anthem\", \"anti\",\n    \"any\", \"anyhow\", \"anyway\", \"apart\", \"apathy\", \"apex\", \"apiece\", \"appeal\", \"appear\", \"apple\",\n    \"apply\", \"apron\", \"arcade\", \"arcane\", \"arch\", \"ardent\", \"are\", \"area\", \"argue\", \"arid\",\n    \"april\", \"arab\", \"arctic\", \"athens\", \"austin\", \"bach\", \"baltic\", \"basque\", \"berlin\", \"bible\",\n    \"arise\", \"arm\", \"armful\", \"armpit\", \"army\", \"aroma\", \"around\", \"arouse\", \"array\", \"arrest\",\n    \"arrive\", \"arrow\", \"arson\", \"art\", \"artery\", \"artful\", \"artist\", \"ascent\", \"ashen\", \"ashore\",\n    \"aside\", \"ask\", \"asleep\", \"aspect\", \"assay\", \"assent\", \"assert\", \"assess\", \"asset\", \"assign\",\n    \"assist\", \"assume\", \"assure\", \"asthma\", \"astute\", \"asylum\", \"ate\", \"atlas\", \"atom\", \"atomic\",\n    \"attach\", \"attack\", \"attain\", \"attend\", \"attic\", \"auburn\", \"audio\", \"audit\", \"august\", \"aunt\",\n    \"auntie\", \"aura\", \"author\", \"auto\", \"autumn\", \"avail\", \"avenge\", \"avenue\", \"avert\", \"avid\",\n    \"avoid\", \"await\", \"awake\", \"awaken\", \"award\", \"aware\", \"awash\", \"away\", \"awful\", \"awhile\",\n    \"axes\", \"axiom\", \"axis\", \"axle\", \"aye\", \"babe\", \"baby\", \"back\", \"backup\", \"bacon\", \"bad\",\n    \"badge\", \"badly\", \"bag\", \"baggy\", \"bail\", \"bait\", \"bake\", \"baker\", \"bakery\", \"bald\", \"ball\",\n    \"ballad\", \"ballet\", \"ballot\", \"bamboo\", \"ban\", \"banal\", \"banana\", \"band\", \"bang\", \"bank\",\n    \"bar\", \"barber\", \"bare\", \"barely\", \"barge\", \"bark\", \"barley\", \"barn\", \"baron\", \"barrel\",\n    \"barren\", \"basalt\", \"base\", \"basic\", \"basil\", \"basin\", \"basis\", \"basket\", \"bass\", \"bat\",\n    \"batch\", \"bath\", \"baton\", \"battle\", \"bay\", \"beach\", \"beacon\", \"beak\", \"beam\", \"bean\", \"bear\",\n    \"beard\", \"beast\", \"beat\", \"beauty\", \"become\", \"bed\", \"beech\", \"beef\", \"beefy\", \"beep\", \"beer\",\n    \"beet\", \"beetle\", \"before\", \"beggar\", \"begin\", \"behalf\", \"behave\", \"behind\", \"beige\", \"being\",\n    \"belief\", \"bell\", \"belly\", \"belong\", \"below\", \"belt\", \"bench\", \"bend\", \"benign\", \"bent\",\n    \"berry\", \"berth\", \"beset\", \"beside\", \"best\", \"bestow\", \"bet\", \"beta\", \"betray\", \"better\",\n    \"beware\", \"beyond\", \"bias\", \"biceps\", \"bicker\", \"bid\", \"big\", \"bigger\", \"bike\", \"bile\", \"bill\",\n    \"binary\", \"bind\", \"biopsy\", \"birch\", \"bird\", \"birdie\", \"birth\", \"bishop\", \"bit\", \"bitch\",\n    \"bite\", \"bitter\", \"black\", \"blade\", \"blame\", \"bland\", \"blast\", \"blaze\", \"bleak\", \"blend\",\n    \"bless\", \"blew\", \"blind\", \"blink\", \"blip\", \"bliss\", \"blitz\", \"block\", \"blond\", \"blood\",\n    \"bloody\", \"bloom\", \"blot\", \"blouse\", \"blow\", \"blue\", \"bluff\", \"blunt\", \"blur\", \"blush\", \"boar\",\n    \"board\", \"boast\", \"boat\", \"bodily\", \"body\", \"bogus\", \"boil\", \"bold\", \"bolt\", \"bomb\", \"bond\",\n    \"bombay\", \"bonn\", \"boston\", \"brazil\", \"briton\", \"buddha\", \"burma\", \"caesar\", \"cairo\", \"canada\",\n    \"bone\", \"bonnet\", \"bonus\", \"bony\", \"book\", \"boom\", \"boost\", \"boot\", \"booth\", \"booze\", \"border\",\n    \"bore\", \"borrow\", \"bosom\", \"boss\", \"both\", \"bother\", \"bottle\", \"bottom\", \"bought\", \"bounce\",\n    \"bound\", \"bounty\", \"bout\", \"bovine\", \"bow\", \"bowel\", \"bowl\", \"box\", \"boy\", \"boyish\", \"brace\",\n    \"brain\", \"brainy\", \"brake\", \"bran\", \"branch\", \"brand\", \"brandy\", \"brass\", \"brave\", \"bravo\",\n    \"breach\", \"bread\", \"break\", \"breast\", \"breath\", \"bred\", \"breed\", \"breeze\", \"brew\", \"brick\",\n    \"bride\", \"bridge\", \"brief\", \"bright\", \"brim\", \"brine\", \"bring\", \"brink\", \"brisk\", \"broad\",\n    \"broke\", \"broken\", \"bronze\", \"brook\", \"broom\", \"brown\", \"bruise\", \"brush\", \"brutal\", \"brute\",\n    \"bubble\", \"buck\", \"bucket\", \"buckle\", \"budget\", \"buffet\", \"buggy\", \"build\", \"bulb\", \"bulge\",\n    \"bulk\", \"bulky\", \"bull\", \"bullet\", \"bully\", \"bump\", \"bumpy\", \"bunch\", \"bundle\", \"bunk\",\n    \"bunny\", \"burden\", \"bureau\", \"burial\", \"buried\", \"burly\", \"burn\", \"burnt\", \"burrow\", \"burst\",\n    \"bury\", \"bus\", \"bush\", \"bust\", \"bustle\", \"busy\", \"but\", \"butler\", \"butt\", \"butter\", \"button\",\n    \"buy\", \"buyer\", \"buzz\", \"bye\", \"byte\", \"cab\", \"cabin\", \"cable\", \"cache\", \"cactus\", \"cage\",\n    \"cake\", \"calf\", \"call\", \"caller\", \"calm\", \"calmly\", \"came\", \"camel\", \"camera\", \"camp\",\n    \"campus\", \"can\", \"canal\", \"canary\", \"cancel\", \"cancer\", \"candid\", \"candle\", \"candy\", \"cane\",\n    \"canine\", \"canoe\", \"canopy\", \"canvas\", \"canyon\", \"cap\", \"cape\", \"car\", \"carbon\", \"card\",\n    \"care\", \"career\", \"caress\", \"cargo\", \"carnal\", \"carp\", \"carpet\", \"carrot\", \"carry\", \"cart\",\n    \"carl\", \"carol\", \"celtic\", \"chile\", \"china\", \"christ\", \"congo\", \"cuba\", \"cyprus\", \"czech\",\n    \"cartel\", \"case\", \"cash\", \"cask\", \"cast\", \"castle\", \"casual\", \"cat\", \"catch\", \"cater\",\n    \"cattle\", \"caught\", \"causal\", \"cause\", \"cave\", \"cease\", \"celery\", \"cell\", \"cellar\", \"cement\",\n    \"censor\", \"census\", \"cereal\", \"cervix\", \"chain\", \"chair\", \"chalk\", \"chalky\", \"champ\", \"chance\",\n    \"change\", \"chant\", \"chaos\", \"chap\", \"chapel\", \"charge\", \"charm\", \"chart\", \"chase\", \"chat\",\n    \"cheap\", \"cheat\", \"check\", \"cheek\", \"cheeky\", \"cheer\", \"cheery\", \"cheese\", \"chef\", \"cherry\",\n    \"chess\", \"chest\", \"chew\", \"chic\", \"chick\", \"chief\", \"child\", \"chill\", \"chilly\", \"chin\", \"chip\",\n    \"choice\", \"choir\", \"choose\", \"chop\", \"choppy\", \"chord\", \"chorus\", \"chose\", \"chosen\", \"chrome\",\n    \"chunk\", \"chunky\", \"church\", \"cider\", \"cigar\", \"cinema\", \"circa\", \"circle\", \"circus\", \"cite\",\n    \"city\", \"civic\", \"civil\", \"clad\", \"claim\", \"clammy\", \"clan\", \"clap\", \"clash\", \"clasp\", \"class\",\n    \"clause\", \"claw\", \"clay\", \"clean\", \"clear\", \"clergy\", \"clerk\", \"clever\", \"click\", \"client\",\n    \"cliff\", \"climax\", \"climb\", \"clinch\", \"cling\", \"clinic\", \"clip\", \"cloak\", \"clock\", \"clone\",\n    \"close\", \"closer\", \"closet\", \"cloth\", \"cloud\", \"cloudy\", \"clout\", \"clown\", \"club\", \"clue\",\n    \"clumsy\", \"clung\", \"clutch\", \"coach\", \"coal\", \"coarse\", \"coast\", \"coat\", \"coax\", \"cobalt\",\n    \"cobra\", \"coca\", \"cock\", \"cocoa\", \"code\", \"coffee\", \"coffin\", \"cohort\", \"coil\", \"coin\", \"coke\",\n    \"cold\", \"collar\", \"colon\", \"colony\", \"colt\", \"column\", \"comb\", \"combat\", \"come\", \"comedy\",\n    \"comic\", \"commit\", \"common\", \"compel\", \"comply\", \"concur\", \"cone\", \"confer\", \"consul\",\n    \"convex\", \"convey\", \"convoy\", \"cook\", \"cool\", \"cope\", \"copper\", \"copy\", \"coral\", \"cord\",\n    \"core\", \"cork\", \"corn\", \"corner\", \"corps\", \"corpse\", \"corpus\", \"cortex\", \"cosmic\", \"cosmos\",\n    \"cost\", \"costly\", \"cosy\", \"cotton\", \"couch\", \"cough\", \"could\", \"count\", \"county\", \"coup\",\n    \"couple\", \"coupon\", \"course\", \"court\", \"cousin\", \"cove\", \"cover\", \"covert\", \"cow\", \"coward\",\n    \"cowboy\", \"crab\", \"crack\", \"cradle\", \"craft\", \"crafty\", \"crag\", \"crane\", \"crap\", \"crash\",\n    \"crate\", \"crater\", \"crawl\", \"crazy\", \"creak\", \"cream\", \"creamy\", \"create\", \"credit\", \"creed\",\n    \"creek\", \"creep\", \"creepy\", \"crept\", \"crest\", \"crew\", \"cried\", \"crime\", \"crisis\", \"crisp\",\n    \"critic\", \"croft\", \"crook\", \"crop\", \"cross\", \"crow\", \"crowd\", \"crown\", \"crude\", \"cruel\",\n    \"cruise\", \"crunch\", \"crush\", \"crust\", \"crux\", \"cry\", \"crypt\", \"cube\", \"cubic\", \"cuckoo\",\n    \"cuff\", \"cult\", \"cup\", \"curb\", \"cure\", \"curfew\", \"curl\", \"curry\", \"curse\", \"cursor\", \"curve\",\n    \"custom\", \"cut\", \"cute\", \"cycle\", \"cyclic\", \"cynic\", \"dad\", \"daddy\", \"dagger\", \"daily\",\n    \"dairy\", \"daisy\", \"dale\", \"damage\", \"damn\", \"damp\", \"dampen\", \"dance\", \"danger\", \"dare\",\n    \"dallas\", \"danish\", \"darwin\", \"david\", \"delhi\", \"derby\", \"diana\", \"dublin\", \"dutch\", \"east\",\n    \"dark\", \"darken\", \"dash\", \"data\", \"date\", \"dawn\", \"day\", \"dead\", \"deadly\", \"deaf\", \"deal\",\n    \"dealer\", \"dean\", \"dear\", \"death\", \"debate\", \"debit\", \"debris\", \"debt\", \"debtor\", \"decade\",\n    \"decay\", \"decent\", \"decide\", \"deck\", \"decor\", \"decree\", \"deduce\", \"deed\", \"deep\", \"deeply\",\n    \"deer\", \"defeat\", \"defect\", \"defend\", \"defer\", \"define\", \"defy\", \"degree\", \"deity\", \"delay\",\n    \"delete\", \"delta\", \"demand\", \"demise\", \"demo\", \"demon\", \"demure\", \"denial\", \"denote\", \"dense\",\n    \"dental\", \"deny\", \"depart\", \"depend\", \"depict\", \"deploy\", \"depot\", \"depth\", \"deputy\", \"derive\",\n    \"desert\", \"design\", \"desire\", \"desist\", \"desk\", \"detail\", \"detect\", \"deter\", \"detest\",\n    \"detour\", \"device\", \"devil\", \"devise\", \"devoid\", \"devote\", \"devour\", \"dial\", \"diary\", \"dice\",\n    \"dictum\", \"did\", \"die\", \"diesel\", \"diet\", \"differ\", \"digest\", \"digit\", \"dine\", \"dinghy\",\n    \"dinner\", \"diode\", \"dire\", \"direct\", \"dirt\", \"dirty\", \"disc\", \"disco\", \"dish\", \"disk\",\n    \"dismal\", \"dispel\", \"ditch\", \"dive\", \"divert\", \"divide\", \"divine\", \"dizzy\", \"docile\", \"dock\",\n    \"doctor\", \"dog\", \"dogma\", \"dole\", \"doll\", \"dollar\", \"dolly\", \"domain\", \"dome\", \"domino\",\n    \"donate\", \"done\", \"donkey\", \"donor\", \"doom\", \"door\", \"dorsal\", \"dose\", \"double\", \"doubt\",\n    \"dough\", \"dour\", \"dove\", \"down\", \"dozen\", \"draft\", \"drag\", \"dragon\", \"drain\", \"drama\", \"drank\",\n    \"draw\", \"drawer\", \"dread\", \"dream\", \"dreary\", \"dress\", \"drew\", \"dried\", \"drift\", \"drill\",\n    \"drink\", \"drip\", \"drive\", \"driver\", \"drop\", \"drove\", \"drown\", \"drug\", \"drum\", \"drunk\", \"dry\",\n    \"dual\", \"duck\", \"duct\", \"due\", \"duel\", \"duet\", \"duke\", \"dull\", \"duly\", \"dumb\", \"dummy\", \"dump\",\n    \"dune\", \"dung\", \"duress\", \"during\", \"dusk\", \"dust\", \"dusty\", \"duty\", \"dwarf\", \"dwell\", \"dyer\",\n    \"dying\", \"dynamo\", \"each\", \"eager\", \"eagle\", \"ear\", \"earl\", \"early\", \"earn\", \"earth\", \"ease\",\n    \"easel\", \"easily\", \"easter\", \"easy\", \"eat\", \"eaten\", \"eater\", \"echo\", \"eddy\", \"edge\", \"edible\",\n    \"eden\", \"edward\", \"eric\", \"essex\", \"europe\", \"eve\", \"exodus\", \"france\", \"french\", \"friday\",\n    \"edict\", \"edit\", \"editor\", \"eerie\", \"eerily\", \"effect\", \"effort\", \"egg\", \"ego\", \"eight\",\n    \"eighth\", \"eighty\", \"either\", \"elbow\", \"elder\", \"eldest\", \"elect\", \"eleven\", \"elicit\", \"elite\",\n    \"else\", \"elude\", \"elves\", \"embark\", \"emblem\", \"embryo\", \"emerge\", \"emit\", \"empire\", \"employ\",\n    \"empty\", \"enable\", \"enamel\", \"end\", \"endure\", \"enemy\", \"energy\", \"engage\", \"engine\", \"enjoy\",\n    \"enlist\", \"enough\", \"ensure\", \"entail\", \"enter\", \"entire\", \"entry\", \"envoy\", \"envy\", \"enzyme\",\n    \"epic\", \"epoch\", \"equal\", \"equate\", \"equip\", \"equity\", \"era\", \"erase\", \"erect\", \"erode\",\n    \"erotic\", \"errant\", \"error\", \"escape\", \"escort\", \"essay\", \"estate\", \"esteem\", \"ethic\",\n    \"ethnic\", \"evade\", \"even\", \"event\", \"ever\", \"every\", \"evict\", \"evil\", \"evoke\", \"evolve\",\n    \"exact\", \"exam\", \"exceed\", \"excel\", \"except\", \"excess\", \"excise\", \"excite\", \"excuse\", \"exempt\",\n    \"exert\", \"exile\", \"exist\", \"exit\", \"exotic\", \"expand\", \"expect\", \"expert\", \"expire\", \"export\",\n    \"expose\", \"extend\", \"extra\", \"eye\", \"eyed\", \"fabric\", \"face\", \"facial\", \"fact\", \"factor\",\n    \"fade\", \"fail\", \"faint\", \"fair\", \"fairly\", \"fairy\", \"faith\", \"fake\", \"falcon\", \"fall\", \"false\",\n    \"falter\", \"fame\", \"family\", \"famine\", \"famous\", \"fan\", \"fancy\", \"far\", \"farce\", \"fare\", \"farm\",\n    \"farmer\", \"fast\", \"fasten\", \"faster\", \"fat\", \"fatal\", \"fate\", \"father\", \"fatty\", \"fault\",\n    \"faulty\", \"fauna\", \"fear\", \"feast\", \"feat\", \"fed\", \"fee\", \"feeble\", \"feed\", \"feel\", \"feet\",\n    \"fell\", \"fellow\", \"felt\", \"female\", \"fence\", \"fend\", \"ferry\", \"fetal\", \"fetch\", \"feudal\",\n    \"fever\", \"few\", \"fewer\", \"fiance\", \"fiasco\", \"fiddle\", \"field\", \"fiend\", \"fierce\", \"fiery\",\n    \"fifth\", \"fifty\", \"fig\", \"fight\", \"figure\", \"file\", \"fill\", \"filled\", \"filler\", \"film\",\n    \"filter\", \"filth\", \"filthy\", \"final\", \"finale\", \"find\", \"fine\", \"finger\", \"finish\", \"finite\",\n    \"fire\", \"firm\", \"firmly\", \"first\", \"fiscal\", \"fish\", \"fisher\", \"fist\", \"fit\", \"fitful\", \"five\",\n    \"fix\", \"flag\", \"flair\", \"flak\", \"flame\", \"flank\", \"flap\", \"flare\", \"flash\", \"flask\", \"flat\",\n    \"flaw\", \"fled\", \"flee\", \"fleece\", \"fleet\", \"flesh\", \"fleshy\", \"flew\", \"flick\", \"flight\",\n    \"flimsy\", \"flint\", \"flirt\", \"float\", \"flock\", \"flood\", \"floor\", \"floppy\", \"flora\", \"floral\",\n    \"flour\", \"flow\", \"flower\", \"fluent\", \"fluffy\", \"fluid\", \"flung\", \"flurry\", \"flush\", \"flute\",\n    \"flux\", \"fly\", \"flyer\", \"foal\", \"foam\", \"focal\", \"focus\", \"fog\", \"foil\", \"fold\", \"folk\",\n    \"follow\", \"folly\", \"fond\", \"fondly\", \"font\", \"food\", \"fool\", \"foot\", \"for\", \"forbid\", \"force\",\n    \"ford\", \"forest\", \"forge\", \"forget\", \"fork\", \"form\", \"formal\", \"format\", \"former\", \"fort\",\n    \"forth\", \"forty\", \"forum\", \"fossil\", \"foster\", \"foul\", \"found\", \"four\", \"fourth\", \"fox\",\n    \"foyer\", \"frail\", \"frame\", \"franc\", \"frank\", \"fraud\", \"free\", \"freed\", \"freely\", \"freer\",\n    \"freeze\", \"frenzy\", \"fresh\", \"friar\", \"fridge\", \"fried\", \"friend\", \"fright\", \"fringe\", \"frock\",\n    \"frog\", \"from\", \"front\", \"frost\", \"frosty\", \"frown\", \"frozen\", \"frugal\", \"fruit\", \"fudge\",\n    \"fuel\", \"fulfil\", \"full\", \"fully\", \"fun\", \"fund\", \"funny\", \"fur\", \"furry\", \"fury\", \"fuse\",\n    \"fusion\", \"fuss\", \"fussy\", \"futile\", \"future\", \"fuzzy\", \"gadget\", \"gag\", \"gain\", \"gala\",\n    \"galaxy\", \"gale\", \"gall\", \"galley\", \"gallon\", \"gallop\", \"gamble\", \"game\", \"gamma\", \"gang\",\n    \"gandhi\", \"gaul\", \"gemini\", \"geneva\", \"george\", \"german\", \"gloria\", \"god\", \"gothic\", \"greece\",\n    \"gap\", \"garage\", \"garden\", \"garlic\", \"gas\", \"gasp\", \"gate\", \"gather\", \"gauge\", \"gaunt\", \"gave\",\n    \"gay\", \"gaze\", \"gear\", \"geese\", \"gender\", \"gene\", \"genial\", \"genius\", \"genre\", \"gentle\",\n    \"gently\", \"gentry\", \"genus\", \"get\", \"ghetto\", \"ghost\", \"giant\", \"gift\", \"giggle\", \"gill\",\n    \"gilt\", \"ginger\", \"girl\", \"give\", \"given\", \"glad\", \"glade\", \"glance\", \"gland\", \"glare\",\n    \"glass\", \"glassy\", \"gleam\", \"glee\", \"glide\", \"global\", \"globe\", \"gloom\", \"gloomy\", \"glory\",\n    \"gloss\", \"glossy\", \"glove\", \"glow\", \"glue\", \"goal\", \"goat\", \"gold\", \"golden\", \"golf\", \"gone\",\n    \"gong\", \"good\", \"goose\", \"gorge\", \"gory\", \"gosh\", \"gospel\", \"gossip\", \"got\", \"govern\", \"gown\",\n    \"grab\", \"grace\", \"grade\", \"grain\", \"grand\", \"grant\", \"grape\", \"graph\", \"grasp\", \"grass\",\n    \"grassy\", \"grate\", \"grave\", \"gravel\", \"gravy\", \"gray\", \"grease\", \"greasy\", \"great\", \"greed\",\n    \"greedy\", \"green\", \"greet\", \"grew\", \"grey\", \"grid\", \"grief\", \"grill\", \"grim\", \"grin\", \"grind\",\n    \"greek\", \"hague\", \"haiti\", \"hanoi\", \"harry\", \"havana\", \"hawaii\", \"hebrew\", \"henry\", \"hermes\",\n    \"grip\", \"grit\", \"gritty\", \"groan\", \"groin\", \"groom\", \"groove\", \"gross\", \"ground\", \"group\",\n    \"grove\", \"grow\", \"grown\", \"growth\", \"grudge\", \"grunt\", \"guard\", \"guess\", \"guest\", \"guide\",\n    \"guild\", \"guilt\", \"guilty\", \"guise\", \"guitar\", \"gulf\", \"gully\", \"gun\", \"gunman\", \"guru\", \"gut\",\n    \"guy\", \"gypsy\", \"habit\", \"hack\", \"had\", \"hail\", \"hair\", \"hairy\", \"hale\", \"half\", \"hall\",\n    \"halt\", \"hamlet\", \"hammer\", \"hand\", \"handle\", \"handy\", \"hang\", \"hangar\", \"happen\", \"happy\",\n    \"harass\", \"hard\", \"harder\", \"hardly\", \"hare\", \"harem\", \"harm\", \"harp\", \"harsh\", \"has\", \"hash\",\n    \"hassle\", \"haste\", \"hasten\", \"hasty\", \"hat\", \"hatch\", \"hate\", \"haul\", \"haunt\", \"have\", \"haven\",\n    \"havoc\", \"hawk\", \"hazard\", \"haze\", \"hazel\", \"hazy\", \"head\", \"heal\", \"health\", \"heap\", \"hear\",\n    \"heard\", \"heart\", \"hearth\", \"hearty\", \"heat\", \"heater\", \"heaven\", \"heavy\", \"heck\", \"hectic\",\n    \"hedge\", \"heel\", \"hefty\", \"height\", \"heir\", \"held\", \"helium\", \"helix\", \"hell\", \"hello\", \"helm\",\n    \"helmet\", \"help\", \"hemp\", \"hence\", \"her\", \"herald\", \"herb\", \"herd\", \"here\", \"hereby\", \"hernia\",\n    \"hero\", \"heroic\", \"heroin\", \"hey\", \"heyday\", \"hick\", \"hidden\", \"hide\", \"high\", \"higher\",\n    \"highly\", \"hill\", \"him\", \"hind\", \"hint\", \"hippy\", \"hire\", \"his\", \"hiss\", \"hit\", \"hive\",\n    \"hindu\", \"hitler\", \"idaho\", \"inca\", \"india\", \"indian\", \"iowa\", \"iran\", \"iraq\", \"irish\",\n    \"hoard\", \"hoarse\", \"hobby\", \"hockey\", \"hold\", \"holder\", \"hole\", \"hollow\", \"holly\", \"holy\",\n    \"home\", \"honest\", \"honey\", \"hood\", \"hook\", \"hope\", \"horn\", \"horny\", \"horrid\", \"horror\",\n    \"horse\", \"hose\", \"host\", \"hot\", \"hotel\", \"hound\", \"hour\", \"house\", \"hover\", \"how\", \"huge\",\n    \"hull\", \"human\", \"humane\", \"humble\", \"humid\", \"hung\", \"hunger\", \"hungry\", \"hunt\", \"hurdle\",\n    \"hurl\", \"hurry\", \"hurt\", \"hush\", \"hut\", \"hybrid\", \"hymn\", \"hyphen\", \"ice\", \"icing\", \"icon\",\n    \"idea\", \"ideal\", \"idiom\", \"idiot\", \"idle\", \"idly\", \"idol\", \"ignite\", \"ignore\", \"ill\", \"image\",\n    \"immune\", \"impact\", \"imply\", \"import\", \"impose\", \"incest\", \"inch\", \"income\", \"incur\", \"indeed\",\n    \"index\", \"indoor\", \"induce\", \"inept\", \"inert\", \"infant\", \"infect\", \"infer\", \"influx\", \"inform\",\n    \"inject\", \"injure\", \"injury\", \"inlaid\", \"inland\", \"inlet\", \"inmate\", \"inn\", \"innate\", \"inner\",\n    \"input\", \"insane\", \"insect\", \"insert\", \"inset\", \"inside\", \"insist\", \"insult\", \"insure\",\n    \"intact\", \"intake\", \"intend\", \"inter\", \"into\", \"invade\", \"invent\", \"invest\", \"invite\",\n    \"invoke\", \"inward\", \"iron\", \"ironic\", \"irony\", \"island\", \"isle\", \"issue\", \"itch\", \"item\",\n    \"isaac\", \"isabel\", \"islam\", \"israel\", \"italy\", \"ivan\", \"jack\", \"jacob\", \"james\", \"japan\",\n    \"itself\", \"ivory\", \"jacket\", \"jade\", \"jaguar\", \"jail\", \"jargon\", \"jaw\", \"jazz\", \"jeep\", \"java\",\n    \"jersey\", \"jesus\", \"jewish\", \"jim\", \"john\", \"jordan\", \"joseph\", \"judas\", \"judy\", \"jelly\",\n    \"jerky\", \"jest\", \"jet\", \"jewel\", \"job\", \"jock\", \"jockey\", \"join\", \"joint\", \"joke\", \"jolly\",\n    \"jolt\", \"joy\", \"joyful\", \"joyous\", \"judge\", \"juice\", \"juicy\", \"jumble\", \"jumbo\", \"july\",\n    \"june\", \"kansas\", \"karl\", \"kenya\", \"koran\", \"korea\", \"kuwait\", \"laos\", \"latin\", \"leo\", \"jump\",\n    \"jungle\", \"junior\", \"junk\", \"junta\", \"jury\", \"just\", \"karate\", \"keel\", \"keen\", \"keep\",\n    \"keeper\", \"kept\", \"kernel\", \"kettle\", \"key\", \"khaki\", \"kick\", \"kid\", \"kidnap\", \"kidney\",\n    \"kill\", \"killer\", \"kin\", \"kind\", \"kindly\", \"king\", \"kiss\", \"kite\", \"kitten\", \"knack\", \"knee\",\n    \"knew\", \"knife\", \"knight\", \"knit\", \"knob\", \"knock\", \"knot\", \"know\", \"known\", \"label\", \"lace\",\n    \"lack\", \"lad\", \"ladder\", \"laden\", \"lady\", \"lagoon\", \"laity\", \"lake\", \"lamb\", \"lame\", \"lamp\",\n    \"lance\", \"land\", \"lane\", \"lap\", \"lapse\", \"large\", \"larval\", \"laser\", \"last\", \"latch\", \"late\",\n    \"lately\", \"latent\", \"later\", \"latest\", \"latter\", \"laugh\", \"launch\", \"lava\", \"lavish\", \"law\",\n    \"lawful\", \"lawn\", \"lawyer\", \"lay\", \"layer\", \"layman\", \"lazy\", \"lead\", \"leader\", \"leaf\",\n    \"leafy\", \"league\", \"leak\", \"leaky\", \"lean\", \"leap\", \"learn\", \"lease\", \"leash\", \"least\",\n    \"leave\", \"led\", \"ledge\", \"left\", \"leg\", \"legacy\", \"legal\", \"legend\", \"legion\", \"lemon\", \"lend\",\n    \"length\", \"lens\", \"lent\", \"leper\", \"lesion\", \"less\", \"lessen\", \"lesser\", \"lesson\", \"lest\",\n    \"let\", \"lethal\", \"letter\", \"level\", \"lever\", \"levy\", \"lewis\", \"liable\", \"liar\", \"libel\",\n    \"libya\", \"lima\", \"lisbon\", \"liz\", \"london\", \"louvre\", \"lucy\", \"luther\", \"madame\", \"madrid\",\n    \"lice\", \"lick\", \"lid\", \"lie\", \"lied\", \"life\", \"lift\", \"light\", \"like\", \"likely\", \"limb\",\n    \"lime\", \"limit\", \"limp\", \"line\", \"linear\", \"linen\", \"linger\", \"link\", \"lion\", \"lip\", \"liquid\",\n    \"liquor\", \"list\", \"listen\", \"lit\", \"live\", \"lively\", \"liver\", \"lizard\", \"load\", \"loaf\", \"loan\",\n    \"lobby\", \"lobe\", \"local\", \"locate\", \"lock\", \"locus\", \"lodge\", \"loft\", \"lofty\", \"log\", \"logic\",\n    \"logo\", \"lone\", \"lonely\", \"long\", \"longer\", \"look\", \"loop\", \"loose\", \"loosen\", \"loot\", \"lord\",\n    \"lorry\", \"lose\", \"loss\", \"lost\", \"lot\", \"lotion\", \"lotus\", \"loud\", \"loudly\", \"lounge\", \"lousy\",\n    \"love\", \"lovely\", \"lover\", \"low\", \"lower\", \"lowest\", \"loyal\", \"lucid\", \"luck\", \"lucky\", \"lull\",\n    \"lump\", \"lumpy\", \"lunacy\", \"lunar\", \"lunch\", \"lung\", \"lure\", \"lurid\", \"lush\", \"lust\", \"lute\",\n    \"luxury\", \"lying\", \"lymph\", \"lynch\", \"lyric\", \"macho\", \"macro\", \"mad\", \"madam\", \"made\",\n    \"mafia\", \"magic\", \"magma\", \"magnet\", \"magnum\", \"maid\", \"maiden\", \"mail\", \"main\", \"mainly\",\n    \"major\", \"make\", \"maker\", \"male\", \"malice\", \"mall\", \"malt\", \"mammal\", \"manage\", \"mane\",\n    \"malta\", \"maria\", \"mars\", \"mary\", \"maya\", \"mecca\", \"mexico\", \"miami\", \"mickey\", \"milan\",\n    \"mania\", \"manic\", \"manner\", \"manor\", \"mantle\", \"manual\", \"manure\", \"many\", \"map\", \"maple\",\n    \"marble\", \"march\", \"mare\", \"margin\", \"marina\", \"mark\", \"market\", \"marry\", \"marsh\", \"martin\",\n    \"martyr\", \"mask\", \"mason\", \"mass\", \"mast\", \"master\", \"match\", \"mate\", \"matrix\", \"matter\",\n    \"mature\", \"maxim\", \"may\", \"maybe\", \"mayor\", \"maze\", \"mead\", \"meadow\", \"meal\", \"mean\", \"meant\",\n    \"meat\", \"medal\", \"media\", \"median\", \"medic\", \"medium\", \"meet\", \"mellow\", \"melody\", \"melon\",\n    \"melt\", \"member\", \"memo\", \"memory\", \"menace\", \"mend\", \"mental\", \"mentor\", \"menu\", \"mercy\",\n    \"mere\", \"merely\", \"merge\", \"merger\", \"merit\", \"merry\", \"mesh\", \"mess\", \"messy\", \"met\", \"metal\",\n    \"meter\", \"method\", \"methyl\", \"metric\", \"metro\", \"mid\", \"midday\", \"middle\", \"midst\", \"midway\",\n    \"might\", \"mighty\", \"mild\", \"mildew\", \"mile\", \"milk\", \"milky\", \"mill\", \"mimic\", \"mince\", \"mind\",\n    \"mine\", \"mini\", \"mink\", \"minor\", \"mint\", \"minus\", \"minute\", \"mirror\", \"mirth\", \"misery\",\n    \"miss\", \"mist\", \"misty\", \"mite\", \"mix\", \"moan\", \"moat\", \"mobile\", \"mock\", \"mode\", \"model\",\n    \"modem\", \"modern\", \"modest\", \"modify\", \"module\", \"moist\", \"molar\", \"mole\", \"molten\", \"moment\",\n    \"monaco\", \"monday\", \"moscow\", \"moses\", \"moslem\", \"mrs\", \"munich\", \"muslim\", \"naples\", \"nazi\",\n    \"money\", \"monies\", \"monk\", \"monkey\", \"month\", \"mood\", \"moody\", \"moon\", \"moor\", \"moral\",\n    \"morale\", \"morbid\", \"more\", \"morgue\", \"mortal\", \"mortar\", \"mosaic\", \"mosque\", \"moss\", \"most\",\n    \"mostly\", \"moth\", \"mother\", \"motion\", \"motive\", \"motor\", \"mould\", \"mount\", \"mourn\", \"mouse\",\n    \"mouth\", \"move\", \"movie\", \"much\", \"muck\", \"mucus\", \"mud\", \"muddle\", \"muddy\", \"mule\", \"mummy\",\n    \"murder\", \"murky\", \"murmur\", \"muscle\", \"museum\", \"music\", \"mussel\", \"must\", \"mutant\", \"mute\",\n    \"mutiny\", \"mutter\", \"mutton\", \"mutual\", \"muzzle\", \"myopic\", \"myriad\", \"myself\", \"mystic\",\n    \"myth\", \"nadir\", \"nail\", \"naked\", \"name\", \"namely\", \"nape\", \"napkin\", \"narrow\", \"nasal\",\n    \"nasty\", \"nation\", \"native\", \"nature\", \"nausea\", \"naval\", \"nave\", \"navy\", \"near\", \"nearer\",\n    \"nearly\", \"neat\", \"neatly\", \"neck\", \"need\", \"needle\", \"needy\", \"negate\", \"neon\", \"nephew\",\n    \"nepal\", \"newark\", \"nile\", \"nobel\", \"north\", \"norway\", \"ohio\", \"oscar\", \"oslo\", \"oxford\",\n    \"nerve\", \"nest\", \"neural\", \"never\", \"newly\", \"next\", \"nice\", \"nicely\", \"niche\", \"nickel\",\n    \"niece\", \"night\", \"nimble\", \"nine\", \"ninety\", \"ninth\", \"noble\", \"nobody\", \"node\", \"noise\",\n    \"noisy\", \"non\", \"none\", \"noon\", \"nor\", \"norm\", \"normal\", \"nose\", \"nosy\", \"not\", \"note\",\n    \"notice\", \"notify\", \"notion\", \"nought\", \"noun\", \"novel\", \"novice\", \"now\", \"nozzle\", \"nude\",\n    \"null\", \"numb\", \"number\", \"nurse\", \"nylon\", \"nymph\", \"oak\", \"oasis\", \"oath\", \"obese\", \"obey\",\n    \"object\", \"oblige\", \"oboe\", \"obtain\", \"occult\", \"occupy\", \"occur\", \"ocean\", \"octave\", \"odd\",\n    \"off\", \"offend\", \"offer\", \"office\", \"offset\", \"often\", \"oil\", \"oily\", \"okay\", \"old\", \"older\",\n    \"oldest\", \"olive\", \"omega\", \"omen\", \"omit\", \"once\", \"one\", \"onion\", \"only\", \"onset\", \"onto\",\n    \"onus\", \"onward\", \"opaque\", \"open\", \"openly\", \"opera\", \"opium\", \"oppose\", \"optic\", \"option\",\n    \"oracle\", \"oral\", \"orange\", \"orbit\", \"orchid\", \"ordeal\", \"order\", \"organ\", \"orgasm\", \"orient\",\n    \"origin\", \"ornate\", \"orphan\", \"other\", \"otter\", \"ought\", \"ounce\", \"our\", \"out\", \"outer\",\n    \"output\", \"outset\", \"oval\", \"oven\", \"over\", \"overt\", \"owe\", \"owing\", \"owl\", \"own\", \"owner\",\n    \"oxide\", \"oxygen\", \"oyster\", \"ozone\", \"pace\", \"pack\", \"packet\", \"pact\", \"paddle\", \"paddy\",\n    \"pagan\", \"page\", \"paid\", \"pain\", \"paint\", \"pair\", \"palace\", \"pale\", \"palm\", \"panel\", \"panic\",\n    \"panama\", \"paris\", \"pascal\", \"paul\", \"peking\", \"peru\", \"peter\", \"philip\", \"poland\", \"polish\",\n    \"papa\", \"papal\", \"paper\", \"parade\", \"parcel\", \"pardon\", \"parent\", \"parish\", \"park\", \"parody\",\n    \"parrot\", \"part\", \"partly\", \"party\", \"pass\", \"past\", \"paste\", \"pastel\", \"pastor\", \"pastry\",\n    \"pat\", \"patch\", \"patent\", \"path\", \"patio\", \"patrol\", \"patron\", \"pause\", \"pave\", \"pawn\", \"pay\",\n    \"peace\", \"peach\", \"peak\", \"pear\", \"pearl\", \"pedal\", \"peel\", \"peer\", \"pelvic\", \"pelvis\", \"pen\",\n    \"penal\", \"pence\", \"pencil\", \"penis\", \"penny\", \"people\", \"pepper\", \"per\", \"perch\", \"peril\",\n    \"period\", \"perish\", \"permit\", \"person\", \"pest\", \"petite\", \"petrol\", \"petty\", \"phase\", \"phone\",\n    \"photo\", \"phrase\", \"piano\", \"pick\", \"picket\", \"picnic\", \"pie\", \"piece\", \"pier\", \"pierce\",\n    \"piety\", \"pig\", \"pigeon\", \"piggy\", \"pike\", \"pile\", \"pill\", \"pillar\", \"pillow\", \"pilot\", \"pin\",\n    \"pinch\", \"pine\", \"pink\", \"pint\", \"pious\", \"pipe\", \"pirate\", \"piss\", \"pistol\", \"piston\", \"pit\",\n    \"pitch\", \"pity\", \"pivot\", \"pixel\", \"pizza\", \"place\", \"placid\", \"plague\", \"plain\", \"plan\",\n    \"plane\", \"planet\", \"plank\", \"plant\", \"plasma\", \"plate\", \"play\", \"player\", \"plea\", \"plead\",\n    \"please\", \"pledge\", \"plenty\", \"plenum\", \"plight\", \"plot\", \"ploy\", \"plug\", \"plum\", \"plump\",\n    \"plunge\", \"plural\", \"plus\", \"plush\", \"pocket\", \"poem\", \"poet\", \"poetic\", \"poetry\", \"point\",\n    \"poison\", \"polar\", \"pole\", \"police\", \"policy\", \"polite\", \"poll\", \"pollen\", \"polo\", \"pond\",\n    \"ponder\", \"pony\", \"pool\", \"poor\", \"poorly\", \"pop\", \"pope\", \"poppy\", \"pore\", \"pork\", \"port\",\n    \"portal\", \"pose\", \"posh\", \"post\", \"postal\", \"pot\", \"potato\", \"potent\", \"pouch\", \"pound\",\n    \"pour\", \"powder\", \"power\", \"praise\", \"pray\", \"prayer\", \"preach\", \"prefer\", \"prefix\", \"press\",\n    \"prague\", \"quebec\", \"rex\", \"rhine\", \"ritz\", \"robert\", \"roman\", \"rome\", \"rosa\", \"russia\",\n    \"pretty\", \"price\", \"pride\", \"priest\", \"primal\", \"prime\", \"prince\", \"print\", \"prior\", \"prism\",\n    \"prison\", \"privy\", \"prize\", \"probe\", \"profit\", \"prompt\", \"prone\", \"proof\", \"propel\", \"proper\",\n    \"prose\", \"proton\", \"proud\", \"prove\", \"proven\", \"proxy\", \"prune\", \"psalm\", \"pseudo\", \"psyche\",\n    \"pub\", \"public\", \"puff\", \"pull\", \"pulp\", \"pulpit\", \"pulsar\", \"pulse\", \"pump\", \"punch\",\n    \"punish\", \"punk\", \"pupil\", \"puppet\", \"puppy\", \"pure\", \"purely\", \"purge\", \"purify\", \"purple\",\n    \"purse\", \"pursue\", \"push\", \"pushy\", \"pussy\", \"put\", \"putt\", \"puzzle\", \"quaint\", \"quake\",\n    \"quarry\", \"quartz\", \"quay\", \"queen\", \"queer\", \"query\", \"quest\", \"queue\", \"quick\", \"quid\",\n    \"quiet\", \"quilt\", \"quirk\", \"quit\", \"quite\", \"quiver\", \"quiz\", \"quota\", \"quote\", \"rabbit\",\n    \"race\", \"racial\", \"racism\", \"rack\", \"racket\", \"radar\", \"radio\", \"radish\", \"radius\", \"raffle\",\n    \"raft\", \"rage\", \"raid\", \"rail\", \"rain\", \"rainy\", \"raise\", \"rally\", \"ramp\", \"random\", \"range\",\n    \"rank\", \"ransom\", \"rape\", \"rapid\", \"rare\", \"rarely\", \"rarity\", \"rash\", \"rat\", \"rate\", \"rather\",\n    \"ratify\", \"ratio\", \"rattle\", \"rave\", \"raven\", \"raw\", \"ray\", \"razor\", \"reach\", \"react\", \"read\",\n    \"reader\", \"ready\", \"real\", \"really\", \"realm\", \"reap\", \"rear\", \"reason\", \"rebel\", \"recall\",\n    \"recent\", \"recess\", \"recipe\", \"reckon\", \"record\", \"recoup\", \"rector\", \"red\", \"redeem\",\n    \"reduce\", \"reed\", \"reef\", \"refer\", \"reform\", \"refuge\", \"refuse\", \"regal\", \"regard\", \"regent\",\n    \"regime\", \"region\", \"regret\", \"reign\", \"reject\", \"relate\", \"relax\", \"relay\", \"relic\", \"relief\",\n    \"relish\", \"rely\", \"remain\", \"remark\", \"remedy\", \"remind\", \"remit\", \"remote\", \"remove\", \"renal\",\n    \"render\", \"rent\", \"rental\", \"repair\", \"repeal\", \"repeat\", \"repent\", \"reply\", \"report\",\n    \"rescue\", \"resent\", \"reside\", \"resign\", \"resin\", \"resist\", \"resort\", \"rest\", \"result\",\n    \"resume\", \"retail\", \"retain\", \"retina\", \"retire\", \"return\", \"reveal\", \"review\", \"revise\",\n    \"revive\", \"revolt\", \"reward\", \"rhino\", \"rhyme\", \"rhythm\", \"ribbon\", \"rice\", \"rich\", \"rick\",\n    \"rid\", \"ride\", \"rider\", \"ridge\", \"rife\", \"rifle\", \"rift\", \"right\", \"rigid\", \"ring\", \"rinse\",\n    \"riot\", \"ripe\", \"ripen\", \"ripple\", \"rise\", \"risk\", \"risky\", \"rite\", \"ritual\", \"rival\", \"river\",\n    \"road\", \"roar\", \"roast\", \"rob\", \"robe\", \"robin\", \"robot\", \"robust\", \"rock\", \"rocket\", \"rocky\",\n    \"rod\", \"rode\", \"rodent\", \"rogue\", \"role\", \"roll\", \"roof\", \"room\", \"root\", \"rope\", \"rose\",\n    \"rosy\", \"rotate\", \"rotor\", \"rotten\", \"rouge\", \"rough\", \"round\", \"route\", \"rover\", \"row\",\n    \"royal\", \"rubble\", \"ruby\", \"rudder\", \"rude\", \"rugby\", \"ruin\", \"rule\", \"ruler\", \"rumble\",\n    \"rump\", \"run\", \"rune\", \"rung\", \"runway\", \"rural\", \"rush\", \"rust\", \"rustic\", \"rusty\", \"sack\",\n    \"sacred\", \"sad\", \"saddle\", \"sadism\", \"sadly\", \"safari\", \"safe\", \"safely\", \"safer\", \"safety\",\n    \"saga\", \"sage\", \"said\", \"sail\", \"sailor\", \"saint\", \"sake\", \"salad\", \"salary\", \"sale\", \"saline\",\n    \"sahara\", \"sam\", \"saturn\", \"saudi\", \"saxon\", \"scot\", \"seoul\", \"somali\", \"sony\", \"soviet\",\n    \"saliva\", \"salmon\", \"saloon\", \"salt\", \"salty\", \"salute\", \"same\", \"sample\", \"sand\", \"sandy\",\n    \"sane\", \"sash\", \"satan\", \"satin\", \"satire\", \"sauce\", \"sauna\", \"savage\", \"save\", \"say\", \"scale\",\n    \"scalp\", \"scan\", \"scant\", \"scar\", \"scarce\", \"scare\", \"scarf\", \"scary\", \"scene\", \"scenic\",\n    \"scent\", \"school\", \"scope\", \"score\", \"scorn\", \"scotch\", \"scout\", \"scrap\", \"scream\", \"screen\",\n    \"screw\", \"script\", \"scroll\", \"scrub\", \"scum\", \"sea\", \"seal\", \"seam\", \"seaman\", \"search\",\n    \"season\", \"seat\", \"second\", \"secret\", \"sect\", \"sector\", \"secure\", \"see\", \"seed\", \"seeing\",\n    \"seek\", \"seem\", \"seize\", \"seldom\", \"select\", \"self\", \"sell\", \"seller\", \"semi\", \"senate\",\n    \"send\", \"senile\", \"senior\", \"sense\", \"sensor\", \"sent\", \"sentry\", \"sequel\", \"serene\", \"serial\",\n    \"series\", \"sermon\", \"serum\", \"serve\", \"server\", \"set\", \"settle\", \"seven\", \"severe\", \"sewage\",\n    \"sex\", \"sexual\", \"sexy\", \"shabby\", \"shade\", \"shadow\", \"shady\", \"shaft\", \"shaggy\", \"shah\",\n    \"shake\", \"shaky\", \"shall\", \"sham\", \"shame\", \"shape\", \"share\", \"shark\", \"sharp\", \"shawl\", \"she\",\n    \"shear\", \"sheen\", \"sheep\", \"sheer\", \"sheet\", \"shelf\", \"shell\", \"sherry\", \"shield\", \"shift\",\n    \"shine\", \"shiny\", \"ship\", \"shire\", \"shirt\", \"shit\", \"shiver\", \"shock\", \"shoe\", \"shook\",\n    \"shoot\", \"shop\", \"shore\", \"short\", \"shot\", \"should\", \"shout\", \"show\", \"shower\", \"shrank\",\n    \"shrewd\", \"shrill\", \"shrimp\", \"shrine\", \"shrink\", \"shrub\", \"shrug\", \"shut\", \"shy\", \"shyly\",\n    \"sick\", \"side\", \"siege\", \"sigh\", \"sight\", \"sigma\", \"sign\", \"signal\", \"silent\", \"silk\",\n    \"silken\", \"silky\", \"sill\", \"silly\", \"silver\", \"simple\", \"simply\", \"since\", \"sinful\", \"sing\",\n    \"singer\", \"single\", \"sink\", \"sir\", \"siren\", \"sister\", \"sit\", \"site\", \"six\", \"sixth\", \"sixty\",\n    \"size\", \"sketch\", \"skill\", \"skin\", \"skinny\", \"skip\", \"skirt\", \"skull\", \"sky\", \"slab\", \"slack\",\n    \"slain\", \"slam\", \"slang\", \"slap\", \"slate\", \"slater\", \"slave\", \"sleek\", \"sleep\", \"sleepy\",\n    \"sleeve\", \"slice\", \"slick\", \"slid\", \"slide\", \"slight\", \"slim\", \"slimy\", \"sling\", \"slip\",\n    \"slit\", \"slogan\", \"slope\", \"sloppy\", \"slot\", \"slow\", \"slowly\", \"slug\", \"slum\", \"slump\",\n    \"smack\", \"small\", \"smart\", \"smash\", \"smear\", \"smell\", \"smelly\", \"smelt\", \"smile\", \"smoke\",\n    \"smoky\", \"smooth\", \"smug\", \"snack\", \"snail\", \"snake\", \"snap\", \"snatch\", \"sneak\", \"snow\",\n    \"snowy\", \"snug\", \"soak\", \"soap\", \"sober\", \"soccer\", \"social\", \"sock\", \"socket\", \"soda\",\n    \"sodden\", \"sodium\", \"sofa\", \"soft\", \"soften\", \"softly\", \"soggy\", \"soil\", \"solar\", \"sold\",\n    \"sole\", \"solely\", \"solemn\", \"solid\", \"solo\", \"solve\", \"some\", \"son\", \"sonar\", \"sonata\", \"song\",\n    \"sonic\", \"soon\", \"sooner\", \"soot\", \"soothe\", \"sordid\", \"sore\", \"sorrow\", \"sorry\", \"sort\",\n    \"soul\", \"sound\", \"soup\", \"sour\", \"source\", \"space\", \"spade\", \"span\", \"spare\", \"spark\", \"spain\",\n    \"stalin\", \"sudan\", \"suez\", \"sunday\", \"sweden\", \"swiss\", \"sydney\", \"syria\", \"taiwan\", \"sparse\",\n    \"spasm\", \"spat\", \"spate\", \"speak\", \"spear\", \"speech\", \"speed\", \"speedy\", \"spell\", \"spend\",\n    \"sperm\", \"sphere\", \"spice\", \"spicy\", \"spider\", \"spiky\", \"spill\", \"spin\", \"spinal\", \"spine\",\n    \"spiral\", \"spirit\", \"spit\", \"spite\", \"splash\", \"split\", \"spoil\", \"spoke\", \"sponge\", \"spoon\",\n    \"sport\", \"spot\", \"spouse\", \"spray\", \"spread\", \"spree\", \"spring\", \"sprint\", \"spur\", \"squad\",\n    \"square\", \"squash\", \"squat\", \"squid\", \"stab\", \"stable\", \"stack\", \"staff\", \"stage\", \"stain\",\n    \"stair\", \"stake\", \"stale\", \"stall\", \"stamp\", \"stance\", \"stand\", \"staple\", \"star\", \"starch\",\n    \"stare\", \"stark\", \"start\", \"starve\", \"state\", \"static\", \"statue\", \"status\", \"stay\", \"stead\",\n    \"steady\", \"steak\", \"steal\", \"steam\", \"steel\", \"steep\", \"steer\", \"stem\", \"stench\", \"step\",\n    \"stereo\", \"stern\", \"stew\", \"stick\", \"sticky\", \"stiff\", \"stifle\", \"stigma\", \"still\", \"sting\",\n    \"stint\", \"stir\", \"stitch\", \"stock\", \"stocky\", \"stone\", \"stony\", \"stool\", \"stop\", \"store\",\n    \"storm\", \"stormy\", \"story\", \"stout\", \"stove\", \"strain\", \"strait\", \"strand\", \"strap\", \"strata\",\n    \"straw\", \"stray\", \"streak\", \"stream\", \"street\", \"stress\", \"strict\", \"stride\", \"strife\",\n    \"strike\", \"string\", \"strip\", \"strive\", \"stroke\", \"stroll\", \"strong\", \"stud\", \"studio\", \"study\",\n    \"stuff\", \"stuffy\", \"stunt\", \"stupid\", \"sturdy\", \"style\", \"submit\", \"subtle\", \"subtly\",\n    \"suburb\", \"such\", \"suck\", \"sudden\", \"sue\", \"suffer\", \"sugar\", \"suit\", \"suite\", \"suitor\",\n    \"sullen\", \"sultan\", \"sum\", \"summer\", \"summit\", \"summon\", \"sun\", \"sunny\", \"sunset\", \"super\",\n    \"superb\", \"supper\", \"supple\", \"supply\", \"sure\", \"surely\", \"surf\", \"surge\", \"survey\", \"suture\",\n    \"swamp\", \"swan\", \"swap\", \"swarm\", \"sway\", \"swear\", \"sweat\", \"sweaty\", \"sweep\", \"sweet\",\n    \"swell\", \"swift\", \"swim\", \"swine\", \"swing\", \"swirl\", \"switch\", \"sword\", \"swore\", \"symbol\",\n    \"synod\", \"syntax\", \"syrup\", \"system\", \"table\", \"tablet\", \"taboo\", \"tacit\", \"tackle\", \"tact\",\n    \"tactic\", \"tail\", \"tailor\", \"take\", \"tale\", \"talent\", \"talk\", \"tall\", \"tally\", \"tame\",\n    \"tandem\", \"tangle\", \"tank\", \"tap\", \"tape\", \"target\", \"tariff\", \"tart\", \"task\", \"taste\",\n    \"tarzan\", \"taurus\", \"tehran\", \"teresa\", \"texas\", \"thomas\", \"tibet\", \"tokyo\", \"tom\", \"turk\",\n    \"tasty\", \"tattoo\", \"taut\", \"tavern\", \"tax\", \"taxi\", \"tea\", \"teach\", \"teak\", \"team\", \"tear\",\n    \"tease\", \"tech\", \"teeth\", \"tell\", \"temper\", \"temple\", \"tempo\", \"tempt\", \"ten\", \"tenant\",\n    \"tend\", \"tender\", \"tendon\", \"tennis\", \"tenor\", \"tense\", \"tensor\", \"tent\", \"tenth\", \"tenure\",\n    \"term\", \"terror\", \"test\", \"text\", \"than\", \"thank\", \"that\", \"the\", \"their\", \"them\", \"theme\",\n    \"then\", \"thence\", \"theory\", \"there\", \"these\", \"thesis\", \"they\", \"thick\", \"thief\", \"thigh\",\n    \"thin\", \"thing\", \"think\", \"third\", \"thirst\", \"thirty\", \"this\", \"thorn\", \"those\", \"though\",\n    \"thread\", \"threat\", \"three\", \"thrill\", \"thrive\", \"throat\", \"throne\", \"throng\", \"throw\",\n    \"thrust\", \"thud\", \"thug\", \"thumb\", \"thus\", \"thyme\", \"tick\", \"ticket\", \"tidal\", \"tide\", \"tidy\",\n    \"tie\", \"tier\", \"tiger\", \"tight\", \"tile\", \"till\", \"tilt\", \"timber\", \"time\", \"timid\", \"tin\",\n    \"tiny\", \"tip\", \"tissue\", \"title\", \"toad\", \"toast\", \"today\", \"toilet\", \"token\", \"told\", \"toll\",\n    \"tomato\", \"tomb\", \"tonal\", \"tone\", \"tongue\", \"tonic\", \"too\", \"took\", \"tool\", \"tooth\", \"top\",\n    \"topaz\", \"topic\", \"torch\", \"torque\", \"torso\", \"tort\", \"toss\", \"total\", \"touch\", \"tough\",\n    \"tour\", \"toward\", \"towel\", \"tower\", \"town\", \"toxic\", \"toxin\", \"trace\", \"track\", \"tract\",\n    \"trade\", \"tragic\", \"trail\", \"train\", \"trait\", \"tram\", \"trance\", \"trap\", \"trauma\", \"travel\",\n    \"tray\", \"tread\", \"treat\", \"treaty\", \"treble\", \"tree\", \"trek\", \"tremor\", \"trench\", \"trend\",\n    \"trendy\", \"trial\", \"tribal\", \"tribe\", \"trick\", \"tricky\", \"tried\", \"trifle\", \"trim\", \"trio\",\n    \"trip\", \"triple\", \"troop\", \"trophy\", \"trot\", \"trough\", \"trout\", \"truce\", \"truck\", \"true\",\n    \"truly\", \"trunk\", \"trust\", \"truth\", \"try\", \"tsar\", \"tube\", \"tumble\", \"tuna\", \"tundra\", \"tune\",\n    \"tung\", \"tunic\", \"tunnel\", \"turban\", \"turf\", \"turn\", \"turtle\", \"tutor\", \"tweed\", \"twelve\",\n    \"turkey\", \"uganda\", \"venice\", \"venus\", \"vienna\", \"viking\", \"virgo\", \"warsaw\", \"west\", \"yale\",\n    \"twenty\", \"twice\", \"twin\", \"twist\", \"two\", \"tycoon\", \"tying\", \"type\", \"tyrant\", \"ugly\",\n    \"ulcer\", \"ultra\", \"umpire\", \"unable\", \"uncle\", \"under\", \"uneasy\", \"unfair\", \"unify\", \"union\",\n    \"unique\", \"unit\", \"unite\", \"unity\", \"unlike\", \"unrest\", \"unruly\", \"until\", \"update\", \"upheld\",\n    \"uphill\", \"uphold\", \"upon\", \"uproar\", \"upset\", \"upshot\", \"uptake\", \"upturn\", \"upward\", \"urban\",\n    \"urge\", \"urgent\", \"urging\", \"urine\", \"usable\", \"usage\", \"use\", \"useful\", \"user\", \"usual\",\n    \"uterus\", \"utmost\", \"utter\", \"vacant\", \"vacuum\", \"vagina\", \"vague\", \"vain\", \"valet\", \"valid\",\n    \"valley\", \"value\", \"valve\", \"van\", \"vanish\", \"vanity\", \"vary\", \"vase\", \"vast\", \"vat\", \"vault\",\n    \"vector\", \"veil\", \"vein\", \"velvet\", \"vendor\", \"veneer\", \"venom\", \"vent\", \"venue\", \"verb\",\n    \"verbal\", \"verge\", \"verify\", \"verity\", \"verse\", \"versus\", \"very\", \"vessel\", \"vest\", \"veto\",\n    \"via\", \"viable\", \"vicar\", \"vice\", \"victim\", \"victor\", \"video\", \"view\", \"vigil\", \"vile\",\n    \"villa\", \"vine\", \"vinyl\", \"viola\", \"violet\", \"violin\", \"viral\", \"virgin\", \"virtue\", \"virus\",\n    \"visa\", \"vision\", \"visit\", \"visual\", \"vital\", \"vivid\", \"vocal\", \"vodka\", \"vogue\", \"voice\",\n    \"void\", \"volley\", \"volume\", \"vomit\", \"vote\", \"vowel\", \"voyage\", \"vulgar\", \"wade\", \"wage\",\n    \"waist\", \"wait\", \"waiter\", \"wake\", \"walk\", \"walker\", \"wall\", \"wallet\", \"walnut\", \"wander\",\n    \"want\", \"war\", \"warden\", \"warm\", \"warmth\", \"warn\", \"warp\", \"wary\", \"was\", \"wash\", \"wasp\",\n    \"waste\", \"watch\", \"water\", \"watery\", \"wave\", \"way\", \"weak\", \"weaken\", \"wealth\", \"weapon\",\n    \"wear\", \"weary\", \"wedge\", \"wee\", \"weed\", \"week\", \"weekly\", \"weep\", \"weight\", \"weird\", \"well\",\n    \"were\", \"wet\", \"whale\", \"wharf\", \"what\", \"wheat\", \"wheel\", \"when\", \"whence\", \"where\", \"which\",\n    \"whiff\", \"whig\", \"while\", \"whim\", \"whip\", \"whisky\", \"white\", \"who\", \"whole\", \"wholly\", \"whom\",\n    \"whore\", \"whose\", \"why\", \"wide\", \"widely\", \"widen\", \"wider\", \"widow\", \"width\", \"wife\", \"wild\",\n    \"wildly\", \"wilful\", \"will\", \"willow\", \"win\", \"wind\", \"window\", \"windy\", \"wine\", \"wing\", \"wink\",\n    \"winner\", \"winter\", \"wipe\", \"wire\", \"wisdom\", \"wise\", \"wish\", \"wit\", \"witch\", \"with\", \"within\",\n    \"witty\", \"wizard\", \"woke\", \"wolf\", \"wolves\", \"woman\", \"womb\", \"won\", \"wonder\", \"wood\",\n    \"wooden\", \"woods\", \"woody\", \"wool\", \"word\", \"work\", \"worker\", \"world\", \"worm\", \"worry\",\n    \"worse\", \"worst\", \"worth\", \"worthy\", \"would\", \"wound\", \"wrap\", \"wrath\", \"wreath\", \"wreck\",\n    \"wright\", \"wrist\", \"writ\", \"write\", \"writer\", \"wrong\", \"xerox\", \"yacht\", \"yard\", \"yarn\",\n    \"yeah\", \"year\", \"yeast\", \"yellow\", \"yet\", \"yield\", \"yogurt\", \"yolk\", \"you\", \"young\", \"your\",\n    \"yemen\", \"york\", \"zaire\", \"zurich\", \"aback\", \"abbey\", \"abbot\", \"abide\", \"ablaze\", \"able\",\n    \"youth\", \"zeal\", \"zebra\", \"zenith\", \"zero\", \"zigzag\", \"zinc\", \"zombie\", \"zone\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","tests","common.rs"],"content":"#[cfg(test)]\nmod tests {\n    pub use cmn::Words;\n    use cmn::*;\n\n    #[test]\n    fn test_new() {\n        let constants = Constants.constants();\n        assert!(constants.len() \u003e= 9);\n        // assert_eq!(common.constants().constant().len(), 9);\n    }\n\n    #[test]\n    fn test_constants() {\n        let constants = Constants.constants();\n        assert!(constants.len() \u003e= 9);\n    }\n\n    #[test]\n    fn test_words() {\n        let common = Common::new();\n        let words = common.words();\n        assert_eq!(words.words_list().len(), 4096);\n    }\n\n    #[test]\n    fn test_default() {\n        let common = Common::default();\n        assert_eq!(common.constants().constants().len(), 9);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","tests","constants.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate cmn;\n    pub use cmn::Constants;\n\n    #[test]\n    fn test_constant() {\n        let constants = Constants.constants();\n        for constant in constants {\n            println!(\"Name: {} Value: {}\", constant.name, constant.value);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","tests","words.rs"],"content":"#[cfg(test)]\nmod tests {\n    pub use cmn::Words;\n\n    #[test]\n    fn test_words_list() {\n        let words = Words::new();\n        let words_list = words.words_list();\n        assert_eq!(words_list[0], \"aboard\");\n        assert_eq!(words_list[1], \"abode\");\n        assert_eq!(words_list[2], \"abort\");\n    }\n\n    #[test]\n    fn test_default_words() {\n        let words = Words::default();\n        let words_list = words.words_list();\n        assert_eq!(words_list[0], \"aboard\");\n        assert_eq!(words_list[1], \"abode\");\n        assert_eq!(words_list[2], \"abort\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","benches","dtt.rs"],"content":"extern crate criterion;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nextern crate dtt;\nuse self::dtt::DateTime;\n\nfn new_date(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| b.iter(|| DateTime::new));\n}\n\nfn new_day(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"day\", move |b| b.iter(|| date.day));\n}\n\nfn new_hour(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"hour\", move |b| b.iter(|| date.hour));\n}\n\nfn new_iso_8601(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"iso_8601\", move |b| b.iter(|| date.iso_8601.to_owned()));\n}\nfn new_iso_week(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"iso_week\", move |b| b.iter(|| date.iso_week));\n}\nfn new_minute(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"minute\", move |b| b.iter(|| date.minute));\n}\n\nfn new_month(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"month\", move |b| b.iter(|| date.month.to_owned()));\n}\nfn new_offset(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"offset\", move |b| b.iter(|| date.offset.to_owned()));\n}\nfn new_ordinal(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"ordinal\", move |b| b.iter(|| date.ordinal));\n}\nfn new_second(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"second\", move |b| b.iter(|| date.second));\n}\nfn new_time(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"time\", move |b| b.iter(|| date.time.to_owned()));\n}\nfn new_weekday(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"weekday\", move |b| b.iter(|| date.weekday.to_owned()));\n}\n\nfn new_year(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"year\", move |b| b.iter(|| date.year));\n}\n\n// fn scalability(c: \u0026mut Criterion) {\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 10],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 100],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 1000],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 10000],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 100000],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n// }\n\ncriterion_group!(\n    benches,\n    new_date,\n    new_day,\n    new_hour,\n    new_iso_8601,\n    new_iso_week,\n    new_minute,\n    new_month,\n    new_offset,\n    new_ordinal,\n    new_second,\n    new_time,\n    new_weekday,\n    new_year,\n    // scalability\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","examples","dtt.rs"],"content":"extern crate dtt;\nuse self::dtt::DateTime;\n\npub fn main() {\n    let date = DateTime::new();\n    println!(\"ðŸ¦€ Date:              âœ… {}\", date.now);\n    println!(\"ðŸ¦€ Day:               âœ… {}\", date.day);\n    println!(\"ðŸ¦€ Hour:              âœ… {}\", date.hour);\n    println!(\"ðŸ¦€ ISO 8601:          âœ… {}\", date.iso_8601);\n    println!(\"ðŸ¦€ ISO Week Number:   âœ… {}\", date.iso_week);\n    println!(\"ðŸ¦€ Minute:            âœ… {}\", date.minute);\n    println!(\"ðŸ¦€ Month:             âœ… {}\", date.month);\n    println!(\"ðŸ¦€ Offset:            âœ… {}\", date.offset);\n    println!(\"ðŸ¦€ Ordinal Date:      âœ… {}\", date.ordinal);\n    println!(\"ðŸ¦€ Second:            âœ… {}\", date.second);\n    println!(\"ðŸ¦€ Microsecond:       âœ… {}\", date.microsecond);\n    println!(\"ðŸ¦€ Time:              âœ… {}\", date.time);\n    println!(\"ðŸ¦€ Weekday:           âœ… {}\", date.weekday);\n    println!(\"ðŸ¦€ Year:              âœ… {}\", date.year);\n\n    println!(\n        \"ðŸ¦€ Invalid day (32):       âŒ {}\",\n        DateTime::is_valid_day(\"32\")\n    );\n    println!(\n        \"ðŸ¦€ Valid day:         âœ… {}\",\n        DateTime::is_valid_day(\u0026date.day.to_string())\n    );\n    println!(\n        \"ðŸ¦€ Invalid hour (24):      âŒ {}\",\n        DateTime::is_valid_hour(\"24\")\n    );\n    println!(\n        \"ðŸ¦€ Valid hour:        âœ… {}\",\n        DateTime::is_valid_hour(\u0026date.hour.to_string())\n    );\n    // println!(\n    //     \"ðŸ¦€ Invalid month:     âŒ {}\",\n    //     DateTime::is_valid_month(\"13\")\n    // );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for parsing, validating, manipulating, and formatting dates and times\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-dtt.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/dtt.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/dtt)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/dtt)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/dtt)\n//! [![License](https://img.shields.io/crates/l/dtt.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The DateTime (DTT) library is a comprehensive and flexible tool that\n//! enables developers to manage dates and times with ease. It provides\n//! drop-in replacement methods for parsing, validating, manipulating,\n//! and formatting dates and times in Rust.\n//!\n//! The [**`DateTime`**](./struct.DateTime.html) type to represent a\n//! date and a time in a defined timezone.\n//!\n//! ## Features\n//!\n//! - Day of the month: (1-31),\n//! - Hour of the day: (0-23),\n//! - ISO 8601 date and time: (e.g. \"2023-01-01T00:00:00+00:00\"),\n//! - ISO week number: (1-53),\n//! - Microsecond: (0-999999),\n//! - Minute of the hour: (0-59),\n//! - Month: (e.g. \"January\"),\n//! - Now object: (e.g. \"2023-01-01\"),\n//! - Offset from UTC: (e.g. \"+00:00\"),\n//! - Ordinal date: (1-366),\n//! - Second of the minute: (0-59),\n//! - Time object: (e.g. \"00:00:00\"),\n//! - Tz object: (e.g. \"UTC\"),\n//! - Weekday object: (e.g. \"Monday\"),\n//! - Year object: (e.g. \"2023\"),\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! ## Examples\n//!\n//! ```rust\n//!\n//! extern crate dtt;\n//! use self::dtt::DateTime;\n//!\n//! let dt = DateTime::new();\n//! println!(\"Date: {}\", dt.now);\n//! println!(\"Day: {}\", dt.day);\n//! println!(\"Hour: {}\", dt.hour);\n//! println!(\"ISO 8601: {}\", dt.iso_8601);\n//! println!(\"ISO Week Number: {}\", dt.iso_week);\n//! println!(\"Minute: {}\", dt.minute);\n//! println!(\"Month: {}\", dt.month);\n//! println!(\"Offset: {}\", dt.offset);\n//! println!(\"Ordinal Date: {}\", dt.ordinal);\n//! println!(\"Second: {}\", dt.second);\n//! println!(\"Time: {}\", dt.time);\n//! println!(\"Weekday: {}\", dt.weekday);\n//! println!(\"Year: {}\", dt.year);\n//!\n//! ```\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-dtt.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-dtt.svg\",\n    html_root_url = \"https://docs.rs/dtt\"\n)]\n#![crate_name = \"dtt\"]\n#![crate_type = \"lib\"]\n\nextern crate serde;\n\npub use serde::{Deserialize, Serialize};\n\nextern crate time;\nuse time::{Duration, OffsetDateTime};\n\nextern crate regex;\nuse regex::Regex;\n\n/// # DateTime\n///\n/// [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/claims)\n/// [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n///\n/// DateTime struct to ease dates and times manipulation.\n///\n/// This module includes date and time types, such as day, hour,ISO 8601\n/// date and time, and many more methods.\n///\n#[derive(Clone, Debug, Default, Deserialize, PartialEq, Serialize)]\npub struct DateTime {\n    /// Day of the month: (1-31)\n    pub day: u8,\n    /// Hour of the day: (0-23)\n    pub hour: u8,\n    /// ISO 8601 date and time: (e.g. \"2023-01-01T00:00:00+00:00\")\n    pub iso_8601: String,\n    /// ISO week number: (1-53)\n    pub iso_week: u8,\n    /// Microsecond: (0-999999)\n    pub microsecond: u32,\n    /// Minute of the hour: (0-59)\n    pub minute: u8,\n    /// Month: (e.g. \"January\")\n    pub month: String,\n    /// Now object: (e.g. \"2023-01-01\")\n    pub now: String,\n    /// Offset from UTC: (e.g. \"+00:00\")\n    pub offset: String,\n    /// Ordinal date: (1-366)\n    pub ordinal: u16,\n    /// Second of the minute: (0-59)\n    pub second: u8,\n    /// Time object: (e.g. \"00:00:00\")\n    pub time: String,\n    /// Tz object: (e.g. \"UTC\")\n    pub tz: String,\n    /// Weekday object: (e.g. \"Monday\")\n    pub weekday: String,\n    /// Year object: (e.g. \"2023\")\n    pub year: i32,\n}\n\nimpl DateTime {\n    /// Create a new Date object with UTC timezone.\n    pub fn new() -\u003e Self {\n        Self::new_with_tz(\"UTC\")\n    }\n\n    /// Create a new DateTime object with a custom timezone.\n    pub fn new_with_tz(tz: \u0026str) -\u003e Self {\n        let offset = match tz {\n            \"UTC\" =\u003e time::UtcOffset::UTC,\n            _ =\u003e time::UtcOffset::from_hms(0, 0, 0).unwrap(),\n        };\n        let now_utc = if tz == \"UTC\" {\n            OffsetDateTime::now_utc()\n        } else {\n            let (hours, minutes, _) = offset.as_hms();\n            let total_seconds = (hours as i16 * 3600) + (minutes as i16 * 60);\n            OffsetDateTime::now_utc() + Duration::seconds(total_seconds as i64)\n        };\n        let iso_8601 = now_utc.to_string();\n\n        Self {\n            day: now_utc.day(),\n            hour: now_utc.hour(),\n            iso_8601,\n            iso_week: now_utc.iso_week(),\n            microsecond: now_utc.microsecond(),\n            minute: now_utc.minute(),\n            month: now_utc.month().to_string(),\n            now: now_utc.date().to_string(),\n            offset: now_utc.offset().to_string(),\n            ordinal: now_utc.ordinal(),\n            second: now_utc.second(),\n            time: now_utc.time().to_string(),\n            tz: now_utc.time().to_string(),\n            weekday: now_utc.weekday().to_string(),\n            year: now_utc.year(),\n        }\n    }\n    /// Check if the input is a valid day.\n    /// 31 is valid.\n    /// 32 is not valid.\n    pub fn is_valid_day(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(day) = input.parse::\u003cu8\u003e() {\n            if (1..=31).contains(\u0026day) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid hour.\n    /// 23:59 is valid.\n    /// 24:00 is not valid.\n    pub fn is_valid_hour(input: \u0026str) -\u003e bool {\n        let re: Regex = Regex::new(r\"^([0-1][0-9]|2[0-3])(:[0-5][0-9])?$\").unwrap();\n        re.is_match(input)\n    }\n    /// Check if the input is a valid ISO 8601 date and time.\n    /// 2023-01-01T00:00:00+00:00 is valid.\n    /// 2023-01-01T00:00:00+00:00:00 is not valid.\n    pub fn is_valid_iso_8601(input: \u0026str) -\u003e bool {\n        let re = Regex::new(\n            r\"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.\\d+)?(Z|[+-]\\d{2}:\\d{2})$\",\n        )\n        .unwrap();\n        if !re.is_match(input) {\n            return false;\n        }\n        let captures = re.captures(input).unwrap();\n        // let year = captures[1].parse::\u003ci32\u003e().unwrap();\n        let month = captures[2].parse::\u003cu32\u003e().unwrap();\n        let day = captures[3].parse::\u003cu32\u003e().unwrap();\n        let hour = captures[4].parse::\u003cu32\u003e().unwrap();\n        let minute = captures[5].parse::\u003cu32\u003e().unwrap();\n        let second = captures[6].parse::\u003cu32\u003e().unwrap();\n        let tz = captures[7].to_string();\n        if !(1..=12).contains(\u0026month)\n            || !(1..=31).contains(\u0026day)\n            || hour \u003e= 24\n            || minute \u003e= 60\n            || second \u003e= 60\n        {\n            return false;\n        }\n        if tz != \"Z\" {\n            let re = Regex::new(r\"^[+-](\\d{2}):(\\d{2})$\").unwrap();\n            let captures = re.captures(\u0026tz).unwrap();\n            let tz_hour = captures[1].parse::\u003ci32\u003e().unwrap();\n            let tz_minute = captures[2].parse::\u003ci32\u003e().unwrap();\n            if !(0..=23).contains(\u0026tz_hour) || !(0..=59).contains(\u0026tz_minute) {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Check if the input is a valid ISO week number.\n    /// 53 is valid.\n    /// 54 is not valid.\n    pub fn is_valid_iso_week(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(iso_week) = input.parse::\u003cu8\u003e() {\n            if (1..=53).contains(\u0026iso_week) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid microsecond.\n    /// 999999 is valid.\n    /// 1000000 is not valid.\n    pub fn is_valid_microsecond(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(microsecond) = input.parse::\u003cu32\u003e() {\n            if (0..=999999).contains(\u0026microsecond) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid minute.\n    /// 59 is valid.\n    /// 60 is not valid.\n    pub fn is_valid_minute(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(minute) = input.parse::\u003cu8\u003e() {\n            if (0..=59).contains(\u0026minute) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid month.\n    /// 12 is valid.\n    /// 13 is not valid.\n    pub fn is_valid_month(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(month) = input.parse::\u003cu8\u003e() {\n            if (1..=12).contains(\u0026month) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid ordinal date.\n    /// 366 is valid.\n    /// 367 is not valid.\n    pub fn is_valid_ordinal(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(ordinal) = input.parse::\u003cu16\u003e() {\n            if (1..=366).contains(\u0026ordinal) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid second.\n    /// 59 is valid.\n    /// 60 is not valid.\n    pub fn is_valid_second(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(second) = input.parse::\u003cu8\u003e() {\n            if (0..=59).contains(\u0026second) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid time.\n    /// 23:59:59 is valid.\n    /// 24:00:00 is not valid.\n    pub fn is_valid_time(input: \u0026str) -\u003e bool {\n        let re = Regex::new(r\"^([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$\").unwrap();\n        re.is_match(input)\n    }\n}\n\nimpl std::fmt::Display for DateTime {\n    /// Display the date and time in ISO 8601 format.\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Year: {}\\nMonth: {}\\nDay: {}\\nWeekday: {}\\nHour: {}\\nMinute: {}\\nSecond: {}\\nMicrosecond: {}\\nOrdinal: {}\\nIso 8601: {}\\nIso Week: {}\\nTime: {}\\nTZ: {}\\nOffset: {}\\nNow: {}\", self.year, self.month, self.day, self.weekday, self.hour, self.minute, self.second, self.microsecond, self.ordinal, self.iso_8601, self.iso_week, self.time, self.tz, self.offset, self.now)\n    }\n}\n\n/// Generates a function with the given name `$name` that checks whether\n/// a string `input` can be parsed into a value of type `$type`.\n///\n/// # Examples\n///\n/// ```rust\n///\n/// extern crate dtt;\n/// use dtt::is_valid;\n///\n/// is_valid!(day, u32);\n/// let input = \"31\";\n/// let result = day(input);\n/// assert!(result);\n///\n/// ```\n#[macro_export]\nmacro_rules! is_valid {\n    ($name:ident, $type:ty) =\u003e {\n        fn $name(input: \u0026str) -\u003e bool {\n            let mut valid = false;\n            if let Ok(_input) = input.parse::\u003c$type\u003e() {\n                valid = true;\n            }\n            valid\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","tests","dtt.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n\n    extern crate dtt;\n    use dtt::{is_valid, DateTime};\n\n    extern crate time;\n    use time::{Duration, OffsetDateTime};\n\n    #[test]\n    fn test_new() {\n        let date = DateTime::new();\n        assert!(!date.now.is_empty());\n        assert!(date.day \u003c= 31);\n        assert!(date.hour \u003c= 23);\n        assert!(!date.iso_8601.is_empty());\n        assert!(date.iso_week \u003e 0 \u0026\u0026 date.iso_week \u003c= 53);\n        assert!(date.minute \u003c= 59);\n        assert!(!date.month.is_empty());\n        assert!(!date.offset.is_empty());\n        assert!(date.ordinal \u003e 0 \u0026\u0026 date.ordinal \u003c= 366);\n        assert!(date.second \u003c= 59);\n        assert!(!date.time.is_empty());\n        assert!(!date.weekday.is_empty());\n        assert!(date.year \u003e 0);\n    }\n    #[test]\n    fn test_is_valid_day() {\n        assert!(!DateTime::is_valid_day(\"32\"));\n        assert!(DateTime::is_valid_day(\"31\"));\n    }\n    #[test]\n    fn test_is_valid_hour() {\n        assert!(DateTime::is_valid_hour(\"23\"));\n        assert!(DateTime::is_valid_hour(\"23:59\"));\n        assert!(!DateTime::is_valid_hour(\"24:00\"));\n    }\n    #[test]\n    fn test_valid_iso_8601() {\n        assert!(DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00Z\"));\n        assert!(DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00+01:00\"));\n        assert!(DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00.123456Z\"));\n        assert!(DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456+01:00\"\n        ));\n    }\n\n    #[test]\n    fn test_invalid_iso_8601() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25 17:30:00Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00+25:00\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00+01:61\"));\n    }\n\n    #[test]\n    fn test_month_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-13-25T17:30:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-00-25T17:30:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_day_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-32T17:30:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-00T17:30:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_hour_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T24:30:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T-1:30:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_minute_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:60:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:-1:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_second_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:59:60.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:59:-1.1234567Z\"));\n    }\n    #[test]\n    fn test_tz_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456Z+25:00\"\n        ));\n        assert!(!DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456Z+24:61\"\n        ));\n        assert!(!DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456Z+99:59\"\n        ));\n    }\n    #[test]\n    fn test_update_date() {\n        let date = DateTime::new();\n        let date_before_update = date.now.clone();\n        assert_eq!(date_before_update, date.now);\n    }\n\n    #[test]\n    fn test_update_day() {\n        let date = DateTime::new();\n        let day_before_update = date.day;\n        assert_eq!(day_before_update, date.day);\n        assert!(date.day \u003c= 31);\n    }\n\n    #[test]\n    fn test_update_hour() {\n        let date = DateTime::new();\n        let hour_before_update = date.hour;\n        assert_eq!(hour_before_update, date.hour);\n        assert!(date.hour \u003c= 23);\n    }\n\n    #[test]\n    fn test_update_iso_8601() {\n        let date = DateTime::new();\n        let iso_8601_before_update = date.iso_8601.clone();\n        assert_eq!(iso_8601_before_update, date.iso_8601);\n    }\n\n    #[test]\n    fn test_update_iso_week() {\n        let date = DateTime::new();\n        let iso_week_before_update = date.iso_week;\n        assert_eq!(iso_week_before_update, date.iso_week);\n        assert!(date.iso_week \u003c= 53);\n    }\n\n    #[test]\n    fn test_update_minute() {\n        let date = DateTime::new();\n        let minute_before_update = date.minute;\n        assert_eq!(minute_before_update, date.minute);\n        assert!(date.minute \u003c= 59);\n    }\n\n    #[test]\n    fn test_update_month() {\n        let date = DateTime::new();\n        let month_before_update = date.month.clone();\n        assert_eq!(month_before_update, date.month);\n    }\n\n    #[test]\n    fn test_update_offset() {\n        let date = DateTime::new();\n        let offset_before_update = date.offset.clone();\n        assert_eq!(offset_before_update, date.offset);\n    }\n\n    #[test]\n    fn test_update_ordinal() {\n        let date = DateTime::new();\n        let ordinal_before_update = date.ordinal;\n        assert_eq!(ordinal_before_update, date.ordinal);\n        assert!(date.ordinal \u003e 0 \u0026\u0026 date.ordinal \u003c= 366);\n    }\n    #[test]\n    fn test_update_second() {\n        let date = DateTime::new();\n        let second_before_update = date.second;\n        assert_eq!(second_before_update, date.second);\n        assert!(date.second \u003c= 59);\n    }\n    #[test]\n    fn test_update_time() {\n        let date = DateTime::new();\n        let time_before_update = date.time.clone();\n        assert_eq!(time_before_update, date.time);\n    }\n\n    #[test]\n    fn test_update_weekday() {\n        let date = DateTime::new();\n        let weekday_before_update = date.weekday.clone();\n        assert_eq!(weekday_before_update, date.weekday);\n    }\n    #[test]\n    fn test_update_year() {\n        let date = DateTime::new();\n        let year_before_update = date.year;\n        assert_eq!(year_before_update, date.year);\n        assert!(date.year \u003e 0);\n    }\n    #[test]\n    fn test_new_with_tz_utc() {\n        let date_time = DateTime::new_with_tz(\"UTC\");\n        let offset = time::UtcOffset::UTC;\n\n        let now_utc = OffsetDateTime::now_utc();\n        let (hours, minutes, _) = offset.as_hms();\n        let total_seconds = (hours as i16 * 3600) + (minutes as i16 * 60);\n        let expected_date_time = now_utc + Duration::seconds(total_seconds as i64);\n\n        assert_eq!(date_time.hour, expected_date_time.hour());\n        assert_eq!(date_time.minute, expected_date_time.minute());\n        assert_eq!(date_time.offset, expected_date_time.offset().to_string());\n    }\n    #[test]\n    fn test_new_with_tz_custom() {\n        let date_time = DateTime::new_with_tz(\"Custom\");\n        let offset = time::UtcOffset::from_hms(0, 0, 0).unwrap();\n\n        let now_utc = OffsetDateTime::now_utc();\n        let (hours, minutes, _) = offset.as_hms();\n        let total_seconds = (hours as i16 * 3600) + (minutes as i16 * 60);\n        let expected_date_time = now_utc + Duration::seconds(total_seconds as i64);\n\n        assert_eq!(date_time.hour, expected_date_time.hour());\n        assert_eq!(date_time.minute, expected_date_time.minute());\n        assert_eq!(date_time.offset, expected_date_time.offset().to_string());\n    }\n    #[test]\n    fn test_new_with_tz_to_paris() {\n        let date = DateTime::new_with_tz(\"Europe/Paris\");\n        assert!(!date.now.is_empty());\n        assert!(date.day \u003c= 31);\n        assert!(date.hour \u003c= 23);\n        assert!(!date.iso_8601.is_empty());\n        assert!(date.iso_week \u003e 0 \u0026\u0026 date.iso_week \u003c= 53);\n        assert!(date.minute \u003c= 59);\n        assert!(!date.month.is_empty());\n        assert!(!date.offset.is_empty());\n        assert!(date.ordinal \u003e 0 \u0026\u0026 date.ordinal \u003c= 366);\n        assert!(date.second \u003c= 59);\n        assert!(!date.time.is_empty());\n        assert!(!date.weekday.is_empty());\n        assert!(date.year \u003e 0);\n    }\n    #[test]\n    fn test_is_valid() {\n        is_valid!(day, u32);\n        let input = \"31\";\n        let result = day(input);\n        assert!(result);\n    }\n    #[test]\n    fn test_display_format() {\n        let date_time = DateTime::new();\n        let formatted = format!(\"{date_time}\");\n\n        assert!(formatted.starts_with(\"Year:\"));\n        assert!(formatted.contains(\"Month:\"));\n        assert!(formatted.contains(\"Day:\"));\n        assert!(formatted.contains(\"Weekday:\"));\n        assert!(formatted.contains(\"Hour:\"));\n        assert!(formatted.contains(\"Minute:\"));\n        assert!(formatted.contains(\"Second:\"));\n        assert!(formatted.contains(\"Microsecond:\"));\n        assert!(formatted.contains(\"Ordinal:\"));\n        assert!(formatted.contains(\"Iso 8601:\"));\n        assert!(formatted.contains(\"Iso Week:\"));\n        assert!(formatted.contains(\"Time:\"));\n        assert!(formatted.contains(\"TZ:\"));\n        assert!(formatted.contains(\"Offset:\"));\n        assert!(formatted.contains(\"Now:\"));\n    }\n    #[test]\n    fn test_is_valid_iso_week() {\n        assert!(DateTime::is_valid_iso_week(\"53\"));\n        assert!(!DateTime::is_valid_iso_week(\"54\"));\n        assert!(!DateTime::is_valid_iso_week(\"a\"));\n    }\n\n    #[test]\n    fn test_is_valid_microsecond() {\n        assert!(DateTime::is_valid_microsecond(\"999999\"));\n        assert!(!DateTime::is_valid_microsecond(\"1000000\"));\n        assert!(!DateTime::is_valid_microsecond(\"b\"));\n    }\n\n    #[test]\n    fn test_is_valid_minute() {\n        assert!(DateTime::is_valid_minute(\"59\"));\n        assert!(!DateTime::is_valid_minute(\"60\"));\n        assert!(!DateTime::is_valid_minute(\"c\"));\n    }\n\n    #[test]\n    fn test_is_valid_month() {\n        assert!(DateTime::is_valid_month(\"12\"));\n        assert!(!DateTime::is_valid_month(\"13\"));\n        assert!(!DateTime::is_valid_month(\"d\"));\n    }\n\n    #[test]\n    fn test_is_valid_ordinal() {\n        assert!(DateTime::is_valid_ordinal(\"366\"));\n        assert!(!DateTime::is_valid_ordinal(\"367\"));\n        assert!(!DateTime::is_valid_ordinal(\"e\"));\n    }\n\n    #[test]\n    fn test_is_valid_second() {\n        assert!(DateTime::is_valid_second(\"59\"));\n        assert!(!DateTime::is_valid_second(\"60\"));\n        assert!(!DateTime::is_valid_second(\"f\"));\n    }\n    #[test]\n    fn test_is_valid_time() {\n        assert!(DateTime::is_valid_time(\"23:59:59\"));\n        assert!(!DateTime::is_valid_time(\"24:00:00\"));\n        assert!(!DateTime::is_valid_time(\"g\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","benches","hsh.rs"],"content":"use blake3::Hasher;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse hsh::Hash;\n\nfn generate_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"generate_hash\", |b| {\n        let mut hasher = Hasher::new();\n        let password = \"password\";\n        b.iter(|| {\n            hasher.update(password.as_bytes());\n            hasher.finalize();\n        });\n    });\n}\n\nfn hash_entropy(c: \u0026mut Criterion) {\n    let mut hash_struct = Hash::new();\n    hash_struct.set_password(\"password\");\n    hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n    c.bench_function(\"hash_entropy\", |b| {\n        b.iter(|| {\n            black_box(\u0026hash_struct).entropy();\n        });\n    });\n}\n\nfn verify_password(c: \u0026mut Criterion) {\n    let mut hash_struct = Hash::new();\n    hash_struct.set_password(\"password\");\n    hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n    c.bench_function(\"verify_password\", |b| {\n        let hash = \"abcdefghijklmnopqrstuvwxyz\";\n        let password = \"password\";\n        b.iter(|| {\n            black_box(hash_struct.verify(hash, password));\n        });\n    });\n}\n\nfn bench_generate_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"generate_hash\", |b| {\n        let password = \"password\";\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(password);\n        b.iter(|| {\n            hash_struct.generate_hash();\n        });\n    });\n}\n\nfn bench_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"hash\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n        b.iter(|| {\n            black_box(hash_struct.hash());\n        });\n    });\n}\n\nfn bench_hash_length(c: \u0026mut Criterion) {\n    c.bench_function(\"hash_length\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n        b.iter(|| {\n            black_box(hash_struct.hash_length());\n        });\n    });\n}\n\nfn bench_new(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| {\n        b.iter(|| {\n            Hash::new();\n        });\n    });\n}\n\nfn bench_password(c: \u0026mut Criterion) {\n    c.bench_function(\"password\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        b.iter(|| {\n            black_box(hash_struct.password());\n        });\n    });\n}\n\nfn bench_password_length(c: \u0026mut Criterion) {\n    c.bench_function(\"password_length\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        b.iter(|| {\n            black_box(hash_struct.password_length());\n        });\n    });\n}\n\nfn bench_set_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"set_hash\", |b| {\n        let mut hash_struct = Hash::new();\n        let hash = \"abcdefghijklmnopqrstuvwxyz\";\n        b.iter(|| {\n            hash_struct.set_hash(hash);\n        });\n    });\n}\n\nfn bench_set_password(c: \u0026mut Criterion) {\n    c.bench_function(\"set_password\", |b| {\n        let mut hash_struct = Hash::new();\n        let password = \"password\";\n        b.iter(|| {\n            hash_struct.set_password(password);\n        });\n    });\n}\n\nfn bench_verify(c: \u0026mut Criterion) {\n    c.bench_function(\"verify\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n        let hash = \"abcdefghijklmnopqrstuvwxyz\";\n        let password = \"password\";\n        b.iter(|| {\n            black_box(hash_struct.verify(hash, password));\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_generate_hash,\n    bench_hash,\n    bench_hash_length,\n    bench_new,\n    bench_password,\n    bench_password_length,\n    bench_set_hash,\n    bench_set_password,\n    bench_verify,\n    generate_hash,\n    hash_entropy,\n    verify_password\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","examples","hsh.rs"],"content":"extern crate hsh;\nuse self::hsh::Hash;\n\nfn main() {\n    let mut hash = Hash::new();\n    let mut default = Hash::default();\n    let is_valid = hash.verify(\n        \"7f2611ba158b6dcea4a69c229c303358c5e04493abeadee106a4bfa464d55787\",\n        \"password\",\n    );\n    hash.set_password(\"password\");\n    default.set_password(\"password\");\n    hash.set_hash(\"1.61803398874989484820\");\n    default.set_hash(\"1.61803398874989484820\");\n\n    println!(\"ðŸ¦€ Hash::new():                âœ… {hash}\");\n    println!(\"ðŸ¦€ Hash::default():            âœ… {default}\");\n    println!(\"ðŸ¦€ Hash::generate_hash():      âœ… {}\", hash.generate_hash());\n    if is_valid {\n        println!(\n            \"ðŸ¦€ Hash::verify():             âœ… {}\",\n            hash.verify(hash.hash(), \"password\")\n        );\n    } else {\n        println!(\"ðŸ¦€ Hash::verify() :            âŒ The password or hash is invalid.\");\n    }\n    println!(\n        \"ðŸ¦€ Hash::set_password():       âœ… {}\",\n        hash.password() == \"password\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::set_hash():           âœ… {}\",\n        hash.hash() == \"1.61803398874989484820\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::password():           âœ… {}\",\n        hash.password() == \"password\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::password_length():    âœ… {}\",\n        hash.password_length() == 8\n    );\n    println!(\n        \"ðŸ¦€ Hash::hash():               âœ… {}\",\n        hash.hash() == \"1.61803398874989484820\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::hash_length():        âœ… {}\",\n        hash.hash_length() == 22\n    );\n    println!(\"ðŸ¦€ Hash::entropy():            âœ… {}\", hash.entropy() \u003e 0.0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Cryptographic Hash Algorithms Library for Rust\n//!\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-hsh.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/hsh.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/hsh)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/hsh)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/hsh)\n//! [![License](https://img.shields.io/crates/l/hsh.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Hash (HSH), is a Cryptographic Hash Algorithms Library for secure\n//! password management.\n//!\n//! Utilizing the cutting-edge [Blake3][11] algorithm, this library\n//! generates and verifies hashed passwords with ease. The library\n//! features a struct for storing and verifying hashed passwords, as\n//! well as a series of methods for calculating entropy, generating\n//! hashes, accessing password and hash values, and more.\n//!\n//! `HSH` also implements the Default and Display traits for flexible\n//! use and easy readability.\n//!\n//! ## Features\n//!\n//! - [x] Hashes passwords using the [blake3](https://crates.io/crates/blake3) crate.\n//! - [x] Verifies passwords against stored hashes.\n//! - [x] Calculates the entropy of the hash in bits based on the Shannon entropy formula.\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-hsh.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-hsh.svg\",\n    html_root_url = \"https://docs.rs/hsh\"\n)]\n#![crate_name = \"hsh\"]\n#![crate_type = \"lib\"]\n\nextern crate blake3;\nuse blake3::Hasher;\n\n/// A struct for storing and verifying hashed passwords based on\n/// the [blake3](https://crates.io/crates/blake3) crate.\n#[non_exhaustive]\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\npub struct Hash {\n    /// The password.\n    pub password: String,\n    /// The password hash.\n    pub hash: String,\n}\n\nimpl Hash {\n    /// Calculates the entropy of the hash in bits based on the Shannon\n    /// entropy formula. \u003chttps://en.wikipedia.org/wiki/Entropy\u003e`\n    pub fn entropy(\u0026self) -\u003e f64 {\n        // Shannon entropy formula in bits.\n        let mut entropy = 0.0;\n        for c in self.hash.chars() {\n            let p = (c as u8) as f64 / 255.0;\n            entropy -= p * p.log2();\n        }\n        entropy\n    }\n\n    /// Hashes the password.\n    pub fn generate_hash(\u0026self) -\u003e String {\n        let mut hasher = Hasher::new();\n        hasher.update(self.password.as_bytes());\n        let hash = hasher.finalize().to_hex();\n        hash.to_string()\n    }\n\n    /// Returns the hash.\n    pub fn hash(\u0026self) -\u003e \u0026str {\n        \u0026self.hash\n    }\n\n    /// Returns the hash length.\n    pub fn hash_length(\u0026self) -\u003e usize {\n        self.hash.len()\n    }\n\n    /// Returns a new instance of `Hash`.\n    pub fn new() -\u003e Self {\n        Self {\n            password: String::default(),\n            hash: String::default(),\n        }\n    }\n\n    /// Returns the password.\n    pub fn password(\u0026self) -\u003e \u0026str {\n        \u0026self.password\n    }\n\n    /// Returns the password length.\n    pub fn password_length(\u0026self) -\u003e usize {\n        self.password.len()\n    }\n\n    /// Sets the hash.\n    pub fn set_hash(\u0026mut self, hash: \u0026str) {\n        self.hash = hash.to_string();\n    }\n\n    /// Sets the password and updates the hash.\n    pub fn set_password(\u0026mut self, password: \u0026str) {\n        self.password = password.to_string();\n        self.hash = self.generate_hash();\n    }\n    /// Verifies the password against the stored hash.\n    ///\n    /// Returns `true` if the password and hash match, `false` otherwise.\n    pub fn verify(\u0026self, hash: \u0026str, password: \u0026str) -\u003e bool {\n        let mut hasher = Hasher::new();\n        hasher.update(password.as_bytes());\n        let password_hash = hasher.finalize().to_hex();\n        let password_hash_str = password_hash.to_string();\n        password_hash_str == hash\n    }\n}\n\nimpl std::fmt::Display for Hash {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Hash {{ password: {}, hash: {} }}\",\n            self.password, self.hash\n        )\n    }\n}\n\nimpl Default for Hash {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","tests","hsh.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate hsh;\n    use self::hsh::Hash;\n\n    #[test]\n    fn test_hash_fmt() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        hash.set_hash(\"hash\");\n        assert_eq!(format!(\"{hash}\"), \"Hash { password: password, hash: hash }\");\n    }\n\n    #[test]\n    fn test_hash_password() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.password, \"password\");\n    }\n\n    #[test]\n    fn test_hash_hash() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash, \"hash\");\n    }\n\n    #[test]\n    fn test_new() {\n        let hash = Hash::new();\n        assert_eq!(hash.password(), \"\");\n        assert_eq!(hash.hash(), \"\");\n    }\n\n    #[test]\n    fn test_default() {\n        let hash = Hash::default();\n        assert_eq!(hash.password(), \"\");\n        assert_eq!(hash.hash(), \"\");\n    }\n\n    #[test]\n    fn test_generate_hash() {\n        let hash = Hash::new();\n        let hash = hash.generate_hash();\n        assert_eq!(hash.len(), 64);\n    }\n\n    #[test]\n    fn test_verify() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert!(hash.verify(\n            \"7f2611ba158b6dcea4a69c229c303358c5e04493abeadee106a4bfa464d55787\",\n            \"password\",\n        ));\n    }\n\n    #[test]\n    fn test_set_password() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert_eq!(hash.password(), \"password\");\n    }\n    #[test]\n    fn test_set_hash() {\n        let mut hash = Hash::new();\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash(), \"hash\");\n    }\n\n    #[test]\n    fn test_password() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert_eq!(hash.password(), \"password\");\n    }\n    #[test]\n    fn test_password_length() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert_eq!(hash.password_length(), 8);\n    }\n    #[test]\n    fn test_hash() {\n        let mut hash = Hash::new();\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash(), \"hash\");\n    }\n    #[test]\n    fn test_hash_length() {\n        let mut hash = Hash::new();\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash_length(), 4);\n    }\n    #[test]\n    fn test_entropy() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert!(hash.entropy() \u003e 0.0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","benches","idk.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","examples","idk.rs"],"content":"extern crate idk;\nuse idk::common::ErrorType;\n\nfn main() {\n    let error_type = ErrorType::new(\"illegal_argument\");\n    let error_type_new_subtype = error_type.new_subtype(\"subtype\");\n\n    println!(\"ðŸ¦€ Error::error_type_new():             âœ… {error_type:?}\\n\",);\n    println!(\"ðŸ¦€ Error::error_type_new_subtype():        âœ… {error_type_new_subtype:?}\\n\",);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","common.rs"],"content":"/// ErrorType is a struct that holds a name and an Error enum instance\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ErrorType {\n    /// name is a string that holds the name of the error type\n    pub name: String,\n    /// error_type is an instance of the Error enum\n    pub error_type: Error,\n}\n/// Error is an enumeration of different error types\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub enum Error {\n    /// Argument error\n    Argument(String),\n    /// Assertion error\n    Assertion(String),\n    /// Concurrency error\n    Concurrency(String),\n    /// Data error\n    Data(String),\n    /// External error\n    External(String),\n    /// Format error\n    Format(String),\n    /// Implementation error\n    Implementation(String),\n    /// Initialization error\n    Initialization(String),\n    /// Internal error\n    Internal(String),\n    /// Interruption error\n    Interruption(String),\n    /// Operation error\n    Operation(String),\n    /// Rejection error\n    Rejection(String),\n    /// State error\n    State(String),\n    /// Timeout error\n    Timeout(String),\n    /// Unknown error\n    Unknown(String),\n    /// Version error\n    Version(String),\n}\n\nimpl Error {\n    /// new creates a new Error enum instance based on the name\n    pub fn new(err_type: ErrorType) -\u003e Self {\n        match err_type.name.as_str() {\n            \"argument\" =\u003e Error::Argument(String::from(\"Illegal argument\")),\n            \"assertion\" =\u003e Error::Assertion(String::from(\"Assertion failed\")),\n            \"concurrency\" =\u003e Error::Concurrency(String::from(\"Concurrency update\")),\n            \"data\" =\u003e Error::Data(String::from(\"Data unavailable\")),\n            \"external\" =\u003e Error::External(String::from(\"External error\")),\n            \"format\" =\u003e Error::Format(String::from(\"Illegal format\")),\n            \"implementation\" =\u003e Error::Implementation(String::from(\"No implementation\")),\n            \"initialization\" =\u003e Error::Initialization(String::from(\"Initialization failed\")),\n            \"internal\" =\u003e Error::Internal(String::from(\"Internal error\")),\n            \"interruption\" =\u003e Error::Interruption(String::from(\"Interruption occurred\")),\n            \"operation\" =\u003e Error::Operation(String::from(\"Unsupported operation\")),\n            \"rejection\" =\u003e Error::Rejection(String::from(\"Rejection occurred\")),\n            \"state\" =\u003e Error::State(String::from(\"Illegal state\")),\n            \"timeout\" =\u003e Error::Timeout(String::from(\"Timeout elapsed\")),\n            \"version\" =\u003e Error::Version(String::from(\"Unsupported version\")),\n            _ =\u003e Error::Unknown(String::from(\"Unknown error\")),\n        }\n    }\n}\n\nimpl ErrorType {\n    /// new creates a new ErrorType struct instance\n    pub fn new(name: \u0026str) -\u003e ErrorType {\n        ErrorType {\n            name: String::from(name),\n            error_type: Error::new(ErrorType {\n                name: name.to_string(),\n                error_type: Error::Unknown(String::from(name)),\n            }),\n        }\n    }\n    /// new_subtype creates a new ErrorType struct instance\n    pub fn new_subtype(\u0026self, name: \u0026str) -\u003e ErrorType {\n        ErrorType {\n            name: String::from(name),\n            error_type: Error::new(ErrorType {\n                name: name.to_string(),\n                error_type: Error::Unknown(String::from(name)),\n            }),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","error.rs"],"content":"use crate::common::ErrorType;\nuse std::error::Error as StdError;\nuse std::fmt;\n\n#[derive(Debug)]\n/// Error struct for the crate\npub struct Error {\n    /// The error message\n    pub message: String,\n\n    /// The error type\n    pub error_type: ErrorType,\n\n    /// The context of the error\n    pub ctx: String,\n}\n\nimpl Error {\n    /// Create a new error\n    pub fn new(message: \u0026str, error_type: ErrorType) -\u003e Error {\n        Error {\n            message: message.to_owned(),\n            error_type,\n            ctx: \"\".to_owned(),\n        }\n    }\n\n    /// Create a new error type\n    pub fn error_type(name: \u0026str, error_type: ErrorType, ctx: \u0026str) -\u003e Error {\n        Error {\n            message: name.to_owned(),\n            error_type,\n            ctx: ctx.to_owned(),\n        }\n    }\n\n    /// Add context to the error\n    pub fn with_context(mut self, ctx: \u0026str) -\u003e Error {\n        self.ctx = ctx.to_owned();\n        self\n    }\n}\n\nimpl StdError for Error {\n    /// Source of the error\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn StdError + 'static)\u003e {\n        None\n    }\n}\n\nimpl fmt::Display for Error {\n    /// Display the error\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}, ctx: {}\", self.message, self.ctx)\n    }\n}\n\nimpl fmt::Display for ErrorType {\n    /// Display the error type\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.name)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","jwt.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nextern crate base64;\n// extern crate openssl;\nextern crate serde_json;\n\n// use openssl::error::ErrorStack;\n// use self::error::Error;\nuse base64::DecodeError;\nuse hmac::digest::InvalidLength as InvLen;\nuse serde_json::Error as SJError;\nuse std::error::Error;\nuse std::fmt;\nuse std::io::Error as IoError;\n\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n/// Custom error type for JWT. This type is used to represent all\n/// possible errors that can occur when working with JWTs. It is\n/// implemented as an enum with variants for each possible error. It\n/// also implements the `Default`, `Display`, and `Error` traits.\npub enum JwtError {\n    /// The Audience is invalid.\n    AudienceInvalid(String),\n\n    /// Decode error.\n    DecodeError(String),\n\n    /// Expiration is invalid.\n    ExpirationInvalid(String),\n\n    /// Format is invalid\n    FormatInvalid(String),\n\n    /// Invalid header.\n    InvalidHeader(String),\n\n    /// Invalid payload.\n    InvalidPayload(String),\n\n    /// Invalid signature\n    InvalidSignature(String),\n\n    /// Invalid length\n    InvalidLength(String),\n\n    /// IO error.\n    IoError(String),\n\n    /// Issuer is invalid.\n    IssuerInvalid(String),\n\n    /// JWT is invalid.\n    JWTInvalid(String),\n\n    /// Open SSL error.\n    OpenSslError(String),\n\n    /// Protocol error.\n    ProtocolError(String),\n\n    /// Signature is expired.\n    SignatureExpired(String),\n\n    /// Signature is invalid.\n    SignatureInvalid(String),\n\n    /// Token not found.\n    TokenNotFound(String),\n}\n\nimpl Error for JwtError {}\n\nimpl fmt::Display for JwtError {\n    /// The formatted error.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            JwtError::AudienceInvalid(err) =\u003e write!(f, \"Audience Invalid Error: {err}\"),\n            JwtError::ExpirationInvalid(err) =\u003e write!(f, \"Expiration Invalid Error: {err}\"),\n            // implement display for other variants as well\n            _ =\u003e write!(f, \"Unknown error\"),\n        }\n    }\n}\n\nimpl From\u003cDecodeError\u003e for JwtError {\n    /// Converts a `DecodeError` to a `JwtError`.\n    fn from(error: DecodeError) -\u003e Self {\n        JwtError::DecodeError(error.to_string())\n    }\n}\n\nimpl From\u003cSJError\u003e for JwtError {\n    fn from(error: SJError) -\u003e Self {\n        JwtError::InvalidPayload(error.to_string())\n    }\n}\n\nimpl From\u003cInvLen\u003e for JwtError {\n    fn from(error: InvLen) -\u003e Self {\n        JwtError::InvalidLength(error.to_string())\n    }\n}\n\n// impl From\u003cErrorStack\u003e for JwtError {\n//     fn from(error: ErrorStack) -\u003e Self {\n//         JwtError::OpenSslError(error.to_string())\n//     }\n// }\n\nimpl From\u003cIoError\u003e for JwtError {\n    fn from(error: IoError) -\u003e Self {\n        JwtError::IoError(error.to_string())\n    }\n}\n\nimpl JwtError {\n    /// Returns `true` if the error is a signature error.\n    pub fn is_signature_error(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            JwtError::SignatureExpired(_) | JwtError::SignatureInvalid(_)\n        )\n    }\n\n    /// Returns `true` if the error is a JWT error.\n    pub fn is_jwt_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::JWTInvalid(_))\n    }\n\n    /// Returns `true` if the error is an issuer error.\n    pub fn is_issuer_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::IssuerInvalid(_))\n    }\n\n    /// Returns `true` if the error is an expiration error.\n    pub fn is_expiration_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::ExpirationInvalid(_))\n    }\n\n    /// Returns `true` if the error is an audience error.\n    pub fn is_audience_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::AudienceInvalid(_))\n    }\n\n    /// Returns `true` if the error is a format error.\n    pub fn is_format_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::FormatInvalid(_))\n    }\n\n    /// Returns `true` if the error is a header error.\n    pub fn is_invalid_length_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::InvalidLength(_))\n    }\n\n    /// Returns `true` if the error is an IO error.\n    pub fn is_io_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::IoError(_))\n    }\n\n    /// Returns `true` if the error is an Open SSL error.\n    pub fn is_openssl_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::OpenSslError(_))\n    }\n\n    /// Returns `true` if the error is a protocol error.\n    pub fn is_protocol_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::ProtocolError(_))\n    }\n    /// Returns `true` if the error is a token not found error.\n    pub fn is_token_not_found_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::TokenNotFound(_))\n    }\n    /// Returns `true` if the error is an invalid base 64.\n    pub fn is_base64_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::DecodeError(_))\n    }\n}\n\n// Implementation of `Default` for `Error` to provide a default error.\nimpl Default for JwtError {\n    fn default() -\u003e Self {\n        Self::SignatureExpired(\"Signature expired.\".to_owned())\n    }\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":40},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for managing errors and exceptions\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-idk.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/idk.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/idk)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/idk)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/tree/main/idk)\n//! [![License](https://img.shields.io/crates/l/idk.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! IDontKnow (IDK) is a Rust library that has functions and variables\n//! designed to make it easy for your program to report informative\n//! error messages. You can use the IDK library to create error messages\n//! that are clear, concise, and actionable.\n//!\n//! ## Features\n//!\n//! The library includes multiple modules: `Common`, `Error`, `Jwt`,\n//! `Property`, `Stacktrace`, and `Traits`.\n//!\n//! - **The common module:** This module provides a foundation of common\n//! functionalities that can be utilized throughout the entire project.\n//! These functionalities serve as a building block for the rest of the\n//! project, making it easier for developers to create and manage their\n//! code.\n//! - **The error module:** This module contains all the error types\n//! that are used in the project. By providing a centralized location\n//! for errors, developers can quickly and easily identify and resolve\n//! any issues that may arise.\n//! - **The jwt module:** This module offers the tools necessary to\n//! encode and decode JSON Web Tokens (JWT). With a simple, easy-to-use\n//! interface, developers can ensure secure communication between\n//! parties.\n//! - **The property module:** This module provides the functionality to\n//! create and manage properties. By utilizing this module, developers\n//! can keep track of all properties within the project and make changes\n//! as necessary.\n//! - **The stacktrace module:** This module offers the tools to create\n//! and manage stacktraces. By providing detailed information about the\n//! execution of the code, developers can quickly identify and resolve\n//! any issues that may arise.\n//! - **The traits module:** This module provides functionality to\n//! create and manage traits. By utilizing this module, developers can\n//! ensure that all traits within the project are consistent and\n//! well-defined.\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-idk.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-idk.svg\",\n    html_root_url = \"https://docs.rs/idk\"\n)]\n#![crate_name = \"idk\"]\n#![crate_type = \"lib\"]\n\n/// The common module provides common functionality that can be used\n/// throughout the entire crate.\npub mod common;\n\n/// The error module contains all the error types used in the crate.\npub mod error;\n\n/// The jwt module provides functionality to encode and decode\n/// JSON Web Tokens (JWT).\npub mod jwt;\n\n/// The property module provides functionality to create and manage\n/// properties.\npub mod property;\n\n/// The stacktrace module provides functionality to create and manage\n/// stacktraces.\npub mod stacktrace;\n\n/// The traits module provides functionality to create and manage\n/// traits.\npub mod traits;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","property.rs"],"content":"#[derive(Clone, Debug, Ord, PartialEq, PartialOrd, Hash)]\n/// The property of the error.\npub struct Property {\n    /// The label of the property.\n    pub label: String,\n    /// Whether the property is printable.\n    pub printable: bool,\n}\n\nimpl Eq for Property {}\n\nimpl Property {\n    /// Creates a new property.\n    pub fn new(label: \u0026str, printable: bool) -\u003e Property {\n        Property {\n            label: label.to_owned(),\n            printable,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","stacktrace.rs"],"content":"use std::fmt;\n\nconst STACK_TRACE_DEPTH: usize = 128;\n\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n/// The program counter of the stack trace.\npub struct StackTrace {\n    /// The program counter of the stack trace.\n    pub pc: Vec\u003cusize\u003e,\n    /// The cause stack trace of the stack trace.\n    pub cause_stack_trace: Option\u003cBox\u003cStackTrace\u003e\u003e,\n}\n\nimpl StackTrace {\n    /// Formats the stack trace.\n    pub fn format_stack_trace(stack_trace: Vec\u003cString\u003e) -\u003e String {\n        format!(\n            \"Stack trace:\\n{}\",\n            stack_trace\n                .iter()\n                .map(|elem| format!(\"\\t- {elem}\"))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\\n\")\n        )\n    }\n\n    /// Creates a new stack trace.\n    pub fn new() -\u003e StackTrace {\n        let pc = Vec::with_capacity(STACK_TRACE_DEPTH);\n        StackTrace {\n            pc,\n            cause_stack_trace: Some(Box::new(StackTrace {\n                pc: Vec::with_capacity(STACK_TRACE_DEPTH),\n                cause_stack_trace: None,\n            })),\n        }\n    }\n}\n\nimpl Default for StackTrace {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for StackTrace {\n    /// The formatted stack trace.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let stack_trace = self\n            .pc\n            .iter()\n            .map(|\u0026pc| format!(\"{pc:#x}\"))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let formatted_stack_trace = StackTrace::format_stack_trace(stack_trace);\n\n        match \u0026self.cause_stack_trace {\n            Some(cause_stack_trace) =\u003e {\n                write!(f, \"{formatted_stack_trace}\\n{cause_stack_trace}\")\n            }\n            None =\u003e write!(f, \"{formatted_stack_trace}\"),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","traits.rs"],"content":"use std::sync::atomic::AtomicU64;\n\nstatic INTERNAL_ID_COUNTER: AtomicU64 = AtomicU64::new(0);\n\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n/// The `Trait` struct with id as a unique identifier and label as a\n/// string representation of the trait.\npub struct Trait {\n    /// The `id` field holds the unique identifier of the trait.\n    pub id: u64,\n    /// The `label` field holds the string representation of the trait.\n    pub label: String,\n}\n\nimpl Trait {\n    /// Creates a new instance of Trait with a unique identifier and the\n    /// given label string.\n    pub fn new(label: \u0026str) -\u003e Self {\n        Trait {\n            id: INTERNAL_ID_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed),\n            label: label.to_string(),\n        }\n    }\n    /// A convenient alias to new().\n    pub fn register_trait(label: \u0026str) -\u003e Trait {\n        Trait::new(label)\n    }\n}\n/// A struct to manage a collection of Trait instances.\npub struct TraitBuilder {\n    /// A vector of Trait instances\n    pub traits: Vec\u003cTrait\u003e,\n}\n\nimpl TraitBuilder {\n    /// Creates a new instance of TraitBuilder.\n    pub fn new() -\u003e Self {\n        TraitBuilder { traits: Vec::new() }\n    }\n    /// Adds a new Trait instance with the given label to the collection.\n    pub fn add_trait(\u0026mut self, label: \u0026str) -\u003e \u0026Trait {\n        let trait_ = Trait::new(label);\n        self.traits.push(trait_);\n        self.traits.last().unwrap()\n    }\n    /// Finds and returns the Trait instance with the given label.\n    pub fn get_trait(\u0026self, label: \u0026str) -\u003e Option\u003c\u0026Trait\u003e {\n        self.traits.iter().find(|t| t.label == label)\n    }\n    /// Deletes the Trait instance with the given label from the\n    /// collection.\n    pub fn delete_trait(\u0026mut self, label: \u0026str) -\u003e bool {\n        let pos = self.traits.iter().position(|t| t.label == label);\n        if let Some(pos) = pos {\n            self.traits.remove(pos);\n            true\n        } else {\n            false\n        }\n    }\n}\n\nimpl Default for TraitBuilder {\n    /// A default implementation of TraitBuilder, creating a new\n    /// instance of TraitBuilder.\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n/// A struct to represent the presence of a Trait instance.\npub struct HasTrait {\n    /// The identifier of the Trait instance.\n    pub trait_id: u64,\n    /// Whether the Trait instance is present.\n    pub has_trait: bool,\n    /// Whether the Trait instance was added.\n    pub add_trait: bool,\n}\nimpl HasTrait {\n    /// Creates a new instance of HasTrait with the given trait_id.\n    pub fn new(trait_id: u64) -\u003e Self {\n        HasTrait {\n            trait_id,\n            has_trait: false,\n            add_trait: false,\n        }\n    }\n    /// Returns true if the HasTrait instance has the given Trait key.\n    pub fn has_trait(\u0026self, key: \u0026Trait) -\u003e bool {\n        self.trait_id == key.id\n    }\n    /// Adds the given Trait key to the HasTrait instance.\n    pub fn add_trait(\u0026mut self, key: \u0026Trait) {\n        self.trait_id = key.id;\n        self.has_trait = true;\n        self.add_trait = true;\n    }\n    /// Removes the given Trait key from the HasTrait instance.\n    pub fn remove_trait(\u0026mut self, key: \u0026Trait) {\n        self.trait_id = key.id;\n        self.has_trait = false;\n        self.add_trait = false;\n    }\n    /// Returns true if the Trait instance was added to the HasTrait\n    /// instance.\n    pub fn is_add_trait(\u0026self) -\u003e bool {\n        self.add_trait\n    }\n    /// Returns true if the HasTrait instance has the Trait instance.\n    pub fn is_has_trait(\u0026self) -\u003e bool {\n        self.has_trait\n    }\n    /// Returns true if the Trait instance was removed from the HasTrait\n    /// instance.\n    pub fn is_remove_trait(\u0026self) -\u003e bool {\n        !self.add_trait\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":38},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","common.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::common::{Error, ErrorType};\n\n    #[test]\n    fn test_error_type_new() {\n        let error_type = ErrorType::new(\"argument\");\n        assert_eq!(error_type.name, \"argument\");\n        match error_type.error_type {\n            Error::Argument(s) =\u003e assert_eq!(s, \"Illegal argument\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn test_error_type_new_subtype() {\n        let error_type = ErrorType::new(\"illegal_argument\");\n        let subtype = error_type.new_subtype(\"subtype\");\n        assert_eq!(subtype.name, \"subtype\");\n        match subtype.error_type {\n            Error::Unknown(s) =\u003e assert_eq!(s, \"Unknown error\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn test_error_type_name() {\n        let error_type = ErrorType::new(\"illegal_argument\");\n        assert_eq!(error_type.name, \"illegal_argument\");\n    }\n\n    #[test]\n    fn test_error_type_error_type() {\n        let error_type = ErrorType::new(\"argument\");\n        match error_type.error_type {\n            Error::Argument(s) =\u003e assert_eq!(s, \"Illegal argument\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn test_new() {\n        let err_type = ErrorType {\n            name: String::from(\"argument\"),\n            error_type: Error::Argument(String::from(\"argument\")),\n        };\n        let err = Error::new(err_type);\n        assert_eq!(err, Error::Argument(String::from(\"Illegal argument\")));\n\n        let err_type = ErrorType {\n            name: String::from(\"operation\"),\n            error_type: Error::Operation(String::from(\"operation\")),\n        };\n        let err = Error::new(err_type);\n        assert_eq!(err, Error::Operation(String::from(\"Unsupported operation\")));\n\n        let err_type = ErrorType {\n            name: String::from(\"unknown_error\"),\n            error_type: Error::Unknown(String::from(\"unknown_error\")),\n        };\n        let err = Error::new(err_type);\n        assert_eq!(err, Error::Unknown(String::from(\"Unknown error\")));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","error.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::{common::ErrorType, error::Error as OtherError};\n    use std::error::Error as StdError;\n\n    #[test]\n    fn test_error_new() {\n        let error_type = ErrorType::new(\"illegal_argument\");\n        let err = OtherError::new(\"message\", error_type);\n        assert_eq!(err.message, \"message\");\n        assert_eq!(err.error_type.name, \"illegal_argument\");\n    }\n    #[test]\n    fn test_with_context() {\n        let error_type = ErrorType::new(\"test_error\");\n        let err =\n            OtherError::with_context(OtherError::new(\"message\", error_type), \"Additional context\");\n        assert_eq!(err.message, \"message\");\n        assert_eq!(err.error_type.name, \"test_error\");\n        assert_eq!(err.ctx, \"Additional context\");\n    }\n\n    #[test]\n    fn test_source() {\n        let error_type = ErrorType::new(\"test_error\");\n        let err = OtherError::new(\"message\", error_type);\n        assert!(StdError::source(\u0026err).is_none());\n    }\n\n    #[test]\n    fn test_display() {\n        let err = OtherError::new(\"Test error\", ErrorType::new(\"test_error\"));\n        let display = format!(\"{err}\");\n        assert_eq!(display, \"Test error, ctx: \");\n    }\n\n    #[test]\n    fn test_display_error_type() {\n        let err_type = ErrorType::new(\"test_error_type\");\n        let display = format!(\"{err_type}\");\n        assert_eq!(display, \"test_error_type\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","jwt.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::jwt::JwtError;\n\n    #[test]\n    fn test_jwt_error() {\n        let jwt_error = JwtError::JWTInvalid(\"JWT is invalid\".to_string());\n        assert!(jwt_error.is_jwt_error());\n        assert!(!jwt_error.is_signature_error());\n        assert!(!jwt_error.is_issuer_error());\n        assert!(!jwt_error.is_expiration_error());\n        assert!(!jwt_error.is_audience_error());\n    }\n    #[test]\n    fn test_jwt_display() {\n        let jwt_audience_error = JwtError::AudienceInvalid(\"Audience is invalid\".to_string());\n        assert!(jwt_audience_error\n            .to_string()\n            .contains(\"Audience is invalid\"));\n\n        let jwt_expiration_invalid =\n            JwtError::ExpirationInvalid(\"Expiration is invalid\".to_string());\n        assert!(jwt_expiration_invalid\n            .to_string()\n            .contains(\"Expiration is invalid\"));\n\n        let jwt_error = JwtError::default();\n        assert_eq!(jwt_error.to_string(), \"Unknown error\");\n    }\n    #[test]\n    fn test_signature_error() {\n        let jwt_error = JwtError::SignatureInvalid(\"Signature is invalid\".to_string());\n        assert!(!jwt_error.is_jwt_error());\n        assert!(jwt_error.is_signature_error());\n        assert!(!jwt_error.is_issuer_error());\n        assert!(!jwt_error.is_expiration_error());\n        assert!(!jwt_error.is_audience_error());\n        assert!(!jwt_error.is_format_error());\n        assert!(!jwt_error.is_invalid_length_error());\n        assert!(!jwt_error.is_io_error());\n        assert!(!jwt_error.is_openssl_error());\n        assert!(!jwt_error.is_protocol_error());\n        assert!(!jwt_error.is_token_not_found_error());\n        assert!(!jwt_error.is_base64_error());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","property.rs"],"content":"#[cfg(test)]\n\nmod tests {\n    extern crate idk;\n    use idk::property::Property;\n\n    #[test]\n    fn test_property_error() {\n        let err = Property::new(\"test\", true);\n        assert_eq!(err.label, \"test\");\n        assert!(err.printable);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","stacktrace.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::stacktrace::StackTrace;\n\n    #[test]\n    fn test_stack_trace_new() {\n        let stack_trace = StackTrace::new();\n        assert_eq!(stack_trace.pc.len(), 0);\n    }\n\n    #[test]\n    fn test_format_stack_trace_default() {\n        let stack_trace = StackTrace::default();\n        assert_eq!(stack_trace.pc.len(), 0);\n    }\n\n    #[test]\n    fn test_display_stack_trace() {\n        let test_display_stack_trace = StackTrace::new();\n        assert!(!test_display_stack_trace.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","traits.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::traits::{HasTrait, Trait, TraitBuilder};\n\n    #[test]\n    fn test_trait_new() {\n        let trait_test = Trait::new(\"test\");\n        assert_eq!(trait_test.label, \"test\");\n    }\n\n    #[test]\n    fn register_trait() {\n        let trait_test = Trait::new(\"test\");\n        assert_eq!(trait_test.label, \"test\");\n        Trait::register_trait(\"test\");\n    }\n\n    #[test]\n    fn test_traits_builder() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        trait_builder.delete_trait(\"test\");\n        assert_eq!(trait_builder.traits.len(), 0);\n    }\n\n    #[test]\n    fn test_trait_new_builder() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n    }\n\n    #[test]\n    fn test_get_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n    }\n\n    #[test]\n    fn test_has_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n    }\n    #[test]\n    fn test_add_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.add_trait(trait_test.unwrap());\n        assert!(has_trait.add_trait);\n    }\n    #[test]\n    fn test_remove_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.remove_trait(trait_test.unwrap());\n    }\n    #[test]\n    fn test_is_add_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.add_trait(trait_test.unwrap());\n        assert!(has_trait.is_add_trait());\n    }\n    #[test]\n    fn test_is_has_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.add_trait(trait_test.unwrap());\n        assert!(has_trait.is_has_trait());\n    }\n    #[test]\n    fn is_remove_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.remove_trait(trait_test.unwrap());\n        assert!(has_trait.is_remove_trait());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","benches","mdg.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nextern crate mdg;\nuse mdg::*;\n\npub const BLOCK_LENGTH: usize = 64;\n\nfn finalize_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"finalize\", |b| {\n        let mut mdg = MD5::new();\n        let data = vec![0u8; BLOCK_LENGTH];\n        mdg.update(\u0026data);\n\n        b.iter(|| {\n            mdg.finalize();\n            // mdg.digest;\n        });\n    });\n}\n\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| {\n        b.iter(|| MD5::new);\n    });\n}\n\nfn transform_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let data = vec![0u8; BLOCK_LENGTH];\n\n    c.bench_function(\"transform\", |b| {\n        b.iter(|| {\n            mdg.transform(black_box(\u0026data));\n        });\n    });\n}\n\nfn update_with_len_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let data = vec![0u8; BLOCK_LENGTH];\n    let nbytes = Some(BLOCK_LENGTH);\n\n    c.bench_function(\"update_with_len\", |b| {\n        b.iter(|| {\n            // mdg.update_with_len(black_box(\u0026data), black_box(nbytes));\n            mdg.update_with_len(black_box(\u0026data), black_box(nbytes.unwrap_or(BLOCK_LENGTH)));\n        });\n    });\n}\n\nfn reset_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n\n    c.bench_function(\"reset\", |b| {\n        b.iter(|| {\n            mdg.reset();\n        });\n    });\n}\n\nfn update_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let data = vec![0u8; BLOCK_LENGTH];\n\n    c.bench_function(\"update\", |b| {\n        b.iter(|| {\n            mdg.update(black_box(\u0026data));\n        });\n    });\n}\n\nfn update_file_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let path = \"file.txt\";\n\n    c.bench_function(\"update_file\", |b| {\n        b.iter(|| {\n            mdg.update_file(black_box(path));\n        });\n    });\n}\n\nfn hexdigest_benchmark(c: \u0026mut Criterion) {\n    let data = vec![0u8; BLOCK_LENGTH];\n\n    c.bench_function(\"hexdigest\", |b| {\n        b.iter(|| {\n            let data_str = String::from_utf8(data.to_vec()).unwrap();\n            MD5::hexdigest(black_box(\u0026data_str));\n        });\n    });\n}\n\nfn hexdigest_file_benchmark(c: \u0026mut Criterion) {\n    let path = \"file.txt\";\n\n    c.bench_function(\"hexdigest_file\", |b| {\n        b.iter(|| {\n            MD5::hexdigest_file(black_box(path));\n        });\n    });\n}\n\nfn reset_file_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let path = \"file.txt\";\n\n    c.bench_function(\"reset_file\", |b| {\n        b.iter(|| {\n            mdg.reset_file(black_box(path));\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    finalize_benchmark,\n    hexdigest_benchmark,\n    hexdigest_file_benchmark,\n    new_benchmark,\n    reset_benchmark,\n    reset_file_benchmark,\n    transform_benchmark,\n    update_benchmark,\n    update_file_benchmark,\n    update_with_len_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","examples","mdg.rs"],"content":"extern crate mdg;\nuse mdg::{Digest, MD5};\n\nfn main() {\n    // Example using MD5::hexdigest() for a string input\n    let input = \"Hello, world!\";\n    let digest = MD5::hexdigest(input);\n    println!(\"ðŸ¦€ MD5::hexdigest() for a string input:            âœ… {digest}\",);\n    // Expected 6cd3556deb0da54bca060b4c39479839\n\n    // Example using MD5::hexdigest() for a byte array input\n    let input = [72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]; // \"Hello, world!\"\n    let input_str = String::from_utf8(input.to_vec()).unwrap();\n    let digest = MD5::hexdigest(\u0026input_str);\n    println!(\"ðŸ¦€ MD5::hexdigest() for a byte array input:        âœ… {digest}\",);\n    // Expected 6cd3556deb0da54bca060b4c39479839\n\n    // Example using MD5::hexdigest() for a file input\n    let digest = MD5::hexdigest_file(\"mdg/file.txt\"); // file.txt contains \"Hello, world!\"\n    println!(\"ðŸ¦€ MD5::hexdigest_file() for a file input:         âœ… {digest}\",);\n    // Expected 6cd3556deb0da54bca060b4c39479839\n\n    // Example using MD5::update() for a byte array input\n    let mut mdg = MD5::new();\n    let input = [\n        67, 111, 117, 99, 111, 117, 44, 32, 108, 101, 32, 109, 111, 110, 100, 101, 33,\n    ]; // \"Coucou, le monde!\"\n    mdg.update(\u0026input);\n    let digest = mdg.finalize();\n    println!(\"ðŸ¦€ MD5::update() for a byte array input:           âœ… {digest}\",);\n    // Expected 47353a0e5ed2e1e0d57213a39e9bb7c4\n\n    // Example using MD5::update() for a string input\n    let mut mdg = MD5::new();\n    let input = \"Coucou, le monde!\";\n    mdg.update(input.as_bytes());\n    let digest = mdg.finalize();\n    println!(\"ðŸ¦€ MD5::update() for a string input:               âœ… {digest}\",);\n    // Expected 47353a0e5ed2e1e0d57213a39e9bb7c4\n\n    // Example using MD5::update() for a file input\n    let mut mdg = MD5::new();\n    println!(\n        \"ðŸ¦€ MD5::new() is:                                  âœ… {}\",\n        mdg.finalize()\n    );\n    // Expected d41d8cd98f00b204e9800998ecf8427e\n    mdg.update_file(\"mdg/update.txt\"); // update.txt contains \"Coucou, le monde!\"\n    let digest = mdg.finalize();\n    println!(\"ðŸ¦€ MD5::update_file() is:                          âœ… {digest}\",);\n    // Expected 7fc3e27776139278c6b8e0b6f096b4fb\n\n    // Example using MD5::reset() for a string input\n    let mut mdg = MD5::new();\n    println!(\n        \"ðŸ¦€ MD5::new() is:                                  âœ… {}\",\n        mdg.finalize()\n    );\n    // Expected d41d8cd98f00b204e9800998ecf8427e\n    println!(\n        \"ðŸ¦€ MD5::reset() for a string input:                âœ… {}\",\n        mdg.reset()\n    );\n    // Expected 00000000000000000000000000000000\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","constants.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n/// The block length.\npub const BLOCK_LENGTH: usize = 64;\n/// The digest length.\npub const DIGEST_LENGTH: usize = 16;\n/// The number of bytes in a word.\npub const INITIAL_STATE: [u32; 4] = [0x6745_2301, 0xefcd_ab89, 0x98ba_dcfe, 0x1032_5476];\n/// The number of bytes in a word.\npub const SHIFTS: [u8; 64] = [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,\n    14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,\n    21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n/// Padding used in the algorithm implementation of MD5.\npub const PADDING: [u8; 64] = [\n    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0,\n];\n/// The number of bytes in a word.\npub const T_VALUES: [u32; 64] = [\n    0xd76a_a478,\n    0xe8c7_b756,\n    0x2420_70db,\n    0xc1bd_ceee,\n    0xf57c_0faf,\n    0x4787_c62a,\n    0xa830_4613,\n    0xfd46_9501,\n    0x6980_98d8,\n    0x8b44_f7af,\n    0xffff_5bb1,\n    0x895c_d7be,\n    0x6b90_1122,\n    0xfd98_7193,\n    0xa679_438e,\n    0x49b4_0821,\n    0xf61e_2562,\n    0xc040_b340,\n    0x265e_5a51,\n    0xe9b6_c7aa,\n    0xd62f_105d,\n    0x0244_1453,\n    0xd8a1_e681,\n    0xe7d3_fbc8,\n    0x21e1_cde6,\n    0xc337_07d6,\n    0xf4d5_0d87,\n    0x455a_14ed,\n    0xa9e3_e905,\n    0xfcef_a3f8,\n    0x676f_02d9,\n    0x8d2a_4c8a,\n    0xfffa_3942,\n    0x8771_f681,\n    0x6d9d_6122,\n    0xfde5_380c,\n    0xa4be_ea44,\n    0x4bde_cfa9,\n    0xf6bb_4b60,\n    0xbebf_bc70,\n    0x289b_7ec6,\n    0xeaa1_27fa,\n    0xd4ef_3085,\n    0x0488_1d05,\n    0xd9d4_d039,\n    0xe6db_99e5,\n    0x1fa2_7cf8,\n    0xc4ac_5665,\n    0xf429_2244,\n    0x432a_ff97,\n    0xab94_23a7,\n    0xfc93_a039,\n    0x655b_59c3,\n    0x8f0c_cc92,\n    0xffef_f47d,\n    0x8584_5dd1,\n    0x6fa8_7e4f,\n    0xfe2c_e6e0,\n    0xa301_4314,\n    0x4e08_11a1,\n    0xf753_7e82,\n    0xbd3a_f235,\n    0x2ad7_d2bb,\n    0xeb86_d391,\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","digest.rs"],"content":"use crate::{INITIAL_STATE, MD5};\nuse std::{fs::File, io::Read};\n\n/// The `Digest` trait.\npub trait Digest {\n    /// reset the internal state of the object\n    fn reset(\u0026mut self) -\u003e \u0026mut Self;\n    /// update the internal state of the object with new data\n    fn update(\u0026mut self, value: \u0026[u8]) -\u003e \u0026mut Self;\n    /// update the internal state of the object with new data from a file\n    fn update_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self;\n    /// return the digest value as a string of hexadecimal digits\n    fn hexdigest(value: \u0026str) -\u003e String;\n    /// return the digest value as a string of hexadecimal digits from a file\n    fn hexdigest_file(path: \u0026str) -\u003e String;\n    /// reset the internal state of the object and update it with new data from a file\n    fn reset_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self;\n}\n\nimpl Digest for MD5 {\n    /// Reset the internal state of the MD5 object.\n    fn reset(\u0026mut self) -\u003e \u0026mut Self {\n        self.state = INITIAL_STATE;\n        self.count.fill(0);\n        self.buffer.fill(0);\n        self.digest.fill(0);\n\n        self\n    }\n    /// Update the internal state of the MD5 object with new data.\n    fn update(\u0026mut self, value: \u0026[u8]) -\u003e \u0026mut Self {\n        self.update_with_len(value, value.len())\n    }\n    /// Update the internal state of the MD5 object with new data from a file.\n    fn update_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self {\n        let mut file = File::open(path).expect(\"Couldn't open file\");\n        let mut buffer = [0; 1024];\n\n        loop {\n            let nbytes = file.read(\u0026mut buffer).expect(\"Couldn't read file\");\n            if nbytes == 0 {\n                break;\n            }\n            self.update_with_len(\u0026buffer, nbytes);\n        }\n\n        self\n    }\n    /// Return the digest value as a string of hexadecimal digits.\n    fn hexdigest(value: \u0026str) -\u003e String {\n        Self::new().update(value.as_bytes()).finalize().to_string()\n    }\n\n    /// Return the digest value as a string of hexadecimal digits from a file.\n    fn hexdigest_file(path: \u0026str) -\u003e String {\n        let mut file = File::open(path).expect(\"Couldn't open file\");\n        let mut buffer = [0; 1024];\n        let mut mdg = Self::new();\n\n        loop {\n            let nbytes = file.read(\u0026mut buffer).expect(\"Couldn't read file\");\n            if nbytes == 0 {\n                break;\n            }\n            mdg.update_with_len(\u0026buffer, nbytes);\n        }\n\n        mdg.finalize().to_string()\n    }\n    /// Reset the internal state of the MD5 object and update it with new data from a file.\n    fn reset_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self {\n        self.reset();\n        self.update_file(path)\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library that implements the MD5 cryptographic hash function\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-mdg.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The Message Digest (MDG) is an easy way to produces a 128-bit\n//! (16-byte) hash value using the MD5 cryptographic hash function. It\n//! provides a struct, MD5, that can generate a message digest of data\n//! in a secure, one-way hash. The message digest can verify the\n//! integrity of the data without having to store the entire message.\n//!\n//! Several options are available to produce the hash value:\n//!\n//! - `MD5::default()` - Returns the hash value of an empty string.\n//! - `MD5::digest()` - Returns the hash value of a string.\n//! - `MD5::finalize()` - Finalize the MD5 object and return the result\n//!    as a 16-byte array.\n//! - `MD5::hexdigest()` - Returns the hash value of a string as a\n//!    hexadecimal string.\n//! - `MD5::new()` - Create a new instance of the MD5 struct.\n//! - `MD5::reset()` - Reset the internal state of the MD5 object.\n//! - `MD5::to_hex_string()` - Returns the hash value of a string as a\n//!    hexadecimal string.\n//! - `MD5::to_string()` - Returns the hash value of a string as a\n//!    string.\n//! - `MD5::update()` - Update the internal state of the MD5 object\n//!    with new data.\n//! - `MD5::update_file()` - Update the internal state of the MD5\n//!    object with new data from a file.\n//!\n//! To use this crate, add `mdg` to your `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! mdg = \"0.0.1\"\n//! ```\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! # Examples\n//!\n//! ```no_run\n//! use mdg::MD5;\n//!\n//! let hash = MD5::default();\n//! assert_eq!(hash.to_string(), \"d41d8cd98f00b204e9800998ecf8427e\");\n//! ```\n//! # Warning\n//!\n//! This crate is not intended for cryptographic use. MD5 is not a\n//! cryptographically secure hashing algorithm and should not be used\n//! for applications that require a collision-resistant hash function.\n//!\n//! MD5 is sensitive to length extension attacks, which alter the hash\n//! value if additional data is appended to the input.\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mdg.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mdg.svg\",\n    html_root_url = \"https://docs.rs/mdg\"\n)]\n#![crate_name = \"mdg\"]\n#![crate_type = \"lib\"]\n\n/// Import the `params` module.\nmod params;\npub use params::*;\n\n/// Import the `constants` module.\npub mod constants;\npub use constants::*;\n\n/// Import the `digest` module.\npub mod digest;\npub use digest::*;\n\nuse std::convert::TryInto;\nuse std::fmt::Display;\n\n/// The MD5 struct.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct MD5 {\n    /// The buffer.\n    pub buffer: [u8; BLOCK_LENGTH],\n    /// The count.\n    pub count: [u32; 2],\n    /// The digest.\n    pub digest: [u8; DIGEST_LENGTH],\n    /// The state.\n    pub state: [u32; 4],\n}\n\nimpl MD5 {\n    /// Finalize the MD5 object and return the result as a 16-byte array.\n    pub fn finalize(\u0026mut self) -\u003e \u0026Self {\n        // Save the length before padding.\n        let bits: [u8; 8] = (0..8)\n            .into_iter()\n            .map(|i| (self.count[i \u003e\u003e 2] \u003e\u003e ((i \u0026 3) \u003c\u003c 3)) as u8)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .try_into()\n            .expect(\"Couldn't transform vec into array\");\n\n        // Pad out to 56 mod 64\n        let index = (self.count[0] \u003e\u003e 3) \u0026 63;\n        let pad_len = if index \u003c 56 { 56 - index } else { 120 - index };\n        self.update_with_len(\u0026PADDING, pad_len as usize);\n\n        // Append the length\n        self.update(\u0026bits);\n\n        self.digest = (0..DIGEST_LENGTH)\n            .into_iter()\n            .map(|i| (self.state[i \u003e\u003e 2] \u003e\u003e ((i \u0026 3) \u003c\u003c 3)) as u8)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .try_into()\n            .expect(\"Couldn't transform vec into array\");\n\n        self\n    }\n    /// Create a new instance of the MD5 struct.\n    pub fn new() -\u003e Self {\n        Self {\n            state: INITIAL_STATE,\n            count: [0, 0],\n            buffer: [0; BLOCK_LENGTH],\n            digest: [0; DIGEST_LENGTH],\n        }\n    }\n    /// Update the internal state of the MD5 object with new data.\n    pub fn transform(\u0026mut self, data: \u0026[u8]) -\u003e \u0026mut Self {\n        const fn f(x: u32, y: u32, z: u32) -\u003e u32 {\n            (x \u0026 y) | (!x \u0026 z)\n        }\n\n        const fn g(x: u32, y: u32, z: u32) -\u003e u32 {\n            (x \u0026 z) | (y \u0026 !z)\n        }\n\n        const fn h(x: u32, y: u32, z: u32) -\u003e u32 {\n            x ^ y ^ z\n        }\n\n        const fn i(x: u32, y: u32, z: u32) -\u003e u32 {\n            y ^ (x | !z)\n        }\n        let (mut a, mut b, mut c, mut d): (u32, u32, u32, u32) =\n            (self.state[0], self.state[1], self.state[2], self.state[3]);\n\n        for (idx, t_value) in T_VALUES.iter().enumerate() {\n            let (value, g): (u32, usize) = match idx {\n                0..=15 =\u003e (f(b, c, d), idx),\n                16..=31 =\u003e (g(b, c, d), (5 * idx + 1) % DIGEST_LENGTH),\n                32..=47 =\u003e (h(b, c, d), (3 * idx + 5) % DIGEST_LENGTH),\n                48..=63 =\u003e (i(b, c, d), (7 * idx) % DIGEST_LENGTH),\n                _ =\u003e unreachable!(),\n            };\n            let part_value = u32::from_ne_bytes(\n                data[4 * g..4 * g + 4]\n                    .try_into()\n                    .expect(\"Couldn't transform slice into array\"),\n            );\n            let f = value\n                .wrapping_add(a)\n                .wrapping_add(*t_value)\n                .wrapping_add(part_value);\n            a = d;\n            d = c;\n            c = b;\n            b = b.wrapping_add(f.rotate_left(SHIFTS[idx].into()));\n        }\n        self.state[0] = self.state[0].wrapping_add(a);\n        self.state[1] = self.state[1].wrapping_add(b);\n        self.state[2] = self.state[2].wrapping_add(c);\n        self.state[3] = self.state[3].wrapping_add(d);\n\n        self\n    }\n    /// Update the internal state of the MD5 object with new data.\n    pub fn update_with_len(\u0026mut self, value: \u0026[u8], nbytes: usize) -\u003e \u0026mut Self {\n        // Compute number of bytes mod 64\n        let mut offset = ((self.count[0] \u003e\u003e 3) \u0026 63) as usize;\n        let nbits = (nbytes \u003c\u003c 3) as u32;\n        let p = value;\n\n        if nbytes == 0 {\n            return self;\n        }\n\n        // Update the number of bits\n        self.count[0] = self.count[0].wrapping_add(nbits);\n        if self.count[0] \u003c nbits {\n            self.count[1] += 1;\n        }\n\n        self.count[1] += (nbytes \u003e\u003e 29) as u32;\n\n        let part_len = BLOCK_LENGTH - offset;\n        let mut i = part_len;\n\n        // Transform as many times as possible\n        if nbytes \u003e= part_len {\n            self.buffer[offset..(offset + part_len)].clone_from_slice(\u0026p[..part_len]);\n            let buf = self.buffer;\n            self.transform(\u0026buf);\n\n            while i \u003c nbytes - part_len {\n                if nbytes - i \u003e= 64 {\n                    let buf = self.buffer[i..i + part_len].to_vec();\n                    self.transform(\u0026buf);\n                    i += 64;\n                } else {\n                    break;\n                }\n            }\n            offset = 0;\n        } else {\n            i = 0;\n        }\n\n        // Add remaining input in buffer\n        self.buffer[offset..(offset + nbytes - i)].clone_from_slice(\u0026p[i..nbytes]);\n        self\n    }\n}\n\nimpl Default for MD5 {\n    /// Create a new instance of the MD5 struct.\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Display for MD5 {\n    /// Display the current MD5 value.\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        for di in self.digest {\n            write!(f, \"{di:02x}\")?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":120,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":200},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":455},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":455},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":458},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":458},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":3457},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3430},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2140},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1721},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1292},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":864},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1724},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":685},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":332},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":21},"fn_name":null}],"covered":86,"coverable":89},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","params.rs"],"content":"/// MD5Params\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct MD5Params {\n    /// A\n    pub a: u32,\n    /// B\n    pub b: u32,\n    /// C\n    pub c: u32,\n    /// D\n    pub d: u32,\n    /// X\n    pub x: u32,\n    /// S\n    pub s: u8,\n    /// AC\n    pub ac: u32,\n}\n\nimpl MD5Params {\n    /// Create a new instance of the MD5Params struct.\n    pub fn new(a: u32, b: u32, c: u32, d: u32, x: u32, s: u8, ac: u32) -\u003e Self {\n        Self {\n            a,\n            b,\n            c,\n            d,\n            x,\n            s,\n            ac,\n        }\n    }\n}\n/// Rotate left\npub fn f(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    let res = mdg_f(b, c, d);\n\n    params.a = params\n        .a\n        .wrapping_add(res.wrapping_add(params.x.wrapping_add(params.ac)));\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(res)\n}\n/// Rotate left\npub fn g(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    params.a = params.a.wrapping_add(params.x.wrapping_add(params.ac));\n    params.a = params.a.wrapping_add(!d \u0026 c);\n    params.a = params.a.wrapping_add(d \u0026 b);\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(!d \u0026 c)\n}\n/// Rotate left\npub fn h(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    params.a = params.a.wrapping_add(params.x.wrapping_add(params.ac));\n    params.a = params.a.wrapping_add(b ^ c ^ d);\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(b ^ c ^ d)\n}\n/// Rotate left\npub fn i(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    params.a = params.a.wrapping_add(params.x.wrapping_add(params.ac));\n    params.a = params.a.wrapping_add(c ^ (d | !b));\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(c ^ (d | !b))\n}\n#[inline(always)]\n/// mdg_f\npub fn mdg_f(x: u32, y: u32, z: u32) -\u003e u32 {\n    (x \u0026 y) | (!x \u0026 z)\n}\n\n#[inline(always)]\n/// mdg_h\npub fn mdg_h(x: u32, y: u32, z: u32) -\u003e u32 {\n    x ^ y ^ z\n}\n/// mdg_i\n#[inline(always)]\npub fn mdg_i(x: u32, y: u32, z: u32) -\u003e u32 {\n    y ^ (x | !z)\n}\n/// Rotate left\n#[inline(always)]\npub fn rotate_left(x: u32, n: u32) -\u003e u32 {\n    (x \u003c\u003c n) | (x \u003e\u003e (32 - n))\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":64,"coverable":64},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","constants.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate mdg;\n    use self::mdg::constants::{\n        BLOCK_LENGTH, DIGEST_LENGTH, INITIAL_STATE, PADDING, SHIFTS, T_VALUES,\n    };\n\n    #[test]\n    fn test_block_length() {\n        assert_eq!(BLOCK_LENGTH, 64);\n    }\n\n    #[test]\n    fn test_digest_length() {\n        assert_eq!(DIGEST_LENGTH, 16);\n    }\n\n    #[test]\n    fn test_initial_state() {\n        assert_eq!(\n            INITIAL_STATE,\n            [0x6745_2301, 0xefcd_ab89, 0x98ba_dcfe, 0x1032_5476]\n        );\n    }\n\n    #[test]\n    fn test_shifts() {\n        assert_eq!(\n            SHIFTS,\n            [\n                7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14,\n                20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11,\n                16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_padding() {\n        assert_eq!(\n            PADDING,\n            [\n                0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_t_values() {\n        assert_eq!(\n            T_VALUES,\n            [\n                0xd76a_a478,\n                0xe8c7_b756,\n                0x2420_70db,\n                0xc1bd_ceee,\n                0xf57c_0faf,\n                0x4787_c62a,\n                0xa830_4613,\n                0xfd46_9501,\n                0x6980_98d8,\n                0x8b44_f7af,\n                0xffff_5bb1,\n                0x895c_d7be,\n                0x6b90_1122,\n                0xfd98_7193,\n                0xa679_438e,\n                0x49b4_0821,\n                0xf61e_2562,\n                0xc040_b340,\n                0x265e_5a51,\n                0xe9b6_c7aa,\n                0xd62f_105d,\n                0x0244_1453,\n                0xd8a1_e681,\n                0xe7d3_fbc8,\n                0x21e1_cde6,\n                0xc337_07d6,\n                0xf4d5_0d87,\n                0x455a_14ed,\n                0xa9e3_e905,\n                0xfcef_a3f8,\n                0x676f_02d9,\n                0x8d2a_4c8a,\n                0xfffa_3942,\n                0x8771_f681,\n                0x6d9d_6122,\n                0xfde5_380c,\n                0xa4be_ea44,\n                0x4bde_cfa9,\n                0xf6bb_4b60,\n                0xbebf_bc70,\n                0x289b_7ec6,\n                0xeaa1_27fa,\n                0xd4ef_3085,\n                0x0488_1d05,\n                0xd9d4_d039,\n                0xe6db_99e5,\n                0x1fa2_7cf8,\n                0xc4ac_5665,\n                0xf429_2244,\n                0x432a_ff97,\n                0xab94_23a7,\n                0xfc93_a039,\n                0x655b_59c3,\n                0x8f0c_cc92,\n                0xffef_f47d,\n                0x8584_5dd1,\n                0x6fa8_7e4f,\n                0xfe2c_e6e0,\n                0xa301_4314,\n                0x4e08_11a1,\n                0xf753_7e82,\n                0xbd3a_f235,\n                0x2ad7_d2bb,\n                0xeb86_d391,\n            ]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","digest.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate mdg;\n\n    use mdg::*;\n\n    #[test]\n    fn test_mdg_reset() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        mdg.reset();\n        let digest = mdg::MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_mdg_update() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        let digest = mdg::MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_mdg_hexdigest() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        let digest = mdg::MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n    #[test]\n    fn test_reset_file() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        mdg.reset_file(\"file.txt\");\n        assert_eq!(mdg::MD5::hexdigest(\"\"), \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","lib.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate mdg;\n    use std::cmp;\n\n    use mdg::{Digest, MD5};\n\n    extern crate cjwt;\n    use self::cjwt::{Algorithm, JWT};\n\n    #[test]\n    fn test_mdg_0() {\n        let digest = MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_mdg_1() {\n        let digest = MD5::hexdigest(\"a\");\n        assert_eq!(digest, \"0cc175b9c0f1b6a831c399e269772661\");\n    }\n\n    #[test]\n    fn test_mdg_2() {\n        let digest = MD5::hexdigest(\"abc\");\n        assert_eq!(digest, \"900150983cd24fb0d6963f7d28e17f72\");\n    }\n\n    #[test]\n    fn test_mdg_3() {\n        let digest = MD5::hexdigest(\"message digest\");\n        assert_eq!(digest, \"f96b697d7cb7938d525a2f31aaf161d0\");\n    }\n\n    #[test]\n    fn test_mdg_4() {\n        let digest = MD5::hexdigest(\"abcdefghijklmnopqrstuvwxyz\");\n        assert_eq!(digest, \"c3fcd3d76192e4007dfb496cca67e13b\");\n    }\n\n    #[test]\n    fn test_mdg_5() {\n        let digest =\n            MD5::hexdigest(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\");\n        assert_eq!(digest, \"d174ab98d277d9f5a5611c2c9f419d9f\");\n    }\n\n    #[test]\n    fn test_mdg_6() {\n        let digest = MD5::hexdigest(\n            \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n        );\n        assert_eq!(digest, \"57edf4a22be3c955ac49da2e2107b67a\");\n    }\n\n    #[test]\n    fn test_update_mdg_many_times() {\n        let digest = MD5::new()\n            .update(b\"a\")\n            .update(b\"b\")\n            .update(b\"c\")\n            .finalize()\n            .to_string();\n        assert_eq!(digest, \"900150983cd24fb0d6963f7d28e17f72\");\n    }\n\n    #[test]\n    fn test_reset() {\n        let digest = MD5::new().update(b\"a\").reset().finalize().to_string();\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_to_string_before_finalize() {\n        let digest = MD5::new().update(b\"a\").to_string();\n        // Is this acceptable? Or make it an Option that can be None?\n        assert_eq!(digest, \"00000000000000000000000000000000\");\n    }\n\n    #[test]\n    fn update_with_len() {\n        let digest = MD5::new().update_with_len(b\"abc\", 3).finalize().to_string();\n        assert_eq!(digest, \"900150983cd24fb0d6963f7d28e17f72\");\n    }\n    #[test]\n    fn update_file() {\n        let digest = MD5::new().update_file(\"update.txt\").finalize().to_string();\n        assert_eq!(digest, \"47353a0e5ed2e1e0d57213a39e9bb7c4\");\n    }\n    #[test]\n    fn hexdigest_file() {\n        let digest = MD5::hexdigest_file(\"update.txt\");\n        assert_eq!(digest, \"47353a0e5ed2e1e0d57213a39e9bb7c4\");\n    }\n    #[test]\n    fn reset_file() {\n        let digest = MD5::new()\n            .update_file(\"update.txt\")\n            .reset()\n            .finalize()\n            .to_string();\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n    #[test]\n    fn transform() {\n        let digest = MD5::new().update_file(\"update.txt\").finalize().to_string();\n        assert_eq!(digest, \"47353a0e5ed2e1e0d57213a39e9bb7c4\");\n    }\n    #[test]\n    fn test_algorithm_to_string() {\n        let hs256 = Algorithm::HS256;\n        assert_eq!(hs256.to_string(), \"HS256\");\n\n        let rs512 = Algorithm::RS512;\n        assert_eq!(rs512.to_string(), \"RS512\");\n    }\n\n    #[test]\n    fn test_default_algorithm() {\n        let default_alg = Algorithm::default();\n        assert_eq!(default_alg, Algorithm::HS256);\n    }\n\n    #[test]\n    fn test_default_jwt() {\n        let default_jwt = JWT::default();\n        assert_eq!(default_jwt.header.alg, Some(Algorithm::HS256));\n        assert_eq!(default_jwt.token, String::new());\n    }\n    #[test]\n    fn test_reset_file() {\n        let mut mdg = MD5::new();\n        mdg.finalize();\n        mdg.reset();\n        assert_eq!(mdg.to_string(), \"00000000000000000000000000000000\");\n    }\n    #[test]\n    fn test_default() {\n        let mut mdg = MD5::default();\n        mdg.finalize();\n        mdg.reset();\n        assert_eq!(mdg.to_string(), \"00000000000000000000000000000000\");\n    }\n\n    #[test]\n    fn test_update_with_len() {\n        let mut md5 = MD5::new();\n        let data = b\"test data\";\n        let nbytes = data.len();\n\n        // Test updating with non-empty data\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [72, 0]);\n        assert_eq!(md5.buffer[0..nbytes], data[..]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with empty data\n        md5.update_with_len(b\"\", 0);\n        assert_eq!(md5.count, [0, 0]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with data that is smaller than part_len\n        let data = b\"test\";\n        let nbytes = data.len();\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [32, 0]);\n        assert_eq!(md5.buffer[0..nbytes], data[..]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with data that is larger than part_len\n        let data = b\"test data test data test data\";\n        let nbytes = data.len();\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [232, 0]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with data that results in overflow of count[0]\n        let data = b\"test data\";\n        let nbytes = data.len();\n        md5.count[0] = u32::max_value();\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [71, 1]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n    }\n    #[test]\n    fn test_update_with_len_large_data() {\n        let mut md5 = MD5::new();\n        let data = vec![1; 128];\n        let nbytes = data.len();\n\n        md5.update_with_len(\u0026data, nbytes);\n        assert_eq!(md5.count, [1024, 0]);\n\n        let buffer_len = cmp::min(md5.buffer.len(), nbytes);\n        assert_eq!(md5.buffer[0..buffer_len], data[..buffer_len]);\n\n        let buf = md5.buffer[0..buffer_len].to_vec();\n        md5.transform(\u0026buf);\n        assert_eq!(buffer_len \u003e= 64, true);\n        assert_eq!(md5.count, [1024, 0]);\n\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Check the state of the md5 after each iteration of the while loop\n        let state1 = md5.state;\n        assert_ne!(state1, [0; 4]);\n\n        let state2 = md5.state;\n        assert_ne!(state2, [0; 4]);\n        assert_eq!(state1, state2);\n\n        md5.reset();\n    }\n    #[test]\n    fn test_transform_with_sufficient_buffer_length() {\n        const NBYTES: usize = 1024;\n        const PART_LEN: usize = 512;\n\n        let mut md5 = MD5::new();\n        md5.count = [NBYTES as u32, 0];\n        let mut buffer = [0; NBYTES];\n\n        // Fill the buffer with some data\n        for i in 0..NBYTES {\n            buffer[i] = i as u8;\n        }\n\n        let mut i = 0;\n        while i \u003c NBYTES - PART_LEN {\n            if NBYTES - i \u003e= PART_LEN {\n                let buf = \u0026buffer[i..(i + PART_LEN)];\n                md5.transform(buf);\n                i += PART_LEN;\n\n                assert_eq!(i, PART_LEN);\n                assert_eq!(md5.count, [1024, 0]);\n            } else {\n                let part_len = NBYTES - i;\n                let buf = \u0026buffer[i..(i + part_len)];\n                md5.transform(buf);\n                i += part_len;\n\n                assert_eq!(i, NBYTES);\n                assert_eq!(md5.count, [1024, 0]);\n            }\n        }\n\n        let mut md5 = MD5::new();\n        md5.count = [NBYTES as u32, 0];\n        let mut buffer = [0; NBYTES];\n\n        // Fill the buffer with some data\n        for i in 0..NBYTES {\n            buffer[i] = i as u8;\n        }\n\n        let mut i = 0;\n        while i \u003c NBYTES - PART_LEN {\n            if NBYTES - i \u003e= PART_LEN {\n                let buf = \u0026buffer[i..(i + PART_LEN)];\n                md5.transform(buf);\n                i += PART_LEN;\n\n                assert_eq!(i, PART_LEN);\n                assert_eq!(md5.count, [1024, 0]);\n            } else {\n                let part_len = NBYTES - i;\n                let buf = \u0026buffer[i..(i + part_len)];\n                md5.transform(buf);\n                i += part_len;\n\n                assert_eq!(i, NBYTES);\n                assert_eq!(md5.count, [1024, 0]);\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","params.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate mdg;\n    use mdg::*;\n\n    #[test]\n    fn test_mdg_params_new() {\n        let params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(params.a, 0);\n        assert_eq!(params.b, 1);\n        assert_eq!(params.c, 2);\n        assert_eq!(params.d, 3);\n        assert_eq!(params.x, 4);\n        assert_eq!(params.s, 5);\n    }\n\n    #[test]\n    fn test_f() {\n        let mut params: MD5Params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(f(\u0026mut params), ((!1 \u0026 3) + 1));\n    }\n\n    #[test]\n    fn test_g() {\n        let mut params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(g(\u0026mut params), 1 \u0026 3);\n    }\n\n    #[test]\n    fn test_h() {\n        let mut params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(h(\u0026mut params), 1 ^ 2 ^ (3 - 1));\n    }\n\n    #[test]\n    fn test_i() {\n        let mut params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(i(\u0026mut params), 2 ^ ((1 | !3) - 1));\n    }\n    #[test]\n    fn test_mdg_f() {\n        assert_eq!(mdg_f(1, 2, 3), (!1 \u0026 3));\n    }\n\n    #[test]\n    fn test_mdg_h() {\n        assert_eq!(mdg_h(1, 2, 3), 1 ^ 2 ^ 3);\n    }\n\n    #[test]\n    fn test_mdg_i() {\n        assert_eq!(mdg_i(1, 2, 3), 2 ^ (1 | !3));\n    }\n\n    #[test]\n    fn test_rotate_left() {\n        assert_eq!(rotate_left(0b1010, 2), 0b101000);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","benches","psph.rs"],"content":"use cmn::constants::*;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse psph::Password;\n\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"Password::new\", |b| {\n        b.iter(|| {\n            Password::new(\n                black_box(4),\n                black_box(\"-\"),\n                black_box(SPECIAL_CHARS.to_vec()),\n            )\n        })\n    });\n}\ncriterion_group!(benches, new_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","examples","psph.rs"],"content":"use cmn::constants::*;\nuse psph::Password;\n\nfn main() {\n    let password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n    println!(\n        \"ðŸ¦€ Password::default():           âœ… {}\",\n        Password::default()\n    );\n    println!(\"ðŸ¦€ Password::new():               âœ… {password}\");\n    println!(\n        \"ðŸ¦€ Password::passphrase():        âœ… {}\",\n        password.passphrase()\n    );\n    let mut password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n    println!(\"ðŸ¦€ Password::set_passphrase\");\n    println!(\n        \"    ðŸ”“ Original passphrase:       âœ… {}\",\n        password.passphrase()\n    );\n    password.set_passphrase(\"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\");\n    println!(\n        \"    ðŸ” Updated passphrase:        âœ… {}\",\n        password.passphrase()\n    );\n    println!(\"ðŸ¦€ Password::len():               âœ… {}\", password.len());\n    println!(\n        \"ðŸ¦€ Password::is_empty():          âœ… {}\",\n        password.is_empty()\n    );\n    println!(\"ðŸ¦€ Password::hash():              âœ… {}\", password.hash());\n    println!(\n        \"ðŸ¦€ Password::password_length():   âœ… {}\",\n        password.password_length()\n    );\n    println!(\n        \"ðŸ¦€ Password::hash_length():       âœ… {}\",\n        password.hash_length()\n    );\n\n    let entropy = Password::entropy(\u0026password) as u64;\n\n    match entropy {\n        x if x \u003c 40 =\u003e println!(\"ðŸ¦€ Password::entropy():  âŒ {entropy} bits (Poor)\"),\n        x if (40..55).contains(\u0026x) =\u003e {\n            println!(\"ðŸ¦€ Password::entropy():  âŒ {entropy} bits (Weak)\")\n        }\n        x if (56..70).contains(\u0026x) =\u003e {\n            println!(\"ðŸ¦€ Password::entropy():           âš ï¸ {entropy} bits (Reasonable)\",)\n        }\n        x if (71..80).contains(\u0026x) =\u003e {\n            println!(\"ðŸ¦€ Password::entropy():  âš ï¸ {entropy} bits (Strong)\")\n        }\n        _ =\u003e println!(\"ðŸ¦€ Password::entropy():           âœ… {entropy} bits (Excellent)\",),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for generating random passwords and passphrases\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-psph.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/psph.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/psph)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/psph)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/psph)\n//! [![License](https://img.shields.io/crates/l/psph.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! PassPhrase (PSPH) is a Rust library that empowers developers to\n//! elevate the security of their applications with ease. `PSPH`\n//! generates secure and strong passphrases using a unique combination\n//! of letters, numbers, cases, and symbols to form an unpredictable\n//! string of characters that doesn't resemble words or names with a\n//! high level of entropy.\n//!\n//! ## Features\n//!\n//! - Generate a random password / passphrase.\n//! - Calculate the entropy of a password.\n//! - Calculate the hash of a password.\n//! - Calculate the hash length of a password.\n//! - Check if a password is empty.\n//! - Get the length of a password.\n//! - Get the generated password / passphrase.\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-psph.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-psph.svg\",\n    html_root_url = \"https://docs.rs/psph\"\n)]\n#![crate_name = \"psph\"]\n#![crate_type = \"lib\"]\n\nextern crate cmn;\n/// constants\npub use cmn::constants::*;\n/// words\npub use cmn::words::WORD_LIST;\n\nextern crate hsh;\npub use hsh::Hash;\n\nextern crate vrd;\npub use vrd::Random;\n\nuse std::collections::{HashMap, HashSet};\nuse std::convert::TryInto;\nuse std::f64;\n\n/// A random password / passphrase generator. The generated password\n/// is a string of three words separated by hyphens. Each word is\n/// between 6 and 8 characters long. The first character of each word\n/// is capitalized.\n#[non_exhaustive]\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\npub struct Password {\n    /// The generated passphrase.\n    passphrase: String,\n    /// The special characters to use for replacing letters in words.\n    special_chars: Vec\u003cchar\u003e,\n    /// The separator to use between words.\n    separator: String,\n}\n\nimpl Password {\n    /// Calculates the entropy of a password based on its length, the\n    /// number of unique characters used in the password and the number\n    /// of bits of the hash generated from the password.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - An immutable reference to the password.\n    ///\n    /// # Returns\n    ///\n    /// * `f64` - The calculated entropy of the password.\n    ///\n    /// # Entropy Ranges\n    ///\n    /// The following ranges can give you an idea of how the entropy is\n    /// considered:\n    ///\n    /// - Poor: less than 40 bits\n    /// - Weak: 40-55 bits\n    /// - Reasonable: 56-70 bits\n    /// - Strong: 71-80 bits\n    /// - Excellent: 81 bits and above\n    ///\n    /// Keep in mind that these values are just rough estimates and the\n    /// actual entropy of a password depends on the distribution of\n    /// characters used in the password and the number of unique\n    /// characters in it, and not just its length.\n    ///\n    pub fn entropy(\u0026self) -\u003e f64 {\n        let l = self.len() as f64;\n        l * (94.0_f64.log2()).round()\n    }\n    /// Returns the hash of the generated passphrase.\n    pub fn hash(\u0026self) -\u003e String {\n        let mut hash = Hash::new();\n        hash.set_password(\u0026format!(\n            \"{}{}\",\n            self.passphrase,\n            self.special_chars.iter().collect::\u003cString\u003e()\n        ));\n        let hash_value = hash.hash();\n        hash_value.to_string()\n    }\n    /// Returns the hash length.\n    pub fn hash_length(\u0026self) -\u003e usize {\n        self.hash().len()\n    }\n    /// Returns true if the generated passphrase is empty.\n    /// Returns false if the generated passphrase is not empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.passphrase.is_empty()\n    }\n    /// Returns the length of the generated passphrase.\n    pub fn len(\u0026self) -\u003e usize {\n        self.passphrase.len()\n    }\n    /// Returns the generated passphrase.\n    pub fn new(len: u8, separator: \u0026str, special_chars: Vec\u003cchar\u003e) -\u003e Self {\n        // Setup a random number generator.\n        let mut rng = Random::default();\n\n        // Create a new vector to store the words in the passphrase.\n        let mut words: Vec\u003cString\u003e = Vec::new();\n\n        // Convert the special characters to a vector of chars.\n        let ascii: Vec\u003cchar\u003e = SPECIAL_CHARS.to_vec();\n\n        // Create a new HashSet to store the generated words.\n        let mut word_set = HashSet::new();\n\n        // Create a HashMap for storing seen characters for each word\n        let mut seen_chars = HashMap::new();\n\n        // Generate `len` random words from the word list.\n        while words.len() \u003c len.into() {\n            // Choose a random word from the list.\n            let mut word = if let Some(w) = Random::choose(\u0026mut rng, WORD_LIST) {\n                // If a word was found, return it.\n                w\n            } else {\n                // If no word was found, return an empty string.\n                \"\"\n            };\n\n            // Ensure that the random word is not already present in\n            // the vector of words\n            while words.contains(\u0026word.to_string()) {\n                word = if let Some(w) = Random::choose(\u0026mut rng, WORD_LIST) {\n                    // If a word was found, return it.\n                    w\n                } else {\n                    // If no word was found, return an empty string.\n                    \"\"\n                };\n\n                // Get the HashSet of seen characters for the word\n                let word_seen_chars: \u0026mut HashSet\u003cchar\u003e =\n                    seen_chars.entry(word.to_lowercase()).or_default();\n\n                // Iterate through each character in the word and check if it has been seen before\n                let mut has_repeated_chars = false;\n                for c in word.to_lowercase().chars() {\n                    if !word_seen_chars.insert(c) {\n                        has_repeated_chars = true;\n                        break;\n                    }\n                }\n\n                // If word has repeated characters, skip to the next iteration of the loop\n                if has_repeated_chars {\n                    continue;\n                }\n\n                // Check if the word is already in the HashSet. If it is, skip to the next iteration of the loop.\n                if word_set.contains(\u0026word.to_lowercase()) {\n                    continue;\n                }\n\n                // Add the word to the HashSet.\n                word_set.insert(word.to_lowercase());\n            }\n\n            // Generate a random uppercase or lowercase letter from the\n            // ASCII table.\n            let mut random_letter = Random::char(\u0026mut rng);\n\n            // Ensure that the random letter is not already present in\n            // the word that was chosen.\n            while word.contains(random_letter) {\n                random_letter = Random::char(\u0026mut rng);\n            }\n\n            // Convert the word to title case and add a number to the\n            // end of the word.\n            let mut word = word.to_owned();\n            let chars = word.chars().enumerate().collect::\u003cVec\u003c_\u003e\u003e();\n            for (i, c) in chars {\n                if i == 0 || !c.is_alphabetic() {\n                    continue;\n                }\n                let lower = c.to_lowercase().next().unwrap();\n                word.remove(i);\n                word.insert(i, lower);\n                word.insert(i + 1, lower.to_uppercase().next().unwrap());\n            }\n            let first_letter = word.chars().next().unwrap().to_uppercase().next().unwrap();\n            word.remove(0);\n            word.insert(0, first_letter);\n\n            // Generate a new random number between 0 and 99.\n            let nb = rng.range(HASH_COST.try_into().unwrap(), 99);\n\n            word.push(random_letter);\n            word.push(*Random::choose(\u0026mut rng, \u0026ascii).unwrap());\n            word.push_str(\u0026nb.to_string());\n\n            // Replace a random letter in the word with a special\n            // character from the list.\n            let mut chars: Vec\u003cchar\u003e = word.chars().collect();\n            let index = rng.range(0, (chars.len() - 1).try_into().unwrap()) as usize;\n            chars[index] = *Random::choose(\u0026mut rng, \u0026special_chars).unwrap();\n\n            word = chars.into_iter().collect();\n            words.push(word);\n        }\n        // Return the generated passphrase.\n        Self {\n            passphrase: words.join(separator),\n            special_chars,\n            separator: separator.to_string(),\n        }\n    }\n\n    /// Returns the generated passphrase.\n    pub fn passphrase(\u0026self) -\u003e \u0026str {\n        \u0026self.passphrase\n    }\n    /// Returns the password length.\n    pub fn password_length(\u0026self) -\u003e usize {\n        self.passphrase.len()\n    }\n    /// Sets the generated passphrase.\n    pub fn set_passphrase(\u0026mut self, passphrase: \u0026str) {\n        self.passphrase = passphrase.to_string();\n    }\n}\n\nimpl std::fmt::Display for Password {\n    /// Display the generated passphrase.\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.passphrase)\n    }\n}\n\nimpl Default for Password {\n    /// Default to a passphrase of 4 words.\n    fn default() -\u003e Self {\n        Self::new(4, \"-\", SPECIAL_CHARS.to_vec())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","tests","psph.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    use cmn::constants::*;\n    use psph::Password;\n    use vrd::Random;\n\n    #[test]\n    fn test_password() {\n        let password = Password::new(3, \"-\", SPECIAL_CHARS.to_vec());\n        assert_eq!(password.passphrase().split('-').count(), 3);\n    }\n\n    #[test]\n    fn test_default() {\n        let default_result = Password::default();\n        let expected_result = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n        assert_ne!(default_result, expected_result);\n    }\n\n    #[test]\n    fn test_set_password() {\n        let mut password = Password::new(3, \"-\", SPECIAL_CHARS.to_vec());\n        password.set_passphrase(\"test\");\n        assert_eq!(password.passphrase(), \"test\");\n    }\n\n    #[test]\n    fn test_password_entropy() {\n        let password = Password::new(4, \"-\", vec!['!', '@', '#']);\n        let entropy = password.entropy();\n        assert!(entropy \u003e 71.0);\n    }\n\n    #[test]\n    fn test_password_hash_length() {\n        let password = Password::new(4, \"-\", vec!['!', '@', '#']);\n        let hash_length = password.hash_length();\n        assert_eq!(hash_length, 64);\n    }\n\n    #[test]\n    fn test_password_is_empty() {\n        let password = Password::new(0, \"-\", vec!['!', '@', '#']);\n        let is_empty = password.is_empty();\n        assert!(is_empty, \"{}\", password.passphrase());\n    }\n\n    #[test]\n    fn test_password_length() {\n        let mut password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n        password.set_passphrase(\"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\");\n        assert_eq!(password.password_length(), 36);\n    }\n\n    #[test]\n    fn test_password_default() {\n        let len = 4;\n        let password = Password::new(len, \"-\", SPECIAL_CHARS.to_vec());\n        assert!(password.passphrase().split('-').count() == len.into());\n    }\n\n    #[test]\n    fn test_password_display() {\n        let mut password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n        password.set_passphrase(\"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\");\n        assert_eq!(\n            format!(\"{password}\"),\n            \"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\"\n        );\n    }\n\n    #[test]\n    fn test_wordlist() {\n        let words: Vec\u003cString\u003e = vec![\"mini\".to_string(), \"functions\".to_string()];\n        let mut rng = Random::default();\n        while words.len() \u003c 2 {\n            if let Some(w) = Random::choose(\u0026mut rng, words.as_slice()) {\n                assert!(words.contains(w));\n            } else {\n                assert!(words.is_empty());\n            };\n        }\n    }\n    #[test]\n    fn test_wordlist_is_empty() {\n        let word = \"\";\n        assert!(word.is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","benches","qrc.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse image::Rgba;\nextern crate qrc;\nuse self::qrc::QRCode;\n\n// Benchmark for QRCode::new\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"QRCode::new\", |b| {\n        b.iter(|| QRCode::new(black_box(vec![1, 2, 3])))\n    });\n}\n// Benchmark for QRCode::to_png\nfn to_png_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    c.bench_function(\"QRCode::to_png\", |b| b.iter(|| qrcode.to_png(512)));\n}\n\n// Benchmark for QRCode::from_string\nfn from_string_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"QRCode::from_string\", |b| {\n        b.iter(|| QRCode::from_string(black_box(\"Hello, world!\".to_string())))\n    });\n}\n\n// Benchmark for QRCode::from_bytes\nfn from_bytes_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"QRCode::from_bytes\", |b| {\n        b.iter(|| QRCode::from_bytes(black_box(vec![1, 2, 3])))\n    });\n}\n\n// Benchmark for QRCode::to_svg\nfn to_svg_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    c.bench_function(\"QRCode::to_svg\", |b| {\n        b.iter(|| qrcode.to_svg(black_box(100)))\n    });\n}\n\n// Benchmark for QRCode::colorize\nfn colorize_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    let color = Rgba([0, 0, 0, 0]);\n    c.bench_function(\"QRCode::colorize\", |b| {\n        b.iter(|| qrcode.colorize(black_box(color)))\n    });\n}\n\n// Benchmark for QRCode::resize\nfn resize_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    c.bench_function(\"QRCode::resize\", |b| {\n        b.iter(|| qrcode.resize(black_box(100), black_box(100)))\n    });\n}\n\ncriterion_group!(\n    benches,\n    colorize_benchmark,\n    from_bytes_benchmark,\n    from_string_benchmark,\n    new_benchmark,\n    resize_benchmark,\n    to_png_benchmark,\n    to_svg_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","examples","qrc.rs"],"content":"extern crate image;\nuse image::{imageops, ImageBuffer, Rgba, RgbaImage};\nextern crate qrc;\nuse self::qrc::{add_image_watermark, qr_code, qr_code_to, QRCode};\nuse std::fs; // Import the fs module from the standard library // Import the QRCode struct from the mini_functions crate\n\nconst URL: \u0026str = \"https://minifunctions.com/\"; // Define a constant for the URL to be encoded\n\nfn main() {\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation\n    let qrcode = QRCode::from_string(URL.to_string()); // Create a new QRCode using the QRCode::from_string() function\n    let png = qrcode.to_png(512); // Convert the QRCode into a PNG representation\n    let png_data = png.into_raw(); // Convert the PNG representation of the QRCode into a vector of bytes\n    let png_image = ImageBuffer::\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e::from_raw(21, 21, png_data).unwrap();\n    println!(\n        \"ðŸ¦€ fn to_png():                âœ… {:?}\",\n        png_image.save(\"qrcode.png\")\n    ); // Print the PNG representation of the QRCode\n    match png_image.save(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file created:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file created:           âŒ qrcode.png: {e}\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n    match fs::remove_file(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file removed:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file removed:           âŒ qrcode.png: {e}\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom color\n    let qrcode = QRCode::from_string(URL.to_string());\n    let red = Rgba([255, 0, 0, 255]);\n    let red_qrcode = qrcode.colorize(red); // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom color\n    let img: RgbaImage = red_qrcode; // Convert the colorized QR code to a PNG image.\n    let new_width = 512;\n    let new_height = 512;\n    let resized_img = imageops::resize(\u0026img, new_width, new_height, imageops::FilterType::Nearest);\n    let image: ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e = resized_img; // Convert the colorized QR code to a PNG image.\n    println!(\n        \"ðŸ¦€ fn colorize():              âœ… {:?}\",\n        image.save(\"qrcode_colorized.png\")\n    ); // Print the PNG representation of the QRCode\n    match image.save(\"qrcode_colorized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ colorized png file created: âœ… qrcode_colorized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ colorized png file created: âŒ qrcode_colorized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode_colorized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ colorized png file removed: âœ… qrcode_colorized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ colorized png file removed: âŒ qrcode_colorized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to an SVG representation\n    let qrcode = QRCode::from_string(URL.to_string());\n    let qrcode_svg = qrcode.to_svg(512); // Convert the QRCode into an SVG representation\n    match fs::write(\"qrcode.svg\", qrcode_svg) {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file created:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file created:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n    match fs::remove_file(\"qrcode.svg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file removed:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file removed:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom size\n    let qrcode = QRCode::new(vec![0x61, 0x62, 0x63]);\n    let resized_image: RgbaImage = qrcode.resize(512, 512);\n    println!(\n        \"ðŸ¦€ fn resize():                âœ… {:?}\",\n        resized_image.save(\"qrcode_resized.png\")\n    ); // Print the PNG representation of the QRCode\n    match resized_image.save(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file created:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file created:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file removed:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file removed:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom size\n    let qrcode = QRCode::new(vec![0x61, 0x62, 0x63]);\n    let resized_image: RgbaImage = qrcode.resize(512, 512);\n    println!(\n        \"ðŸ¦€ fn resize():                âœ… {:?}\",\n        resized_image.save(\"qrcode_resized.png\")\n    ); // Print the PNG representation of the QRCode with a custom size of 512x512\n    match resized_image.save(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file created:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file created:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file removed:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file removed:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    // Create a new QRCode using the macro qr_code and convert it to an SVG representation with a custom size of 512x512\n    let qrcode = qr_code!(URL.into());\n    let qrcode_svg = qrcode.to_svg(512); // Convert the QRCode into an SVG representation with a custom size of 512x512\n    match fs::write(\"qrcode.svg\", qrcode_svg) {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file created:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file created:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n    match fs::remove_file(\"qrcode.svg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file removed:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file removed:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n    // Create a new QRCode using the macro qr_code_to into a PNG representation with a custom size of 512x512\n    let qrcode = qr_code_to!(URL.into(), \"png\", 512);\n    match qrcode.save(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file created:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file created:           âŒ qrcode.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file removed:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file removed:           âŒ qrcode.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    // Create a new QRCode using the macro qr_code_from into a GIF representation with a custom size of 512x512\n    let qrcode = qr_code_to!(URL.into(), \"gif\", 512);\n    match qrcode.save(\"qrcode.gif\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ gif file created:           âœ… qrcode.gif\"), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n        Err(e) =\u003e println!(\"ðŸ¦€ gif file created:           âŒ qrcode.gif: {e}\",), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n    }\n    match fs::remove_file(\"qrcode.gif\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ gif file removed:           âœ… qrcode.gif\"), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n        Err(e) =\u003e println!(\"ðŸ¦€ gif file removed:           âŒ qrcode.gif: {e}\",), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n    }\n    // Create a new QRCode using the macro qr_code_to into a JPEG representation with a custom size of 512x512\n    let qrcode = qr_code_to!(URL.into(), \"jpg\", 512);\n    match qrcode.save(\"qrcode.jpg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ jpg file created:           âœ… qrcode.jpg\"), // Print the path to the JPG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ jpg file created:          âŒ qrcode.jpg: {e}\",), // Print the path to the JPEG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n    }\n    match fs::remove_file(\"qrcode.jpg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ jpg file removed:           âœ… qrcode.jpg\"), // Print the path to the JPG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ jpg file removed:           âŒ qrcode.jpg: {e}\",), // Print the path to the JPEG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n    }\n\n    // Create a new QRCode add a watermark to it and save it as a PNG file\n    let qrcode = QRCode::from_string(URL.to_string());\n    let mut qrcode_img = qrcode.to_png(512);\n    let watermark_img = image::open(\"bubba.ico\").unwrap().into_rgba8();\n    add_image_watermark!(\u0026mut qrcode_img, \u0026watermark_img);\n    match qrcode_img.save(\"qrcode_watermarked.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file with watermark:           âœ… qrcode_watermarked.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file with watermark:           âŒ qrcode_watermarked.png: {e}\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n    match fs::remove_file(\"qrcode_watermarked.png\") {\n        Ok(_) =\u003e {\n            println!(\"ðŸ¦€ png file with watermark removed:           âœ… qrcode_watermarked.png\")\n        } // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e {\n            println!(\"ðŸ¦€ png file with watermark removed:           âŒ qrcode_watermarked.png: {e}\")\n        } // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for generating and manipulating QR code images in various formats\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-qrc.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/qrc.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/qrc/)\n//! [![Docs.rs](https://img.shields.io/badge/docs.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://docs.rs/qrc)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/qrc)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/qrc)\n//! [![License](https://img.shields.io/crates/l/qrc.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The QR Code Library (QRC) is a versatile tool for generating and\n//! manipulating QR code images in various formats.\n//!\n//! With this library, you can easily convert your data into a QR code,\n//! whether it be in the form of a string or a vector of bytes.\n//!\n//! Choose from popular image formats like PNG, JPG, GIF and SVG, and\n//! even customize the size and color of your QR code.\n//!\n//! ## Features\n//!\n//! `QRC` features a `QRCode` struct that can be constructed with a\n//! `Vec\u003cu8\u003e` of data or a `String` of data that will be converted to\n//! a `Vec\u003cu8\u003e`.\n//!\n//! The QR code can be generated using the zto_qrcode` method, and\n//! specific image formats can be generated using the `to_png`,\n//! `to_jpg`, and `to_gif` methods.\n//!\n//! Each of these methods takes a `width` parameter and returns an\n//! `ImageBuffer` containing the QR code image.\n//!\n//! The library uses the qrcode and image crates to generate the QR\n//! code images.\n//!\n//! As of the current version, the library supports the following\n//! features with the following status:\n//!\n//! | Feature | Description |\n//! | ------- | ----------- |\n//! | Library license | Apache-2.0 OR MIT |\n//! | Library version | 0.0.1 |\n//! | Mode Numeric | not specified |\n//! | Mode Alphanumeric | not specified |\n//! | Mode Byte | not specified |\n//! | Mode Kanji | not specified |\n//! | Mode ECI | not specified |\n//! | Mode FNC1 | not specified |\n//! | Mode Structured Append | not specified |\n//! | Mode Hanzi | not specified |\n//! | Mixing modes | not specified |\n//! | QR Codes version 1 - 40 | not specified |\n//! | Micro QR Codes version M1 - M4 | not specified |\n//! | Find maximal error correction level | not specified |\n//! | Optimize QR Codes | not specified |\n//! | PNG output | supported |\n//! | JPG output | supported |\n//! | GIF output | supported |\n//! | SVG output | supported |\n//! | EPS output | not specified |\n//! | PDF output | not specified |\n//! | BMP output | not specified |\n//! | TIFF output | not specified |\n//! | WebP output | not specified |\n//! | Black and white QR Codes | Yes |\n//! | Colorized QR code | Yes |\n//! | Animated QR Codes (GIF, APNG, WebP) | not specified |\n//! | Changing size of modules (scaling factor) | not specified |\n//! | Command line script | not specified |\n//! | QR code resizing | supported |\n//! | QR code watermarking | supported |\n//! | QR code with logo | supported |\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-qrc.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-qrc.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"qrc\"]\n#![crate_type = \"lib\"]\n\nextern crate image;\nextern crate qrcode;\n\nuse image::{ImageBuffer, Rgba, RgbaImage};\nuse qrcode::render::svg;\nuse qrcode::QrCode;\n\n#[non_exhaustive]\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]\n/// QRCode is a structure that contains data in the form of a vector of\n/// bytes.\npub struct QRCode {\n    /// The `data` field holds the data to be encoded in the QR code.\n    pub data: Vec\u003cu8\u003e,\n}\n/// Implementation of QRCode structure.\nimpl QRCode {\n    /// Creates a new QRCode structure with the given data.\n    pub fn new(data: Vec\u003cu8\u003e) -\u003e Self {\n        QRCode { data }\n    }\n\n    /// The `from_string` method creates a new instance of the QRCode\n    /// struct by converting the given string data into a vector of\n    /// bytes\n    pub fn from_string(data: String) -\u003e Self {\n        QRCode {\n            data: data.into_bytes(),\n        }\n    }\n\n    /// Creates a new QRCode structure from a vector of bytes.\n    pub fn from_bytes(data: Vec\u003cu8\u003e) -\u003e Self {\n        QRCode { data }\n    }\n\n    /// Converts the QRCode structure to a QrCode structure.\n    pub fn to_qrcode(\u0026self) -\u003e QrCode {\n        QrCode::new(\u0026self.data).unwrap()\n    }\n\n    /// Converts the QRCode structure to a PNG image.\n    pub fn to_png(\u0026self, width: u32) -\u003e ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\n        let qrcode = self.to_qrcode();\n        let height = width;\n        let mut img = ImageBuffer::new(width, height);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n            let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n            *pixel = match qrcode[(x_index as usize, y_index as usize)] {\n                qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n            };\n        }\n        img\n    }\n    /// Converts the QRCode structure to a JPG image.\n    pub fn to_jpg(\u0026self, width: u32) -\u003e ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\n        let qrcode = self.to_qrcode();\n        let height = width;\n        let mut img = ImageBuffer::new(width, height);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n            let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n            *pixel = match qrcode[(x_index as usize, y_index as usize)] {\n                qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n            };\n        }\n        img\n    }\n    /// Converts the QRCode structure to a GIF image.\n    pub fn to_gif(\u0026self, width: u32) -\u003e ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\n        let qrcode = self.to_qrcode();\n        let height = width;\n        let mut img = ImageBuffer::new(width, height);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n            let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n            *pixel = match qrcode[(x_index as usize, y_index as usize)] {\n                qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n            };\n        }\n        img\n    }\n\n    /// Converts the QRCode structure to an SVG image.\n    pub fn to_svg(\u0026self, width: u32) -\u003e String {\n        let qrcode = self.to_qrcode();\n        let svg_string = qrcode\n            .render::\u003csvg::Color\u003e()\n            .min_dimensions(width, width)\n            .dark_color(svg::Color(\"#000000\"))\n            .light_color(svg::Color(\"#FFFFFF\"))\n            .build();\n        svg_string\n    }\n\n    /// The `colorize` method creates a new PNG image of the QR code\n    /// using the data stored in the QRCode and the given color value to\n    /// colorize the QR code.\n    pub fn colorize(\u0026self, color: Rgba\u003cu8\u003e) -\u003e RgbaImage {\n        let qrcode = self.to_qrcode();\n        let mut img: RgbaImage = ImageBuffer::new(qrcode.width() as u32, qrcode.width() as u32);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let c = if qrcode[(x as usize, y as usize)] == qrcode::Color::Dark {\n                color\n            } else {\n                Rgba([255, 255, 255, 255])\n            };\n            *pixel = c;\n        }\n        img\n    }\n\n    /// The `resize` method creates a new PNG image of the QR code using\n    /// the data stored in the QRCode and the given width and height\n    /// values to resize the QR code.\n    pub fn resize(\u0026self, width: u32, height: u32) -\u003e RgbaImage {\n        let qrcode = self.to_qrcode();\n        let mut img: RgbaImage = ImageBuffer::new(width, height);\n        for y in 0..height {\n            for x in 0..width {\n                let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n                let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n                let c = match qrcode[(x_index as usize, y_index as usize)] {\n                    qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                    qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n                };\n                img.put_pixel(x, y, c);\n            }\n        }\n        img\n    }\n    /// The `add_image_watermark` method adds a watermark to the given image.\n    pub fn add_image_watermark(img: \u0026mut RgbaImage, watermark: \u0026RgbaImage) {\n        let (width, height) = img.dimensions();\n        let (watermark_width, watermark_height) = watermark.dimensions();\n\n        // position the watermark in the bottom right corner\n        let x = width - watermark_width;\n        let y = height - watermark_height;\n\n        // draw the watermark on the QR code image\n        for (dx, dy, watermark_pixel) in watermark.enumerate_pixels() {\n            let x = x + dx;\n            let y = y + dy;\n            let qr_pixel = img.get_pixel(x, y);\n\n            let alpha = (watermark_pixel[3] as f32) / 255.0;\n            let new_r = (1.0 - alpha) * (qr_pixel[0] as f32) + alpha * (watermark_pixel[0] as f32);\n            let new_g = (1.0 - alpha) * (qr_pixel[1] as f32) + alpha * (watermark_pixel[1] as f32);\n            let new_b = (1.0 - alpha) * (qr_pixel[2] as f32) + alpha * (watermark_pixel[2] as f32);\n            let new_a = (qr_pixel[3] as f32) + alpha * (255.0 - qr_pixel[3] as f32);\n\n            let new_pixel = [new_r as u8, new_g as u8, new_b as u8, new_a as u8];\n            img.put_pixel(x, y, image::Rgba(new_pixel));\n        }\n    }\n}\n\n#[macro_export]\n/// The `add_emoji_watermark` macro creates a new instance of the QRCode struct\n/// with the given data.\nmacro_rules! add_image_watermark {\n    ($img:expr, $watermark:expr) =\u003e {\n        QRCode::add_image_watermark($img, $watermark)\n    };\n}\n\n#[macro_export]\n/// The `qr_code` macro creates a new instance of the QRCode struct\n/// with the given data.\nmacro_rules! qr_code {\n    ($data:expr) =\u003e {\n        QRCode::new($data)\n    };\n}\n\n#[macro_export]\n/// Define a macro named `qr_code_to`\nmacro_rules! qr_code_to {\n    // This macro takes two expressions: `$data` and `$format`\n    ($data:expr, $format:expr, $width:expr) =\u003e {\n        // Match the value of `$format`\n        match $format {\n            // If `$format` is equal to \"png\", generate a PNG format QR code using `QRCode::from_bytes`\n            \"png\" =\u003e QRCode::from_bytes($data).to_png($width),\n            // If `$format` is equal to \"jpg\", generate a JPG format QR code using `QRCode::from_bytes`\n            \"jpg\" =\u003e QRCode::from_bytes($data).to_jpg($width),\n            // If `$format` is equal to \"gif\", generate a \"gif\" format QR code using `QRCode::from_bytes`\n            \"gif\" =\u003e QRCode::from_bytes($data).to_gif($width),\n            // For any other value, panic with the message \"Invalid format\"\n            _ =\u003e panic!(\"Invalid format\"),\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","tests","qr.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate image;\n    use image::{Rgba, RgbaImage};\n\n    extern crate qrc;\n    use qrc::{add_image_watermark, qr_code, qr_code_to, QRCode};\n\n    const URL: \u0026str = \"https://minifunctions.com/\"; // Define a constant for the URL to be encoded\n\n    #[test]\n    fn test_new() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::new(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n\n    #[test]\n    fn test_from_string() {\n        let data = \"abc\".to_string();\n        let qrcode = QRCode::from_string(data.clone());\n        assert_eq!(qrcode.data, data.into_bytes());\n    }\n\n    #[test]\n    fn test_from_bytes() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n\n    #[test]\n    fn test_to_qrcode() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n\n    #[test]\n    fn test_to_png() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(\"Hello, world!\".to_string());\n        let png = qrcode.to_png(21);\n        assert_eq!(png.dimensions(), (21, 21));\n\n        let png_data = png.into_raw();\n        assert_eq!(png_data.len(), 1764);\n    }\n    #[test]\n    fn test_to_svg() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let qrcode_svg = qrcode.to_svg(512);\n        assert_eq!(qrcode_svg.len(), 6918);\n    }\n    #[test]\n    fn test_to_gif() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let qrcode_gif = qrcode.to_gif(512);\n        assert_eq!(qrcode_gif.len(), 1048576);\n    }\n    #[test]\n    fn test_to_jpg() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let qrcode_jpg = qrcode.to_jpg(512);\n        assert_eq!(qrcode_jpg.len(), 1048576);\n    }\n    #[test]\n    fn test_add_image_watermark() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let mut qrcode_img = qrcode.to_png(512);\n        let watermark_img = image::open(\"bubba.ico\").unwrap().into_rgba8();\n        add_image_watermark!(\u0026mut qrcode_img, \u0026watermark_img);\n        assert_eq!(qrcode_img.dimensions(), (512, 512));\n    }\n    #[test]\n    fn test_colorize() {\n        // Create a new QR code with some data.\n        let qrcode = QRCode::new(vec![0, 1, 2, 3]);\n\n        // Colorize the QR code with a red color.\n        let red_qrcode = qrcode.colorize(Rgba([255, 0, 0, 255]));\n\n        // Convert the QR code to a PNG image and assert that all of the dark cells are red.\n        let image: RgbaImage = red_qrcode;\n        for (x, y, pixel) in image.enumerate_pixels() {\n            let expected_color =\n                if qrcode.to_qrcode()[(x as usize, y as usize)] == qrcode::Color::Dark {\n                    Rgba([255, 0, 0, 255])\n                } else {\n                    Rgba([255, 255, 255, 255])\n                };\n            assert_eq!(*pixel, expected_color);\n        }\n    }\n    #[test]\n    fn test_resize() {\n        // Create a new QR code with some data.\n        let qrcode = QRCode::new(vec![0, 1, 2, 3]);\n\n        // Resize the QR code to 42x42 pixels.\n        let resized_qrcode = qrcode.resize(42, 42);\n\n        // Convert the QR code to a PNG image and assert that the dimensions are correct.\n        let image: RgbaImage = resized_qrcode;\n        assert_eq!(image.dimensions(), (42, 42));\n    }\n\n    #[test]\n    fn test_qr_code() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = qr_code!(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n    #[test]\n    fn test_qr_code_from_png() {\n        let data = vec![0x61, 0x62, 0x63];\n        let result = qr_code_to!(data.clone(), \"png\", 512);\n        let expected = QRCode::from_bytes(data).to_png(512);\n        assert_eq!(result, expected);\n    }\n    #[test]\n    #[should_panic(expected = \"Invalid format\")]\n    fn test_qr_code_from_invalid_format() {\n        let data = vec![0u8, 1, 2, 3];\n        let _result = qr_code_to!(data, \"jpeg\", 512);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","benches","rlg.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nextern crate rlg;\nuse rlg::*;\n\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| {\n        b.iter(|| {\n            let log = Log::new(\n                \"123\",\n                \"2023-01-23 14:04:09.881393 +00:00:00\",\n                \u0026LogLevel::INFO,\n                \"test\",\n                \"test log message\",\n                \u0026LogFormat::CLF,\n            );\n            black_box(log);\n        })\n    });\n}\ncriterion_group!(benches, new_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","examples","rlg.rs"],"content":"extern crate dtt;\nextern crate rlg;\n\nuse self::dtt::DateTime;\nuse self::rlg::{Log, LogFormat, LogLevel};\n\nfn main() {\n    let date = DateTime::new();\n    let iso = date.iso_8601;\n    let log_formats = vec![\n        LogFormat::CLF,\n        LogFormat::JSON,\n        LogFormat::CEF,\n        LogFormat::ELF,\n        LogFormat::GELF,\n        LogFormat::W3C,\n    ];\n\n    for format in log_formats {\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026iso,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026format,\n        );\n        println!(\"ðŸ¦€ Log::new():            âœ… {log}\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library that implements application-level logging with a simple, readable output format\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-rlg.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Rust Logs (RLG) is a library that implements application-level\n//! logging in a simple, readable output format. The library provides\n//! logging APIs and various helper macros that simplify many common\n//! logging tasks.\n\n//!\n//! ## Features\n//!\n//!- Supports many log levels: `ALL`, `DEBUG`, `DISABLED`, `ERROR`,\n//!  `FATAL`, `INFO`, `NONE`, `TRACE`, `VERBOSE` and `WARNING`,\n//!- Provides structured log formats that are easy to parse and filter,\n//!- Compatible with multiple output formats including:\n//!  - Common Event Format (CEF),\n//!  - Extended Log Format (ELF),\n//!  - Graylog Extended Log Format (GELF),\n//!  - JavaScript Object Notation (JSON),\n//!  - NCSA Common Log Format (CLF),\n//!  - W3C Extended Log File Format (W3C),\n//!  - and many more\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-rlg.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-rlg.svg\",\n    html_root_url = \"https://docs.rs/rlg\"\n)]\n#![crate_name = \"rlg\"]\n#![crate_type = \"lib\"]\n\nuse std::{\n    fmt::{self, Write},\n    io,\n};\n\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\n/// An enumeration of the different log formats that can be used.\npub enum LogFormat {\n    /// The log format is set to CLF.\n    CLF,\n    /// The log format is set to JSON.\n    JSON,\n    /// The log format is set to CEF.\n    CEF,\n    /// The log format is set to ELF.\n    ELF,\n    /// The log format is set to W3C.\n    W3C,\n    /// The log format is set to GELF.\n    GELF,\n}\n\nimpl fmt::Display for LogFormat {\n    /// Implements [`LogFormat`] to display the log format as a string.\n    /// It allows the LogFormat enumeration to be used with the write!\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            LogFormat::CEF =\u003e write!(f, \"CEF\"),\n            LogFormat::CLF =\u003e write!(f, \"CLF\"),\n            LogFormat::ELF =\u003e write!(f, \"ELF\"),\n            LogFormat::GELF =\u003e write!(f, \"GELF\"),\n            LogFormat::JSON =\u003e write!(f, \"JSON\"),\n            LogFormat::W3C =\u003e write!(f, \"W3C\"),\n        }\n    }\n}\n\n/// Implements [`Log`] to log a message to the console with a simple,\n/// readable output format.\n///\n/// # Arguments\n///\n/// * `session_id` - A string slice that holds a session ID. The session\n///    ID is a unique identifier for the current session. A random GUID\n///    (Globally Unique Identifier) is generated by default.\n/// * `time` - A string slice that holds the timestamp in ISO 8601\n///    format.\n/// * `level` - A string slice that holds the level (INFO, WARN, ERROR,\n///     etc.).\n/// * `component` - A string slice that holds the component name.\n/// * `description` - A string slice that holds the description of the\n///    log message.\n///\n\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\n/// An enumeration of the different levels that a log message can have.\n/// Each variant of the enumeration represents a different level of\n/// importance.\n///\n/// # Arguments\n///\n/// * `ALL` - The log level is set to all.\n/// * `DEBUG` - The log level is set to debug.\n/// * `DISABLED` - The log level is set to disabled.\n/// * `ERROR` - The log level is set to error.\n/// * `FATAL` - The log level is set to fatal.\n/// * `INFO` - The log level is set to info.\n/// * `NONE` - The log level is set to none.\n/// * `TRACE` - The log level is set to trace.\n/// * `VERBOSE` - The log level is set to verbose.\n/// * `WARNING` - The log level is set to warning.\n///\npub enum LogLevel {\n    /// The log level is set to all.\n    ALL,\n    /// The log level is set to debug.\n    DEBUG,\n    /// The log level is set to disabled.\n    DISABLED,\n    /// The log level is set to error.\n    ERROR,\n    /// The log level is set to fatal.\n    FATAL,\n    /// The log level is set to info.\n    INFO,\n    /// The log level is set to none.\n    NONE,\n    /// The log level is set to trace.\n    TRACE,\n    /// The log level is set to verbose.\n    VERBOSE,\n    /// The log level is set to warning.\n    WARNING,\n}\n\n/// Implements [`LogLevel`] to display the log level as a string. It\n/// allows the LogLevel enumeration to be used with the write! and\n/// print! macros. It provides a human-readable string representation of\n/// the variant, that will be used when displaying the log message.\nimpl fmt::Display for LogLevel {\n    /// Implements [`LogLevel`] to display the log level as a string.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            LogLevel::ALL =\u003e write!(f, \"ALL\"),\n            LogLevel::DEBUG =\u003e write!(f, \"DEBUG\"),\n            LogLevel::DISABLED =\u003e write!(f, \"DISABLED\"),\n            LogLevel::ERROR =\u003e write!(f, \"ERROR\"),\n            LogLevel::FATAL =\u003e write!(f, \"FATAL\"),\n            LogLevel::INFO =\u003e write!(f, \"INFO\"),\n            LogLevel::NONE =\u003e write!(f, \"NONE\"),\n            LogLevel::TRACE =\u003e write!(f, \"TRACE\"),\n            LogLevel::VERBOSE =\u003e write!(f, \"VERBOSE\"),\n            LogLevel::WARNING =\u003e write!(f, \"WARNING\"),\n        }\n    }\n}\n\n#[non_exhaustive]\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\n/// The `Log` struct provides an easy way to log a message to the\n/// console. It contains a set of defined fields to create a simple,\n/// log message with a readable output format.\n///\n/// # Arguments\n///\n/// * `session_id` - A string slice that holds a session ID. The session\n///    ID is a unique identifier for the current session. A random GUID\n///    (Globally Unique Identifier) is generated by default.\n/// * `time` - A string slice that holds the timestamp in ISO 8601\n///    format.\n/// * `level` - A string slice that holds the level (INFO, WARN, ERROR,\n///     etc.).\n/// * `component` - A string slice that holds the component name.\n/// * `description` - A string slice that holds the description of the\n///    log message.\n///\npub struct Log {\n    /// A string that holds a session ID. The session ID is a unique\n    /// identifier for the current session. A random GUID (Globally\n    /// Unique Identifier) is generated by default.\n    pub session_id: String,\n    /// A string that holds the timestamp in ISO 8601 format.\n    pub time: String,\n    /// A string that holds the level (INFO, WARN, ERROR, etc.).\n    pub level: LogLevel,\n    /// A string that holds the component name.\n    pub component: String,\n    /// A string that holds the description of the log message.\n    pub description: String,\n    /// A string that holds the log format.\n    pub format: LogFormat,\n}\n\n/// This implementation allows the Log struct to be created with default\n/// values. It creates a new instance of the Log struct with empty\n/// strings for the session_id, time, component and description fields,\n///  and LogLevel::INFO for level field. This is useful when creating a\n/// new instance of the Log struct. It allows the struct to be created\n/// with default values, and then the fields can be set to the desired\n/// values.\nimpl Default for Log {\n    /// This implementation allows the Log struct to be created with\n    /// default values.\n    fn default() -\u003e Log {\n        Log {\n            session_id: String::default(),\n            time: String::default(),\n            level: LogLevel::INFO,\n            component: String::default(),\n            description: String::default(),\n            format: LogFormat::CLF,\n        }\n    }\n}\n\nimpl Log {\n    /// Logs a message to the console using a pre-allocated buffer to\n    /// reduce memory allocation and flush the output buffer to ensure\n    /// that the message is written immediately.\n    ///\n    /// # Errors\n    ///\n    /// This function will panic if an error occurs when writing to the\n    /// pre-allocated buffer or flushing the output buffer.\n    ///\n    pub fn log(\u0026self) {\n        let mut log_message = String::with_capacity(256);\n        match self.format {\n        LogFormat::CLF =\u003e write!(\n        log_message,\n        \"SessionID={} Timestamp={} Description={} Level={} Component={} Format={}\",\n        self.session_id, self.description, self.time, self.level, self.component, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::JSON =\u003e write!(\n        log_message,\n        \"{{\\\"SessionID\\\":\\\"{}\\\",\\\"Timestamp\\\":\\\"{}\\\",\\\"Level\\\":\\\"{}\\\",\\\"Component\\\":\\\"{}\\\",\\\"Description\\\":\\\"{}\\\"}} Format={}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::CEF =\u003e write!(\n        log_message,\n                \"CEF:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::ELF =\u003e write!(\n        log_message,\n        \"ELF:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::W3C =\u003e write!(\n        log_message,\n        \"W3C:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::GELF =\u003e write!(\n        log_message,\n        \"GELF:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        }\n        println!(\"{log_message}\");\n        io::Write::flush(\u0026mut io::stdout()).expect(\"Unable to flush stdout\");\n    }\n\n    /// Creates a new instance of the `Log` struct with the provided\n    /// parameters.\n    ///\n    /// # Parameters\n    /// * `component`: A string slice representing the component.\n    /// * `description`: A string slice representing the log description.\n    /// * `format`: A string slice representing the log format.\n    /// * `level`: A string slice representing the log level.\n    /// * `session_id`: A string slice representing the session ID.\n    /// * `time`: A string slice representing the timestamp.\n    ///\n    /// # Returns\n    ///\n    /// A new instance of the `Log` struct with the provided parameters.\n    #[must_use]\n    pub fn new(\n        session_id: \u0026str,\n        time: \u0026str,\n        level: \u0026LogLevel,\n        component: \u0026str,\n        description: \u0026str,\n        format: \u0026LogFormat,\n    ) -\u003e Self {\n        Self {\n            session_id: session_id.to_string(),\n            time: time.to_string(),\n            level: level.clone(),\n            component: component.to_string(),\n            description: description.to_string(),\n            format: format.clone(),\n        }\n    }\n}\n\nimpl fmt::Display for Log {\n    /// Formats the value using the given formatter.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self.format {\n            LogFormat::CLF =\u003e {\n                write!(\n                    f,\n                    \"SessionID={} Timestamp={} Description={} Level={} Component={}\",\n                    self.session_id, self.time, self.description, self.level, self.component\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::JSON =\u003e {\n                write!(\n                f,\n                \"{{\\\"SessionID\\\":\\\"{}\\\",\\\"Timestamp\\\":\\\"{}\\\",\\\"Level\\\":\\\"{}\\\",\\\"Component\\\":\\\"{}\\\",\\\"Description\\\":\\\"{}\\\",\\\"Format\\\":\\\"JSON\\\"}}\",\n                self.session_id, self.time, self.level, self.component, self.description)\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::CEF =\u003e {\n                write!(\n                    f,\n                    \"CEF:0|{}|{}|{}|{}|{}|CEF\",\n                    self.session_id, self.time, self.level, self.component, self.description\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::ELF =\u003e {\n                write!(\n                    f,\n                    \"ELF:0|{}|{}|{}|{}|{}|ELF\",\n                    self.session_id, self.time, self.level, self.component, self.description\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::W3C =\u003e {\n                write!(\n                    f,\n                    \"W3C:0|{}|{}|{}|{}|{}|W3C\",\n                    self.session_id, self.time, self.level, self.component, self.description\n                )\n                // self.session_id, self.time, self.level, self.component, self.description)\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::GELF =\u003e {\n                write!(\n                    f,\n                    r#\"{{\n                            \"version\": \"1.1\",\n                            \"host\": \"{}\",\n                            \"short_message\": \"{}\",\n                            \"level\": \"{:?}\",\n                            \"timestamp\": \"{}\",\n                            \"_component\": \"{}\",\n                            \"_session_id\": \"{}\"\n                        }}\"#,\n                    self.component,\n                    self.description,\n                    self.level,\n                    self.time,\n                    self.component,\n                    self.session_id\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","tests","rlg.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n\n    extern crate dtt;\n    extern crate rlg;\n\n    use self::dtt::DateTime;\n    use self::rlg::LogLevel::ERROR;\n    use self::rlg::{Log, LogFormat, LogLevel};\n    use rlg::LogFormat::CLF;\n\n    #[test]\n    fn test_log_common_format() {\n        let log = Log::new(\n            \"session_id_123\",\n            \"2022-01-01T00:00:00Z\",\n            \u0026ERROR,\n            \"component_a\",\n            \"description_a\",\n            \u0026CLF,\n        );\n        let expected_output = \"SessionID=session_id_123 Timestamp=2022-01-01T00:00:00Z Description=description_a Level=ERROR Component=component_a\";\n        assert_eq!(log.to_string(), expected_output);\n    }\n\n    #[test]\n    fn test_log_error() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_warn() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_debug() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_trace() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_info() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_level_display() {\n        let log_level = LogLevel::ERROR;\n        assert_eq!(log_level.to_string(), \"ERROR\");\n\n        let log_level = LogLevel::WARNING;\n        assert_eq!(log_level.to_string(), \"WARNING\");\n    }\n\n    #[test]\n    fn test_log_display() {\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \"2023-01-23 14:03:00.000+0000\",\n            \u0026LogLevel::ERROR,\n            \"Test\",\n            \"This is a test log message\",\n            \u0026LogFormat::CLF,\n        );\n        assert_eq!(\n        log.to_string(),\n        \"SessionID=12345678-1234-1234-1234-1234567890ab Timestamp=2023-01-23 14:03:00.000+0000 Description=This is a test log message Level=ERROR Component=Test\");\n    }\n\n    #[test]\n    fn test_log_default() {\n        let log = Log::default();\n        assert_eq!(log.session_id, \"\");\n        assert_eq!(log.time, \"\");\n        assert_eq!(log.level, LogLevel::INFO);\n        assert_eq!(log.component, \"\");\n        assert_eq!(log.description, \"\");\n    }\n\n    #[test]\n    fn test_log_common() {\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \"2023-01-23 14:03:00.000+0000\",\n            \u0026LogLevel::ERROR,\n            \"Test\",\n            \"This is a test log message\",\n            \u0026LogFormat::CLF,\n        );\n        let log_string = format!(\"{log}\");\n        println!(\"{log_string}\");\n        assert_eq!(log_string, \"SessionID=12345678-1234-1234-1234-1234567890ab Timestamp=2023-01-23 14:03:00.000+0000 Description=This is a test log message Level=ERROR Component=Test\");\n    }\n\n    #[test]\n    fn test_log_level_all_display() {\n        let log_level = LogLevel::ALL;\n        assert_eq!(log_level.to_string(), \"ALL\");\n    }\n\n    #[test]\n    fn test_log_level_debug_display() {\n        let log_level = LogLevel::DEBUG;\n        assert_eq!(log_level.to_string(), \"DEBUG\");\n    }\n\n    #[test]\n    fn test_log_level_disabled_display() {\n        let log_level = LogLevel::DISABLED;\n        assert_eq!(log_level.to_string(), \"DISABLED\");\n    }\n\n    #[test]\n    fn test_log_level_error_display() {\n        let log_level = LogLevel::ERROR;\n        assert_eq!(log_level.to_string(), \"ERROR\");\n    }\n\n    #[test]\n    fn test_log_level_fatal_display() {\n        let log_level = LogLevel::FATAL;\n        assert_eq!(log_level.to_string(), \"FATAL\");\n    }\n\n    #[test]\n    fn test_log_level_info_display() {\n        let log_level = LogLevel::INFO;\n        assert_eq!(log_level.to_string(), \"INFO\");\n    }\n\n    #[test]\n    fn test_log_level_none_display() {\n        let log_level = LogLevel::NONE;\n        assert_eq!(log_level.to_string(), \"NONE\");\n    }\n\n    #[test]\n    fn test_log_level_trace_display() {\n        let log_level = LogLevel::TRACE;\n        assert_eq!(log_level.to_string(), \"TRACE\");\n    }\n\n    #[test]\n    fn test_log_level_verbose_display() {\n        let log_level = LogLevel::VERBOSE;\n        assert_eq!(log_level.to_string(), \"VERBOSE\");\n    }\n\n    #[test]\n    fn test_log_level_warning_display() {\n        let log_level = LogLevel::WARNING;\n        assert_eq!(log_level.to_string(), \"WARNING\");\n    }\n    #[test]\n    fn test_common_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::CLF,\n        );\n        let expected_output = \"SessionID=123 Timestamp=2023-01-23 14:04:09.881393 +00:00:00 Description=test log message Level=INFO Component=test\";\n        assert_eq!(log.to_string(), expected_output);\n    }\n\n    #[test]\n    fn test_json_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::JSON,\n        );\n        let expected_output = \"{\\\"SessionID\\\":\\\"123\\\",\\\"Timestamp\\\":\\\"2023-01-23 14:04:09.881393 +00:00:00\\\",\\\"Level\\\":\\\"INFO\\\",\\\"Component\\\":\\\"test\\\",\\\"Description\\\":\\\"test log message\\\",\\\"Format\\\":\\\"JSON\\\"}\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n\n    #[test]\n    fn test_cef_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::CEF,\n        );\n        let expected_output =\n            \"CEF:0|123|2023-01-23 14:04:09.881393 +00:00:00|INFO|test|test log message|CEF\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_elf_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::ELF,\n        );\n        let expected_output =\n            \"ELF:0|123|2023-01-23 14:04:09.881393 +00:00:00|INFO|test|test log message|ELF\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_w3c_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::W3C,\n        );\n        let expected_output =\n            \"W3C:0|123|2023-01-23 14:04:09.881393 +00:00:00|INFO|test|test log message|W3C\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_gelf_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::GELF,\n        );\n        let expected_output =\n            \"{\\n                            \\\"version\\\": \\\"1.1\\\",\\n                            \\\"host\\\": \\\"test\\\",\\n                            \\\"short_message\\\": \\\"test log message\\\",\\n                            \\\"level\\\": \\\"INFO\\\",\\n                            \\\"timestamp\\\": \\\"2023-01-23 14:04:09.881393 +00:00:00\\\",\\n                            \\\"_component\\\": \\\"test\\\",\\n                            \\\"_session_id\\\": \\\"123\\\"\\n                        }\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_log_format_display() {\n        for (log_format, expected_output) in vec![\n            (LogFormat::CLF, \"CLF\"),\n            (LogFormat::JSON, \"JSON\"),\n            (LogFormat::CEF, \"CEF\"),\n            (LogFormat::ELF, \"ELF\"),\n            (LogFormat::W3C, \"W3C\"),\n            (LogFormat::GELF, \"GELF\"),\n        ] {\n            assert_eq!(log_format.to_string(), expected_output);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! A Rust library of highly performant utility and wrapper functions\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-mini-functions.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Mini-Functions is a modern Rust library that prioritizes performance\n//! , security, and modularity. It provides a low-overhead access to\n//! functions for common programming tasks.\n//!\n//! ## Features\n//!\n//! - **[Claims](../claims/index.html)** - Provides access to the claims\n//! of a JSON Web Token (JWT).\n//! - **[Common](../common/index.html)** - Provides access to common\n//! functions and constants.\n//! - **[Date](../date/index.html)** - Provides access to the current\n//! date and time.\n//! - **[Errors](../errors/index.html)** - Provides access to error\n//! handling functions.\n//! - **[Hash](../hash/index.html)** - Provides access to hash\n//! functions.\n//! - **[Jot](../cjwt/index.html)** - Provides access to JSON Web Token\n//! (JWT) functions.\n//! - **[rlg](../rlg/index.html)** - Provides access to logging\n//! functions.\n//! - **[MD5](../mdg/index.html)** - Provides access to MD5 functions.\n//! - **[Password](../password/index.html)** - Provides access to\n//! password functions.\n//! - **[QR](../qr/index.html)** - Provides access to QR code functions.\n//! - **[Random](../vrd/index.html)** - Provides access to random\n//! number functions.\n//! - And so much more.\n//!\n//! These components provide a comprehensive set of functionality and\n//! offer powerful new capabilities to help you build better\n//! applications and services in the Rust programming language.\n//!\n//! [**Learn more**](https://minifunctions.com) [â¯](https://minifunctions.com)\n//!\n//!\n//! ## Installation\n//!\n//! Mini Functions is available on both\n//! [Crates.io](https://crates.io/crates/mini_functions) and\n//! [Lib.rs](https://lib.rs/crates/mini_functions).\n//!\n//! Learn more about Mini Functions at \u003chttps://minifunctions.com\u003e.\n//!\n//! Add the following to your `Cargo.toml` file:\n//! ```toml\n//! [dependencies]\n//! mini_functions = \"0.0.8\"\n//! ```\n//! Then, add the following to your crate root:\n//! ```rust\n//! extern crate mini_functions;\n//!\n//! use mini_functions::mini_functions::*;\n//!\n//! ```\n//!\n//!\n#![warn(missing_docs)]\n#![forbid(unsafe_code)]\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mini-functions.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mini-functions.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"mini_functions\"]\n#![crate_type = \"dylib\"]\n#![crate_type = \"lib\"]\n#![crate_type = \"rlib\"]\n#![crate_type = \"staticlib\"]\n\n/// Mini-Functions module that provides a variety of features for\n/// building apps, including several major crates that you can use\n/// individually or together to construct the core infrastructure of\n/// your Rust applications.\npub mod mini_functions {\n    /// Provides access to common functions and constants.\n    pub use cmn::*;\n\n    /// Provides access to the claims of a JSON Web Token (JWT).\n    pub use claims::*;\n\n    /// Provides access to Date functions.\n    pub use dtt::*;\n\n    /// Provides access to Error handling functions.\n    pub use idk::*;\n\n    /// Provides access to Hash functions.\n    pub use hsh::*;\n\n    /// Provides access to JSON Web Token (JWT) functions.\n    pub use cjwt::*;\n\n    /// Provides access to Log functions.\n    pub use rlg::*;\n\n    /// Provides access to MD5 functions.\n    pub use mdg::*;\n\n    /// Provides access to QR code functions.\n    pub use qrc::*;\n\n    /// Provides access to Random numbers functions.\n    pub use vrd::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","benches","vrd.rs"],"content":"extern crate criterion;\nextern crate vrd;\nuse self::vrd::Random;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn benchmark_random(c: \u0026mut Criterion) {\n    // Benchmark the random bool function\n    c.bench_function(\"Random bool\", |b| {\n        b.iter(|| Random::bool(\u0026mut Random::new(), black_box(0.5)))\n    });\n\n    // Benchmark the random bytes function\n    c.bench_function(\"Random bytes\", |b| {\n        b.iter(|| Random::bytes(\u0026mut Random::new(), black_box(1000)))\n    });\n\n    // Benchmark the random char function\n    c.bench_function(\"Random char\", |b| {\n        b.iter(|| Random::char(\u0026mut Random::new()))\n    });\n\n    // Benchmark the random choose function\n    c.bench_function(\"Random choose\", |b| {\n        b.iter(|| {\n            let mut rng = Random::new();\n            let values = vec![1, 2, 3, 4, 5];\n            Random::choose(\u0026mut rng, \u0026values);\n        })\n    });\n\n    // Benchmark the random float function\n    c.bench_function(\"Random float\", |b| {\n        b.iter(|| Random::float(\u0026mut Random::new()))\n    });\n\n    // Benchmark the random int function\n    c.bench_function(\"Random int\", |b| {\n        b.iter(|| Random::int(\u0026mut Random::new(), black_box(0), black_box(100)))\n    });\n\n    // Benchmark the random new function\n    c.bench_function(\"Random new\", |b| b.iter(|| Random::new));\n\n    // Benchmark the random pseudo function\n    c.bench_function(\"Random pseudo\", |b| {\n        let mut rng = Random::new();\n        b.iter(|| rng.pseudo())\n    });\n\n    // Benchmark the random function\n    c.bench_function(\"Random random\", |b| {\n        let mut rng = Random::new();\n        b.iter(|| rng.rand())\n    });\n\n    // Benchmark the random range function\n    c.bench_function(\"Random range\", |b| {\n        let mut rng = Random::new();\n        b.iter(|| rng.range(black_box(0), black_box(100)))\n    });\n}\n\ncriterion_group!(benches, benchmark_random);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","examples","vrd.rs"],"content":"extern crate vrd;\nuse self::vrd::Random;\n\nfn main() {\n    // Create a new random boolean\n    let bool: bool = Random::bool(\u0026mut Random::new(), 0.5);\n    println!(\"ðŸ¦€ Random::bool():        âœ… {bool}\");\n\n    // Create a new random number generator\n    let mut rng = Random::new();\n    println!(\"ðŸ¦€ Random::new():         âœ… {rng}\");\n\n    let default = Random::default();\n    println!(\"ðŸ¦€ Random::default():     âœ… {default}\");\n\n    let random = rng.rand();\n    println!(\"ðŸ¦€ Random::random():      âœ… {random}\");\n\n    let pseudo = rng.pseudo();\n    println!(\"ðŸ¦€ Random::pseudo():      âœ… {pseudo}\");\n\n    let bytes = Random::bytes(\u0026mut rng, 1000);\n    println!(\"ðŸ¦€ Random::bytes():       âœ… {bytes:?}\");\n\n    let float = rng.rand() as f32 / 0x7FFF as f32;\n    println!(\"ðŸ¦€ Random::float():       âœ… {float}\");\n\n    let int = rng.rand() as usize;\n    println!(\"ðŸ¦€ Random::int():         âœ… {int}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for generating random and pseudo-random numbers based on the Mersenne Twister algorithm\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-vrd.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/vrd.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/vrd)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/vrd)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/vrd)\n//! [![License](https://img.shields.io/crates/l/vrd.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! This crate provides a random number generator based on the Mersenne\n//! Twister algorithm. The Mersenne Twister algorithm is a pseudorandom\n//! number generator (PRNG) developed by Makoto Matsumoto and Takuji\n//! Nishimura in 1997. It is based on a linear feedback shift register\n//! (LFSR) and is designed to have a period of 2^19937-1. It is one of\n//! the most widely used PRNGs in scientific computing.\n//!\n//! ## Features\n//!\n//! - Pseudorandom number generation: The library uses the Mersenne\n//!   Twister algorithm (MT19937) to generate pseudorandom integers\n//!   uniformly distributed in 0 to (2^32 - 1) using an array of\n//!   unsigned 32-bit integers and an index.\n//! - Random number types: The library provides several methods to\n//!   generate different types of random numbers including bool, bytes,\n//!   char, float, and int.\n//! - Range of values: The methods for generating random numbers allow\n//!   the user to specify the range of values for the output.\n//! - Random element selection: The library provides a method to choose\n//!   a random element from a given slice of values.\n//! - Initialization: The library provides a new() method to create a\n//!   new instance of the random number generator.\n//! - Optimization: The library is optimized for performance with the\n//!   number of elements in the array set to 624 and the number of\n//!   elements to skip set to 397.\n//! - Constant values: The library uses several constant values in the\n//!   Mersenne Twister algorithm including MATRIX_A, UPPER_MASK,\n//!   LOWER_MASK, TEMPERING_MASK_B, and TEMPERING_MASK_C.\n//!\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-vrd.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-vrd.svg\",\n    html_root_url = \"https://docs.rs/vrd\"\n)]\n#![crate_name = \"vrd\"]\n#![crate_type = \"lib\"]\n\nextern crate rand;\nuse rand::{thread_rng, Rng};\n\n/// N is the number of elements in the array used for the Mersenne\n/// Twister algorithm.Its value is set to 624 for optimal performance.\nconst N: usize = 624;\n\n/// M is the number of elements to skip in the array used for the\n/// Mersenne Twister algorithm. Its value is set to 397 for optimal\n/// performance.\nconst M: usize = 397;\n\n/// MATRIX_A is a constant value used in the Mersenne Twister algorithm.\nconst MATRIX_A: u32 = 0x9908b0df;\n\n/// UPPER_MASK is a constant value used in the Mersenne Twister\n/// algorithm.\nconst UPPER_MASK: u32 = 0x80000000;\n\n/// LOWER_MASK is a constant value used in the Mersenne Twister\n/// algorithm.\nconst LOWER_MASK: u32 = 0x7fffffff;\n\n/// TEMPERING_MASK_B is a constant value used in the Mersenne Twister\n/// algorithm.\nconst TEMPERING_MASK_B: u32 = 0x9d2c5680;\n\n/// TEMPERING_MASK_C is a constant value used in the Mersenne Twister\n/// algorithm.\nconst TEMPERING_MASK_C: u32 = 0xefc60000;\n\n#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]\n/// The Random struct is used to generate random numbers using the\n/// Mersenne Twister algorithm. It generates pseudorandom integers\n/// uniformly distributed in 0..(2^32 - 1) starting from any odd seed in\n/// 0..(2^32 - 1).\n///\n/// It contains an array of unsigned 32-bit integers and an index used\n/// to generate random numbers. The array contains 624 elements and the\n/// index is used to generate random numbers from the array.\n///\n/// The index is incremented after each random number is generated.\n/// When the index reaches 624, the array is reinitialized and the index\n/// is reset to 0.\n///\npub struct Random {\n    /// The array of unsigned 32-bit integers used to generate random\n    /// numbers\n    pub mt: [u32; N],\n    /// The current index of the array used in the generation of random\n    /// numbers\n    pub mti: usize,\n}\n\nimpl Random {\n    /// Returns a random bool with a probability that can be set\n    pub fn bool(\u0026mut self, probability: f64) -\u003e bool {\n        thread_rng().gen_bool(probability)\n    }\n\n    /// Returns a vector of random bytes of the given length\n    pub fn bytes(\u0026mut self, len: usize) -\u003e Vec\u003cu8\u003e {\n        let mut res = Vec::with_capacity(len);\n        for _ in 0..len {\n            let byte = self.rand() as u8;\n            res.push(byte);\n        }\n        res\n    }\n\n    /// Returns a random char within the range 'a'..='z'\n    pub fn char(\u0026mut self) -\u003e char {\n        thread_rng().gen_range('a'..='z')\n    }\n\n    /// Returns a random element from a slice of values\n    pub fn choose\u003c'a, T\u003e(\u0026'a mut self, values: \u0026'a [T]) -\u003e Option\u003c\u0026T\u003e {\n        if values.is_empty() {\n            return None;\n        }\n        let mut rng = rand::thread_rng();\n        let index = rng.gen_range(0..values.len());\n        Some(\u0026values[index])\n    }\n\n    /// Returns a random float.\n    pub fn float(\u0026mut self) -\u003e f32 {\n        thread_rng().gen::\u003cf64\u003e() as f32\n    }\n\n    /// Returns a random integer within the given range\n    pub fn int(\u0026mut self, min: i32, max: i32) -\u003e i32 {\n        thread_rng().gen_range(min..=max)\n    }\n    // pub fn int(\u0026mut self, min: i32, max: i32) -\u003e i32 {\n    //     self.range(min, max)\n    // }\n\n    /// Returns new random number generator\n    pub fn new() -\u003e Self {\n        let mut rng = Random {\n            mt: [0; N],\n            mti: N + 1,\n        };\n        let seed = thread_rng().gen();\n        rng.mt[0] = seed;\n        for i in 1..N {\n            rng.mt[i] = 1812433253u32\n                .wrapping_mul(rng.mt[i - 1] ^ (rng.mt[i - 1] \u003e\u003e 30))\n                .wrapping_add(i as u32);\n        }\n        rng.mti = N;\n        rng\n    }\n\n    /// Returns pseudo random number\n    pub fn pseudo(\u0026mut self) -\u003e u32 {\n        let mut res = self.rand();\n        for _ in 0..31 {\n            res ^= self.rand();\n        }\n        res\n    }\n\n    /// Returns a random 32-bit unsigned integer\n    pub fn rand(\u0026mut self) -\u003e u32 {\n        if self.mti \u003e= N {\n            if self.mti == N + 1 {\n                self.seed(5489);\n            }\n            self.twist();\n        }\n\n        let mut y = self.mt[self.mti];\n        self.mti += 1;\n        y ^= y \u003e\u003e 11;\n        y ^= (y \u003c\u003c 7) \u0026 TEMPERING_MASK_B;\n        y ^= (y \u003c\u003c 15) \u0026 TEMPERING_MASK_C;\n        y ^= y \u003e\u003e 18;\n        y\n    }\n\n    /// Returns a random 32-bit unsigned integer within a given range\n    pub fn random_range(\u0026mut self, min: u32, max: u32) -\u003e u32 {\n        min + self.rand() % (max - min)\n    }\n\n    /// Returns a random number within a given range\n    pub fn range(\u0026mut self, min: i32, max: i32) -\u003e i32 {\n        thread_rng().gen_range(min..=max)\n    }\n\n    /// Seeds the random number generator with a given value\n    pub fn seed(\u0026mut self, seed: u32) {\n        self.mt[0] = seed;\n        for i in 1..N {\n            self.mt[i] = match 1812433253u32.checked_mul(self.mt[i - 1] ^ (self.mt[i - 1] \u003e\u003e 30)) {\n                Some(val) =\u003e val + i as u32,\n                None =\u003e return,\n            };\n        }\n        self.mti = N;\n    }\n\n    /// Twists the state of the random number generator\n    pub fn twist(\u0026mut self) {\n        for i in 0..N {\n            let x = (self.mt[i] \u0026 UPPER_MASK) + (self.mt[(i + 1) % N] \u0026 LOWER_MASK);\n            let x_a = x \u003e\u003e 1;\n            if x % 2 != 0 {\n                self.mt[i] = self.mt[(i + M) % N] ^ x_a ^ MATRIX_A;\n            } else {\n                self.mt[i] = self.mt[(i + M) % N] ^ x_a;\n            }\n        }\n        self.mti = 0;\n    }\n}\n\nimpl std::fmt::Display for Random {\n    /// Returns a formatted string\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(f, \"Random {{ mt: {:?}, mti: {:?} }}\", self.mt, self.mti)\n    }\n}\n\nimpl Default for Random {\n    /// Returns a default random number generator\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","tests","vrd.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n\n    extern crate vrd;\n    use self::vrd::Random;\n\n    const N: usize = 624;\n\n    #[test]\n    fn test_bool() {\n        let mut rng = Random::new();\n        let mut count_of_true = 0;\n        for _ in 0..1000 {\n            let b = Random::bool(\u0026mut rng, 0.5);\n            if b {\n                count_of_true += 1;\n            }\n        }\n        assert!((count_of_true as f64 / 1000.0 - 0.5).abs() \u003c= 0.05);\n    }\n    #[test]\n    fn test_bytes() {\n        let mut rng = Random::new();\n        let bytes = Random::bytes(\u0026mut rng, 0);\n        assert_eq!(bytes.len(), 0);\n\n        let bytes = Random::bytes(\u0026mut rng, 10);\n        assert_eq!(bytes.len(), 10);\n\n        let bytes = Random::bytes(\u0026mut rng, 100);\n        assert_eq!(bytes.len(), 100);\n    }\n    #[test]\n    fn test_char() {\n        let mut rng = Random::new();\n        let c = Random::char(\u0026mut rng);\n        assert!(('a'..='z').contains(\u0026c));\n    }\n    #[test]\n    fn test_choose() {\n        let mut rng = Random::new();\n        let values = vec![1, 2, 3, 4, 5];\n        let value = Random::choose(\u0026mut rng, \u0026values);\n        assert!(value.is_some());\n        assert!(value.unwrap() \u003e= \u00261 \u0026\u0026 value.unwrap() \u003c= \u00265);\n        if values.is_empty() {\n            assert!(Random::choose(\u0026mut rng, \u0026values).is_none());\n        }\n    }\n    #[test]\n    fn test_float() {\n        let mut rng = Random::new();\n        let f = Random::float(\u0026mut rng);\n        assert!((0.0..=1.0).contains(\u0026f));\n    }\n    #[test]\n    fn test_int() {\n        let mut rng = Random::new();\n        let i = rng.int(0, 10);\n        assert!((0..=10).contains(\u0026i));\n    }\n    #[test]\n    fn test_pseudo() {\n        let mut rng = Random::new();\n        let p = Random::pseudo(\u0026mut rng);\n        assert!(p \u003c 4294967295);\n    }\n    #[test]\n    fn test_range() {\n        let mut rng = Random::new();\n        let r = Random::range(\u0026mut rng, 0, 10);\n        assert!((0..=10).contains(\u0026r));\n    }\n    #[test]\n    pub fn test_new() {\n        let rng = Random::new();\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt[0] \u003e 0);\n    }\n    #[test]\n    fn test_rand() {\n        let mut rng = Random::new();\n        let r = Random::rand(\u0026mut rng);\n        assert!(r \u003c 4294967295);\n    }\n    #[test]\n    fn test_random_range() {\n        let mut rng = Random::new();\n        let r = Random::random_range(\u0026mut rng, 0, 10);\n        assert!(r \u003c= 10);\n    }\n    #[test]\n    fn test_seed() {\n        let mut rng = Random::new();\n        Random::seed(\u0026mut rng, 0);\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt.iter().any(|\u0026x| x != 0));\n        assert!(rng.mti == N);\n    }\n    #[test]\n    fn test_twist() {\n        let mut rng = Random::new();\n        Random::seed(\u0026mut rng, 0);\n        Random::twist(\u0026mut rng);\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt.iter().any(|\u0026x| x != 0));\n    }\n    #[test]\n    fn test_fmt() {\n        let rng = Random::new();\n        let s = format!(\"{rng}\");\n        assert!(!s.is_empty());\n    }\n    #[test]\n    fn test_default() {\n        let rng = Random::default();\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt[0] \u003e 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","benches","cjwt.rs"],"content":"extern crate criterion;\nuse claims::Claims;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nextern crate cjwt;\nuse self::cjwt::{Algorithm, Header, JWT};\n\nfn bench_to_string_benchmark(c: \u0026mut Criterion) {\n    let jwt = JWT::default();\n\n    c.bench_function(\"to_string\", move |b| b.iter(|| jwt.to_string()));\n}\n\nfn bench_default_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"default\", |b| b.iter(|| JWT::default));\n}\n\nfn bench_decode_benchmark(c: \u0026mut Criterion) {\n    let secret: \u0026[u8; 6] = b\"secret\";\n    let header = Header::default();\n    let claims = Claims::default();\n\n    let token = JWT::encode(header, claims, secret).unwrap();\n    let mut jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token,\n    };\n\n    c.bench_function(\"decode\", move |b| b.iter(|| jwt.decode(secret)));\n}\n\nfn bench_generate_benchmark(c: \u0026mut Criterion) {\n    let secret = b\"secret\";\n    c.bench_function(\"generate\", |b| {\n        b.iter(|| JWT::generate(black_box(secret)).unwrap())\n    });\n}\n\n// fn bench_generate_benchmark(c: \u0026mut Criterion) {\n//     c.bench_function(\"generate\", |b| b.iter(|| JWT::generate()));\n// }\n\nfn bench_get_token_benchmark(c: \u0026mut Criterion) {\n    let jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n    let result = JWT::get_token(jwt);\n    c.bench_function(\"get_token\", move |b| b.iter(|| result.clone()));\n}\n\nfn bench_claims_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"claims\", move |b| b.iter(|| JWT::claims));\n}\n\nfn bench_get_token_length_benchmark(c: \u0026mut Criterion) {\n    let jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n    let result = JWT::get_token_length(jwt);\n    c.bench_function(\"get_token_length\", move |b| b.iter(|| result));\n}\n\nfn bench_get_token_header_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"get_token_header\", move |b| {\n        let jwt = JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: Some(\"example_kid\".to_string()),\n                typ: Some(\"example_type\".to_string()),\n                cty: Some(\"example_cty\".to_string()),\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::get_token_header(jwt);\n        b.iter(|| result.clone())\n    });\n}\n\nfn bench_encode_benchmark(c: \u0026mut Criterion) {\n    let secret = b\"secret\";\n    let header = JWT::default().header;\n    let claims = JWT::default().claims;\n\n    c.bench_function(\"encode\", move |b| {\n        b.iter(|| {\n            JWT::encode(\n                black_box(header.clone()),\n                black_box(claims.clone()),\n                black_box(secret),\n            )\n        })\n    });\n}\nfn bench_validate_benchmark(c: \u0026mut Criterion) {\n    let secret = b\"secret\";\n    let jwt = JWT {\n        header: Header {\n            alg: Some(Algorithm::HS256),\n            kid: Some(\"example_kid\".to_string()),\n            typ: Some(\"example_type\".to_string()),\n            cty: Some(\"example_cty\".to_string()),\n        },\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n\n    c.bench_function(\"validate\", move |b| {\n        b.iter(|| JWT::validate(black_box(\u0026jwt), black_box(secret)));\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_claims_benchmark,\n    bench_decode_benchmark,\n    bench_default_benchmark,\n    bench_encode_benchmark,\n    bench_generate_benchmark,\n    bench_get_token_benchmark,\n    bench_get_token_header_benchmark,\n    bench_get_token_length_benchmark,\n    bench_to_string_benchmark,\n    bench_validate_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","examples","cjwt.rs"],"content":"extern crate cjwt;\nextern crate jwt;\n\nuse self::cjwt::{Algorithm, Header, JWT};\nuse claims::Claims;\n\nfn main() {\n    // Constants for the JWT struct examples.\n    const HD_ALG: Algorithm = Algorithm::HS384;\n    const HD_KID: \u0026str = \"jwt-kid\";\n    const HD_TYP: \u0026str = \"jwt-typ\";\n    const HD_CTY: \u0026str = \"jwt-cty\";\n\n    // Create a Header struct with default method.\n    let hd: Header = Header::default();\n    println!(\"ðŸ¦€ Header::default():             âœ… {hd:?}\\n\");\n\n    // Create a Header struct with default method and replace values.\n    let mut hdrv: Header = Header::default();\n    Header::default().alg = std::mem::replace(\u0026mut hdrv.alg, Some(HD_ALG));\n    Header::default().kid = std::mem::replace(\u0026mut hdrv.kid, Some(HD_KID.to_string()));\n    Header::default().typ = std::mem::replace(\u0026mut hdrv.typ, Some(HD_TYP.to_string()));\n    Header::default().cty = std::mem::replace(\u0026mut hdrv.cty, Some(HD_CTY.to_string()));\n    println!(\"ðŸ¦€ Header::default():             âœ… {hdrv:?}\\n\");\n\n    // Create a JWT struct with default method.\n    let jd: JWT = JWT::default();\n    println!(\"ðŸ¦€ JWT::default():                âœ… {jd:?}\\n\");\n\n    // Create a JWT struct with default method and replace values.\n    let mut jdrv: JWT = JWT::default();\n    JWT::default().header.alg = std::mem::replace(\u0026mut jdrv.header.alg, Some(HD_ALG));\n    JWT::default().header.kid = std::mem::replace(\u0026mut jdrv.header.kid, Some(HD_KID.to_string()));\n    JWT::default().header.typ = std::mem::replace(\u0026mut jdrv.header.typ, Some(HD_TYP.to_string()));\n    JWT::default().header.cty = std::mem::replace(\u0026mut jdrv.header.cty, Some(HD_CTY.to_string()));\n    println!(\"ðŸ¦€ JWT::default():                âœ… {jdrv:?}\\n\");\n\n    // Encode a JWT struct.\n    let encoded: String = JWT::encode(hdrv, claims::Claims::default(), b\"secret\").unwrap();\n    println!(\"ðŸ¦€ encode():                      âœ… {encoded:?}\\n\");\n\n    // Extract the token field from the passed JWT struct and return it.\n    let jwt = JWT {\n        header: Header::default(),\n        claims: Claims::default(),\n        signature: vec![],\n        token: \"example_token\".to_owned(),\n    };\n    let result = JWT::get_token(jwt);\n    println!(\"ðŸ¦€ get_token():                       âœ… {result:?}\\n\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for working with JSON Web Tokens (JWTs) and JSON Web Signatures (JWSs)\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-cjwt.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! JOT is a struct that holds the JWT token and its associated claims. It provides a set of utility functions for working with JSON Web Tokens (JWTs) and JSON Web Signatures (JWSs).\n//!\n//! ## Features\n//!\n//! - [x] JWT token generation\n//! - [x] JWT token validation\n//! - [x] JWT token signing\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cjwt.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cjwt.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"cjwt\"]\n#![crate_type = \"lib\"]\n\nextern crate base64;\nextern crate claims;\nextern crate dtt;\nextern crate hmac;\nextern crate idk;\nextern crate jwt;\nextern crate serde;\nextern crate serde_json;\nextern crate sha2;\n\nuse self::claims::Claims;\nuse idk::jwt::JwtError;\n\nuse base64::{engine::general_purpose, Engine as _};\nuse hmac::{Hmac, Mac};\nuse serde::{Deserialize, Serialize};\nuse sha2::Sha256;\nuse std::{fmt, string::ToString};\n\n/// JWT is a struct that holds the JWT token and its associated claims.\n/// Provides a set of utility functions for working with JSON Web Tokens\n/// (JWTs) and JSON Web Signatures (JWSs).\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct JWT {\n    /// The header of the JWT.\n    pub header: Header,\n    /// The claims associated with the JWT.\n    pub claims: Claims,\n    /// The signature of the JWT.\n    pub signature: Vec\u003cu8\u003e,\n    /// The JWT token.\n    pub token: String,\n}\n/// The Header struct contains the header of the JWT.\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct Header {\n    /// Indicates the algorithm used to sign the JWT. Defaults to HS256.\n    /// See the Algorithm enum for a list of supported algorithms.\n    pub alg: Option\u003cAlgorithm\u003e,\n    /// Indicates the key used to sign the JWT. This is used to select\n    /// a specific key for a given JWT.\n    pub kid: Option\u003cString\u003e,\n    /// Indicates the media type of the JWT. Defaults to JWT.\n    pub typ: Option\u003cString\u003e,\n    /// Indicates the content type.\n    pub cty: Option\u003cString\u003e,\n}\n\n/// The Algorithm enum contains a list of supported algorithms.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Algorithm {\n    /// HMAC using SHA-256 hash algorithm.\n    HS256,\n\n    /// HMAC using SHA-384 hash algorithm.\n    HS384,\n\n    /// HMAC using SHA-512 hash algorithm.\n    HS512,\n\n    /// RSASSA-PKCS1-v1_5 using SHA-256 hash algorithm.\n    RS256,\n\n    /// RSASSA-PKCS1-v1_5 using SHA-384 hash algorithm.\n    RS384,\n\n    /// RSASSA-PKCS1-v1_5 using SHA-512 hash algorithm.\n    RS512,\n\n    /// ECDSA using P-256 and SHA-256.\n    ES256,\n\n    /// ECDSA using P-384 and SHA-384.\n    ES384,\n\n    /// ECDSA using P-521 and SHA-512.\n    ES512,\n}\n\nimpl ToString for Algorithm {\n    /// Converts an Algorithm enum to a string.\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            Algorithm::HS256 =\u003e \"HS256\".to_string(),\n            Algorithm::HS384 =\u003e \"HS384\".to_string(),\n            Algorithm::HS512 =\u003e \"HS512\".to_string(),\n            Algorithm::RS256 =\u003e \"RS256\".to_string(),\n            Algorithm::RS384 =\u003e \"RS384\".to_string(),\n            Algorithm::RS512 =\u003e \"RS512\".to_string(),\n            Algorithm::ES256 =\u003e \"ES256\".to_string(),\n            Algorithm::ES384 =\u003e \"ES384\".to_string(),\n            Algorithm::ES512 =\u003e \"ES512\".to_string(),\n        }\n    }\n}\n\nimpl Default for Algorithm {\n    /// Returns the default algorithm, HS256.\n    fn default() -\u003e Self {\n        Algorithm::HS256\n    }\n}\n\nimpl Default for JWT {\n    /// Returns a default JWT struct.\n    fn default() -\u003e Self {\n        JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: None,\n                typ: None,\n                cty: None,\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: String::default(),\n        }\n    }\n}\n\nimpl Default for Header {\n    /// Returns a default Header struct.\n    fn default() -\u003e Self {\n        Header {\n            alg: Some(Algorithm::HS256),\n            kid: None,\n            typ: Some(\"JWT\".to_string()),\n            cty: None,\n        }\n    }\n}\n\nimpl JWT {\n    /// Claims returns a default Claims struct.\n    pub fn claims() -\u003e Claims {\n        Claims::default()\n    }\n    /// Decodes a JWT token. takes a mutable reference to a JWT struct\n    /// and a reference to a slice of bytes representing a secret, and\n    /// it returns a Result containing a string or an Error variant.\n    /// The function splits the JWT stored in the token field of the\n    /// JWT struct into its header, claims, and signature, decodes the\n    /// header and claims from base64, deserializes the header and\n    /// claims from JSON, and then verifies the JWT's signature using\n    /// the provided secret.\n    ///\n    /// # Arguments\n    ///\n    /// * `secret` - A byte array containing the secret used to sign\n    /// the JWT.\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(String)` - The decoded JWT as a string.\n    /// * `Err(Error)` - An error if the JWT is invalid or if there was\n    /// a problem decoding it.\n    ///\n    pub fn decode(\u0026mut self, secret: \u0026[u8]) -\u003e Result\u003cString, JwtError\u003e {\n        let jwt = \u0026self.token;\n        {\n            // Split the JWT into its header, claims, and signature\n            // let (header_b64, claims_b64_signature_b64) = jwt.split_once('.').unwrap();\n            let (header_b64, claims_b64_signature_b64) = match jwt.split_once('.') {\n                Some(tuple) =\u003e tuple,\n                None =\u003e return Err(JwtError::DecodeError(\"Invalid JWT\".to_string())),\n            };\n\n            let (claims_b64, inner_signature_b64) =\n                claims_b64_signature_b64.split_once('.').unwrap();\n\n            // Base64-decode the header and claims\n            let header_json = general_purpose::STANDARD.decode(header_b64)?;\n            let claims_json = general_purpose::STANDARD.decode(claims_b64)?;\n\n            // Allocate Vec of references to slices\n            let header_json_tmp = header_json.as_slice();\n            let claims_json = claims_json.as_slice();\n\n            // Deserialize the header and claims from JSON\n            let _decoded_header: Header = serde_json::from_slice(header_json_tmp)?;\n            let _decoded_claims: Claims = serde_json::from_slice(claims_json)?;\n\n            // Sign the JWT with the secret\n            type HmacSha256 = Hmac\u003cSha256\u003e;\n            let mut hmac = HmacSha256::new_from_slice(secret).unwrap();\n            hmac.update(jwt.as_bytes());\n            let signature = hmac.finalize();\n            let signature_b64 = general_purpose::STANDARD.encode(signature.into_bytes());\n\n            // Compare the signature to the signature in the JWT\n            if signature_b64 != inner_signature_b64 {\n                return Err(JwtError::SignatureInvalid(signature_b64));\n            }\n            Ok(jwt.to_string())\n        }\n    }\n\n    /// Encodes a JWT token using the provided header, claims, and\n    /// secret. It returns a Result containing a string or an Error\n    /// variant. The function serializes the header and claims to JSON,\n    /// base64-encodes the header and claims, concatenates the encoded\n    /// header, claims, and separators, and then signs the JWT with the\n    /// provided secret.\n    pub fn encode(header: Header, claims: Claims, secret: \u0026[u8]) -\u003e Result\u003cString, JwtError\u003e {\n        // Serialize the header and claims to JSON\n        let header_json = serde_json::to_string(\u0026header)?;\n        let claims_json = serde_json::to_string(\u0026claims)?;\n\n        // Base64-encode the header and claims\n        let header_b64 = general_purpose::STANDARD.encode(header_json.as_bytes());\n        let claims_b64 = general_purpose::STANDARD.encode(claims_json.as_bytes());\n\n        // Concatenate the encoded header, claims, and separators\n        let jwt = format!(\"{header_b64}.{claims_b64}.\");\n\n        // Sign the JWT with the secret\n        type HmacSha256 = Hmac\u003cSha256\u003e;\n        let mut hmac = HmacSha256::new_from_slice(secret)?;\n        hmac.update(jwt.as_bytes());\n        let signature = hmac.finalize();\n\n        // Base64-encode the signature and concatenate it with the JWT\n        let signature_b64 = general_purpose::STANDARD.encode(signature.into_bytes());\n        let jwt = format!(\"{jwt}.{signature_b64}\");\n\n        Ok(jwt)\n    }\n\n    /// Generates a JWT token.\n    pub fn generate(secret: \u0026[u8]) -\u003e Result\u003cString, JwtError\u003e {\n        let claims = Claims::default();\n        let header = Header::default();\n        JWT::encode(header, claims, secret)\n    }\n\n    /// Returns the token field of the JWT struct.\n    pub fn get_token(jwt: JWT) -\u003e String {\n        jwt.token\n    }\n\n    /// Returns the header field of the JWT struct.\n    pub fn get_token_header(jwt: JWT) -\u003e Header {\n        jwt.header\n    }\n\n    /// Get the token length.\n    pub fn get_token_length(jwt: JWT) -\u003e usize {\n        jwt.token.len()\n    }\n\n    /// Validates a JWT token.\n    pub fn validate(\u0026self, secret: \u0026[u8]) -\u003e Result\u003c(), JwtError\u003e {\n        let jwt = \u0026self.token;\n        {\n            // Split the JWT into its header, claims, and signature\n            // let (header_b64, claims_b64_signature_b64) = jwt.split_once('.').unwrap();\n            let (header_b64, claims_b64_signature_b64) = match jwt.split_once('.') {\n                Some(tuple) =\u003e tuple,\n                None =\u003e return Err(JwtError::DecodeError(\"Invalid JWT\".to_string())),\n            };\n\n            let (claims_b64, inner_signature_b64) =\n                claims_b64_signature_b64.split_once('.').unwrap();\n\n            // Base64-decode the header and claims\n            let header_json = general_purpose::STANDARD.decode(header_b64)?;\n            let claims_json = general_purpose::STANDARD.decode(claims_b64)?;\n\n            // Allocate Vec of references to slices\n            let header_json_tmp = header_json.as_slice();\n            let claims_json = claims_json.as_slice();\n\n            // Deserialize the header and claims from JSON\n            let _decoded_header: Header = serde_json::from_slice(header_json_tmp)?;\n            let _decoded_claims: Claims = serde_json::from_slice(claims_json)?;\n\n            // Sign the JWT with the secret\n            type HmacSha256 = Hmac\u003cSha256\u003e;\n            let mut hmac = HmacSha256::new_from_slice(secret)?;\n            hmac.update(jwt.as_bytes());\n            let signature = hmac.finalize();\n\n            // Verify the signature\n            let mut hmac = HmacSha256::new_from_slice(secret)?;\n            hmac.update(inner_signature_b64.as_bytes());\n            let inner_signature = hmac.finalize();\n            if signature != inner_signature {\n                return Err(JwtError::InvalidSignature(\"Invalid signature\".to_string()));\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for JWT {\n    /// Formats the JWT struct for printing.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(\n            f,\n            \"JWT {{ header: {}, claims: {}, signature: {:?}, token: {} }}\",\n            self.header, self.claims, self.signature, self.token\n        )\n    }\n}\n\nimpl fmt::Display for Header {\n    /// Formats the Header struct for printing.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(\n            f,\n            \"Header {{ alg: {:?}, kid: {:?}, typ: {:?}, cty: {:?} }}\",\n            self.alg, self.kid, self.typ, self.cty\n        )\n    }\n}\n","traces":[{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":98},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cjwt","tests","cjwt.rs"],"content":"#[cfg(test)]\n\n// FIXME: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate cjwt;\n    extern crate claims;\n\n    use self::cjwt::{Algorithm, Header, JWT};\n    use self::claims::Claims;\n\n    #[test]\n    fn test_header_default() {\n        let header = Header::default();\n        assert_eq!(header.alg, Some(Algorithm::HS256));\n        assert_eq!(header.kid, None);\n        assert_eq!(header.typ, Some(\"JWT\".to_string()));\n        assert_eq!(header.cty, None);\n    }\n\n    #[test]\n    fn test_encode() {\n        let secret: \u0026[u8; 6] = b\"secret\";\n        let header = Header::default();\n        let claims = Claims::default();\n        let result = JWT::encode(header, claims, secret);\n        assert!(result.is_ok(), \"{}\", true);\n    }\n    #[test]\n    fn test_decode() {\n        let mut jwt = JWT::default();\n        let secret: \u0026[u8; 6] = b\"secret\";\n        let header = Header::default();\n        let claims = Claims::default();\n        let encoded_result = JWT::encode(header, claims, secret);\n        let encoded = encoded_result.unwrap();\n        jwt.token.clone_from(\u0026encoded);\n        let decoded = JWT::decode(\u0026mut jwt, secret);\n        if let Ok(decoded_token) = decoded {\n            assert_eq!(decoded_token, encoded);\n        }\n    }\n\n    #[test]\n    fn test_default() {\n        let jwt = JWT::default();\n        assert_eq!(jwt.header.alg, Some(Algorithm::HS256));\n    }\n\n    #[test]\n    fn test_generate() {\n        let secret = b\"secret\";\n        let jwt = JWT::generate(secret);\n        assert!(jwt.is_ok());\n        let token = jwt.unwrap();\n        assert!(!token.is_empty());\n    }\n\n    #[test]\n    fn test_get_token() {\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::get_token(jwt);\n        assert_eq!(result, \"example_token\");\n    }\n\n    #[test]\n    fn test_get_token_header() {\n        let jwt = JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: Some(\"example_kid\".to_string()),\n                typ: Some(\"example_type\".to_string()),\n                cty: Some(\"example_cty\".to_string()),\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::get_token_header(jwt);\n        assert_eq!(result.alg, Some(Algorithm::HS256));\n        assert_eq!(result.kid, Some(\"example_kid\".to_string()));\n        assert_eq!(result.typ, Some(\"example_type\".to_string()));\n        assert_eq!(result.cty, Some(\"example_cty\".to_string()));\n    }\n    #[test]\n    fn test_get_token_length() {\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"token\".to_string(),\n        };\n        let result = JWT::get_token_length(jwt);\n        assert_eq!(result, 5);\n    }\n    #[test]\n    fn test_validate_success() {\n        let secret: \u0026[u8; 6] = b\"secret\";\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = JWT::validate(\u0026jwt, secret);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_validate_with_empty_signature() {\n        // Create a JWT with valid claims and an empty signature\n        let secret = b\"secret\";\n        let jwt = JWT {\n            header: Header {\n                alg: Some(Algorithm::HS256),\n                kid: Some(\"example_kid\".to_string()),\n                typ: Some(\"example_type\".to_string()),\n                cty: Some(\"example_cty\".to_string()),\n            },\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n\n        // Test validating the JWT\n        let result = jwt.validate(secret);\n        assert!(result.is_err());\n    }\n    #[test]\n    fn test_to_string() {\n        let jwt = JWT {\n            header: Header::default(),\n            claims: Claims::default(),\n            signature: vec![],\n            token: \"example_token\".to_owned(),\n        };\n        let result = jwt.to_string();\n        assert_eq!(result, \"JWT { header: Header { alg: Some(HS256), kid: None, typ: Some(\\\"JWT\\\"), cty: None }, claims: Claims {  }, signature: [], token: example_token }\");\n    }\n    #[test]\n    fn test_claims_default() {\n        let claims = self::JWT::claims();\n        assert!(claims.is_empty(), \"{}\", true);\n    }\n\n    #[test]\n    fn test_algorithm_variants() {\n        assert!(matches!(Algorithm::HS256, Algorithm::HS256));\n        assert!(matches!(Algorithm::HS384, Algorithm::HS384));\n        assert!(matches!(Algorithm::HS512, Algorithm::HS512));\n        assert!(matches!(Algorithm::RS256, Algorithm::RS256));\n        assert!(matches!(Algorithm::RS384, Algorithm::RS384));\n        assert!(matches!(Algorithm::RS512, Algorithm::RS512));\n        assert!(matches!(Algorithm::ES256, Algorithm::ES256));\n        assert!(matches!(Algorithm::ES384, Algorithm::ES384));\n        assert!(matches!(Algorithm::ES512, Algorithm::ES512));\n    }\n\n    #[test]\n    fn test_algorithm_default() {\n        let algorithm = Algorithm::default();\n        assert_eq!(algorithm, Algorithm::HS256);\n    }\n    #[test]\n    fn test_algorithm_to_string() {\n        let algorithm = Algorithm::default();\n        assert_eq!(algorithm.to_string(), \"HS256\");\n\n        let algorithm_hs384 = Algorithm::HS384;\n        assert_eq!(algorithm_hs384.to_string(), \"HS384\");\n\n        let algorithm_hs512 = Algorithm::HS512;\n        assert_eq!(algorithm_hs512.to_string(), \"HS512\");\n\n        let algorithm_rs256 = Algorithm::RS256;\n        assert_eq!(algorithm_rs256.to_string(), \"RS256\");\n\n        let algorithm_rs384 = Algorithm::RS384;\n        assert_eq!(algorithm_rs384.to_string(), \"RS384\");\n\n        let algorithm_rs512 = Algorithm::RS512;\n        assert_eq!(algorithm_rs512.to_string(), \"RS512\");\n\n        let algorithm_es256 = Algorithm::ES256;\n        assert_eq!(algorithm_es256.to_string(), \"ES256\");\n\n        let algorithm_es384 = Algorithm::ES384;\n        assert_eq!(algorithm_es384.to_string(), \"ES384\");\n\n        let algorithm_es512 = Algorithm::ES512;\n        assert_eq!(algorithm_es512.to_string(), \"ES512\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","benches","claims.rs"],"content":"extern crate claims;\nuse self::claims::Claims;\n\nextern crate criterion;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn memory_usage_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"memory_usage\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            let memory_usage = std::mem::size_of_val(\u0026claims);\n            black_box(memory_usage);\n        });\n    });\n}\nfn set_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"set_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n\n        b.iter(|| {\n            claims.set_claim(key, value);\n        });\n    });\n}\n\nfn get_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"get_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.get_claim(key);\n        });\n    });\n}\n\nfn remove_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"remove_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.remove_claim(key);\n        });\n    });\n}\n\nfn has_claim_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"has_claim\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.has_claim(key);\n        });\n    });\n}\n\nfn clear_claims_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"clear_claims\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.clear_claims();\n        });\n    });\n}\n\nfn len_and_is_empty_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"len_and_is_empty\", |b| {\n        let mut claims = Claims::new();\n        let key = \"key\";\n        let value = \"value\";\n        claims.set_claim(key, value);\n\n        b.iter(|| {\n            claims.len();\n            claims.is_empty();\n        });\n    });\n}\n\nfn scale_claim_benchmark(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"set_claim\");\n    for i in [10, 100, 1000, 10000, 100000].iter() {\n        group.bench_with_input(format!(\"{i} claims\"), i, |b, i| {\n            let mut claims = Claims::new();\n            let key = \"key\";\n            let value = \"value\";\n            b.iter(|| {\n                for _ in 0..*i {\n                    claims.set_claim(key, value);\n                }\n            });\n        });\n    }\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    clear_claims_benchmark,\n    get_claim_benchmark,\n    has_claim_benchmark,\n    len_and_is_empty_benchmark,\n    memory_usage_benchmark,\n    remove_claim_benchmark,\n    scale_claim_benchmark,\n    set_claim_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","examples","claims.rs"],"content":"extern crate claims;\nuse self::claims::Claims;\n\nfn main() {\n    // Create a new instance of Claims\n    let mut claims = Claims::new();\n\n    // Set claims\n    claims.set_claim(\"aud\", \"https://example.com\");\n    claims.set_claim(\"custom\", \"admin\");\n    claims.set_claim(\"did\", \"did:example:123456789\");\n    claims.set_claim(\"iss\", \"https://issuer.com\");\n    claims.set_claim(\"jti\", \"abc123\");\n    claims.set_claim(\"sub\", \"user123\");\n    claims.set_claim(\"vc\", \"Ed25519Signature2018\");\n    claims.set_claim(\"vp\", \"B7AC971B05D791F0EB5FCE3B8A3296F1D68A63199714A2993AAD6E2F3D10F4E4425576AA4D97B80B617D5A182B519E9A021DEEDE9BFFBC3499F902DDC5CA163F\");\n\n    // Get claims\n    let audience = claims.get_claim(\"aud\").unwrap();\n    let custom = claims.get_claim(\"custom\").unwrap();\n    let did = claims.get_claim(\"did\").unwrap();\n    let issuer = claims.get_claim(\"iss\").unwrap();\n    let jwt_id = claims.get_claim(\"jti\").unwrap();\n    let subject = claims.get_claim(\"sub\").unwrap();\n    let credential = claims.get_claim(\"vc\").unwrap();\n    let proof = claims.get_claim(\"vp\").unwrap();\n\n    println!(\"ðŸ¦€ Claims::get_claim() for 'aud':       âœ… {audience}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'custom':    âœ… {custom}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'did':       âœ… {did}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'iss':       âœ… {issuer}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'jti':       âœ… {jwt_id}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'sub':       âœ… {subject}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'vc':        âœ… {credential}\");\n    println!(\"ðŸ¦€ Claims::get_claim() for 'vp':        âœ… {proof}\");\n\n    // Remove claims\n    let audience = claims.get_claim(\"aud\").unwrap().to_owned();\n    claims.remove_claim(\"aud\");\n    println!(\"ðŸ¦€ Claims::remove_claim():              âœ… {audience}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for accessing and manipulating claims of a JSON Web Token (JWT)\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-claims.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/claims)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The Claims library holds JSON Web Token (JWT) claims. It provides an\n//! RFC7519 compliant implementation of JSON Web Tokens (JWT) and JSON\n//! Web Signature (JWS) for Rust.\n//!\n//! The [**`Claims`**](./struct.Claims.html) type is provided to hold\n//! the claims of a JWT. The claims are stored in a `HashMap` and can be\n//! accessed using the `get_claim`, `set_claim`, `remove_claim`, and\n//! `has_claim` methods.\n//!\n//! ## Features\n//!\n//! The following table lists the optional reserved claims that are\n//! supported:\n//!\n//! | Claim | Description |\n//! | --- | --- |\n//! | `aud` (Audience) | Identifies the recipients that the JWT is intended for. |\n//! | `custom` (Custom) | Custom claims are used to share information between parties that agree on using them and are neither registered or public claims. |\n//! | `did` (Decentralized Identifier) | A string value that uniquely identifies a subject. |\n//! | `exp` (Expiration Time) | Identifies the expiration time on or after which the JWT MUST NOT be accepted for processing. |\n//! | `iat` (Issued At) | Identifies the time at which the JWT was issued. |\n//! | `iss` (Issuer) | Identifies the principal that issued the JWT. |\n//! | `jti` (JWT ID) | Provides a unique identifier for the JWT. |\n//! | `nbf` (Not Before) | Identifies the time before which the JWT MUST NOT be accepted for processing. |\n//! | `sub` (Subject) | Identifies the principal that is the subject of the JWT. |\n//! | `vc` (Verifiable Credential) | A Credential that is tamper-evident and has authorship that can be cryptographically verified. |\n//! | `vp` (Verifiable Presentation) | A Presentation that is tamper-evident and has authorship that can be cryptographically verified. |\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! ## Examples\n//!\n//! ```rust\n//! use self::claims::Claims;\n//! use std::collections::HashMap;\n//!\n//! // Create a new instance of Claims\n//! let mut claims = Claims::new();\n//!\n//! // Set a claim\n//! claims.set_claim(\"name\", \"John Doe\");\n//!\n//! // Get a claim\n//! let name = claims.get_claim(\"name\").unwrap(); // returns \"John Doe\"\n//!\n//! // Remove a claim\n//! claims.remove_claim(\"name\");\n//!\n//! // Clear all claims\n//! claims.clear_claims();\n//!\n//! // Has a claim\n//! let has_claim = claims.has_claim(\"name\"); // returns false\n//!\n//! // Get the number of claims\n//! let len = claims.len(); // returns 0\n//!\n//! // Is the claims empty?\n//! let is_empty = claims.is_empty(); // returns true\n//!\n//! // Get the claims as a HashMap\n//! let claims_map: \u0026HashMap\u003cString, String\u003e = claims.get_claims();\n//!\n//! ```\n//!\n//! ## Links\n//! * [RFC 7519](https://tools.ietf.org/html/rfc7519)\n//! * [JSON Web Token (JWT)](https://jwt.io/)\n//!\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-claims.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-claims.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"claims\"]\n#![crate_type = \"lib\"]\n\nextern crate serde;\nuse serde::{Deserialize, Serialize};\n\nuse std::collections::HashMap;\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\n/// The Claims struct holds the claims of a JSON Web Token (JWT).\n///\n/// A JWT is a compact, URL-safe means of representing claims to be\n/// transferred between two parties. It consists of a header, a payload,\n/// and a signature. The payload is where the claims are stored.\n///\n/// The claims in a JWT are encoded as a JSON object and can be used to\n/// convey information such as the identity of an end user, the\n/// expiration time of the token, and more.\n///\n/// The Claims struct provides a convenient way to manipulate the claims\n/// of a JWT in Rust. It stores the claims as a HashMap\u003cString, String\u003e,\n/// allowing for fast and efficient access to each claim.\npub struct Claims {\n    /// The claims of the JWT as a HashMap.\n    pub claims: HashMap\u003cString, String\u003e,\n}\n\nimpl Claims {\n    /// Creates a new instance of the `Claims` struct with an empty\n    /// HashMap of claims.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let claims = Claims::new();\n    /// assert!(claims.claims.is_empty());\n    /// ```\n    pub fn new() -\u003e Claims {\n        Claims {\n            claims: HashMap::new(),\n        }\n    }\n    /// Adds or updates a claim in the `Claims` struct with the given key and value.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.get_claim(\"sub\"), Some(\u0026String::from(\"1234567890\")));\n    /// ```\n    pub fn set_claim(\u0026mut self, key: \u0026str, value: \u0026str) {\n        self.claims.insert(key.to_string(), value.to_string());\n    }\n    /// Gets a claim from the `Claims` struct with the given key.\n    ///\n    /// Returns `None` if the key does not exist in the `Claims`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.get_claim(\"sub\"), Some(\u0026String::from(\"1234567890\")));\n    /// ```\n    pub fn get_claim(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026String\u003e {\n        self.claims.get(key)\n    }\n    //// Removes a claim from the `Claims` struct with the given key.\n    ///\n    /// Returns the value of the claim that was removed, if any.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.remove_claim(\"sub\"), Some(\"1234567890\".to_owned()));\n    /// ```\n    pub fn remove_claim(\u0026mut self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.claims.remove(key)\n    }\n    /// Clears all claims from the `Claims` struct.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// claims.clear_claims();\n    /// assert!(claims.claims.is_empty());\n    /// ```\n    pub fn clear_claims(\u0026mut self) {\n        self.claims.clear();\n    }\n    /// Checks if a claim with the given key exists in the `Claims` struct.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert!(claims.has_claim(\"sub\"));\n    /// ```\n    pub fn has_claim(\u0026self, key: \u0026str) -\u003e bool {\n        self.claims.contains_key(key)\n    }\n    /// Get the number of claims in the `Claims` struct.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert_eq!(claims.len(), 1);\n    /// ```\n    pub fn len(\u0026self) -\u003e usize {\n        self.claims.len()\n    }\n    /// Checks if the `Claims` struct is empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// assert!(claims.is_empty());\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// assert!(!claims.is_empty());\n    /// ```\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.claims.is_empty()\n    }\n    /// Get a reference to the HashMap of claims in the `Claims` struct.\n    /// This is useful if you need to iterate over the claims.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use self::claims::Claims;\n    /// let mut claims = Claims::new();\n    /// claims.set_claim(\"sub\", \"1234567890\");\n    /// claims.set_claim(\"name\", \"John Doe\");\n    /// for (key, value) in claims.get_claims() {\n    ///    println!(\"{}: {}\", key, value);\n    /// }\n    /// ```\n    pub fn get_claims(\u0026self) -\u003e \u0026HashMap\u003cString, String\u003e {\n        \u0026self.claims\n    }\n}\n\n/// Implement the `Display` trait for `Claims`.\nimpl std::fmt::Display for Claims {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let claims: Vec\u003cString\u003e = self\n            .claims\n            .iter()\n            .map(|(k, v)| format!(\"{k}: {v}\"))\n            .collect();\n\n        write!(f, \"Claims {{ {} }}\", claims.join(\", \"))\n    }\n}\n\n/// Implement the `Default` trait for `Claims`.\nimpl Default for Claims {\n    /// Create a new instance of `Claims`.\n    fn default() -\u003e Self {\n        Claims {\n            claims: HashMap::new(),\n        }\n    }\n}\n","traces":[{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":25},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","claims","tests","claims.rs"],"content":"#[cfg(test)]\n\nmod tests {\n\n    extern crate claims;\n    extern crate dtt;\n\n    use self::claims::Claims;\n    use self::dtt::DateTime;\n\n    #[test]\n    fn test_claims() {\n        const CL_AUD: \u0026str = \"MINI-FUNCTIONS-CLAIMS-AUD\";\n        const CL_CUSTOM: \u0026str = \"MINI-FUNCTIONS-CLAIMS-CUSTOM\";\n        const CL_DID: \u0026str = \"MINI-FUNCTIONS-CLAIMS-DID\";\n        const CL_ISS: \u0026str = \"MINI-FUNCTIONS-CLAIMS-ISS\";\n        const CL_JTI: \u0026str = \"MINI-FUNCTIONS-CLAIMS-JTI\";\n        const CL_SUB: \u0026str = \"MINI-FUNCTIONS-CLAIMS-SUB\";\n        const CL_VC: \u0026str = \"MINI-FUNCTIONS-CLAIMS-VC\";\n        const CL_VP: \u0026str = \"MINI-FUNCTIONS-CLAIMS-VP\";\n\n        let date = DateTime::new();\n        let iso = date.iso_8601;\n\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", CL_AUD);\n        claims.set_claim(\"custom\", CL_CUSTOM);\n        claims.set_claim(\"did\", CL_DID);\n        claims.set_claim(\"exp\", \u0026iso);\n        claims.set_claim(\"iat\", \u0026iso);\n        claims.set_claim(\"iss\", CL_ISS);\n        claims.set_claim(\"jti\", CL_JTI);\n        claims.set_claim(\"nbf\", \u0026iso);\n        claims.set_claim(\"sub\", CL_SUB);\n        claims.set_claim(\"vc\", CL_VC);\n        claims.set_claim(\"vp\", CL_VP);\n\n        assert_eq!(claims.get_claim(\"aud\").unwrap(), CL_AUD);\n        assert_eq!(claims.get_claim(\"custom\").unwrap(), CL_CUSTOM);\n        assert_eq!(claims.get_claim(\"did\").unwrap(), CL_DID);\n        assert_eq!(claims.get_claim(\"exp\").unwrap(), \u0026iso.to_string());\n        assert_eq!(claims.get_claim(\"iat\").unwrap(), \u0026iso.to_string());\n        assert_eq!(claims.get_claim(\"iss\").unwrap(), CL_ISS);\n        assert_eq!(claims.get_claim(\"jti\").unwrap(), CL_JTI);\n        assert_eq!(claims.get_claim(\"nbf\").unwrap(), \u0026iso.to_string());\n        assert_eq!(claims.get_claim(\"sub\").unwrap(), CL_SUB);\n        assert_eq!(claims.get_claim(\"vc\").unwrap(), CL_VC);\n        assert_eq!(claims.get_claim(\"vp\").unwrap(), CL_VP);\n    }\n    #[test]\n    fn test_get_claim() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        assert_eq!(\n            claims.get_claim(\"aud\").unwrap(),\n            \"MINI-FUNCTIONS-CLAIMS-AUD\"\n        );\n        assert!(claims.get_claim(\"non-existent-claim\").is_none());\n    }\n    #[test]\n    fn test_remove_claim() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.remove_claim(\"aud\");\n        assert!(claims.get_claim(\"aud\").is_none());\n    }\n\n    #[test]\n    fn test_clear_claims() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        claims.clear_claims();\n        assert_eq!(claims.len(), 0);\n    }\n    #[test]\n    fn test_has_claim() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        assert!(claims.has_claim(\"aud\"));\n        assert!(!claims.has_claim(\"non-existent-claim\"));\n    }\n\n    #[test]\n    fn test_len() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        assert_eq!(claims.len(), 2);\n    }\n    #[test]\n    fn test_is_empty() {\n        let mut claims = Claims::new();\n        assert!(claims.is_empty());\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        assert!(!claims.is_empty());\n    }\n\n    #[test]\n    fn test_get_claims() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        let retrieved_claims = claims.get_claims();\n        assert_eq!(\n            retrieved_claims.get(\"aud\").unwrap(),\n            \"MINI-FUNCTIONS-CLAIMS-AUD\"\n        );\n        assert_eq!(\n            retrieved_claims.get(\"custom\").unwrap(),\n            \"MINI-FUNCTIONS-CLAIMS-CUSTOM\"\n        );\n    }\n    #[test]\n    fn test_display_trait() {\n        let mut claims = Claims::new();\n        claims.set_claim(\"aud\", \"MINI-FUNCTIONS-CLAIMS-AUD\");\n        claims.set_claim(\"custom\", \"MINI-FUNCTIONS-CLAIMS-CUSTOM\");\n        let display_output = format!(\"{claims}\");\n        assert!(display_output.contains(\"aud: MINI-FUNCTIONS-CLAIMS-AUD\"));\n        assert!(display_output.contains(\"custom: MINI-FUNCTIONS-CLAIMS-CUSTOM\"));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let claims = Claims::default();\n        assert_eq!(claims.claims.len(), 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","benches","cmn.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\n\npub use cmn::Constants;\npub use cmn::Words;\n\npub struct Common;\n\nimpl Common {\n    pub fn new() -\u003e Self {\n        Common\n    }\n    pub fn constants(\u0026self) -\u003e Constants {\n        Constants\n    }\n    pub fn words(\u0026self) -\u003e Words {\n        Words::new()\n    }\n}\n\nimpl Default for Common {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nfn bench_common(c: \u0026mut Criterion) {\n    c.bench_function(\"common\", |b| {\n        b.iter(|| {\n            let common = black_box(Common::default());\n            black_box(common.constants());\n            black_box(common.words());\n        });\n    });\n}\n\ncriterion_group!(benches, bench_common);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","examples","cmn.rs"],"content":"extern crate cmn;\npub use cmn::Constants;\npub use cmn::Words;\n\nfn main() {\n    // Constants\n    let constants = Constants.constants();\n    for constant in constants {\n        println!(\n            \"ðŸ¦€ Constants::constant(): âœ… Name: {} Value: {}\",\n            constant.name, constant.value\n        );\n    }\n\n    // Words\n    let words = Words::new();\n    let words_list = words.words_list();\n    println!(\"ðŸ¦€ Words::new():          âœ… {:?}\", words_list[0]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","src","constants.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse serde::{Deserialize, Serialize};\n\n/// Contains several commonly used mathematical and cryptographic\n/// constants.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Constant {\n    /// The name of the constant.\n    pub name: \u0026'static str,\n\n    /// The value of the constant.\n    pub value: String,\n}\n/// The `Constants` structure holds mathematical and hash constants.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Constants;\n\nimpl Constants {\n    /// Returns a vector of tuples with the constant name and its value.\n    pub fn constants(\u0026self) -\u003e Vec\u003cConstant\u003e {\n        vec![\n            Constant {\n                name: \"EULER\",\n                value: EULER.to_string(),\n            },\n            Constant {\n                name: \"HASH_ALGORITHM\",\n                value: HASH_ALGORITHM.to_string(),\n            },\n            Constant {\n                name: \"HASH_COST\",\n                value: HASH_COST.to_string(),\n            },\n            Constant {\n                name: \"HASH_LENGTH\",\n                value: HASH_LENGTH.to_string(),\n            },\n            Constant {\n                name: \"PHI\",\n                value: PHI.to_string(),\n            },\n            Constant {\n                name: \"PI\",\n                value: PI.to_string(),\n            },\n            Constant {\n                name: \"PLANCK\",\n                value: PLANCK.to_string(),\n            },\n            Constant {\n                name: \"SQRT5\",\n                value: SQRT5.to_string(),\n            },\n            Constant {\n                name: \"SPECIAL_CHARS\",\n                value: format!(\"{SPECIAL_CHARS:?}\"),\n            },\n        ]\n    }\n}\n\n/// Enum to represent the different constant values.\n#[derive(Debug, Clone, Serialize)]\npub enum ConstantValue {\n    /// A float value represented as `f64`.\n    Float(f64),\n    /// A string value.\n    String(String),\n    /// An unsigned 32-bit integer value represented as `u32`.\n    U32(u32),\n    /// An unsigned integer with the size of a pointer represented as `usize`.\n    Usize(usize),\n    /// An array of characters represented as `\u0026'static [char]`.\n    CharArray(\u0026'static [char]),\n}\n\n/// The mathematical constant `E`, the base of the natural logarithm.\npub const EULER: f64 = std::f64::consts::E;\n\n/// The hash algorithm used. The default is Blake3.\npub const HASH_ALGORITHM: \u0026str = \"Blake3\";\n\n/// The cost of the hash algorithm. The default is 8.\npub const HASH_COST: u32 = 8;\n\n/// The length of the hash. The default is 32.\npub const HASH_LENGTH: usize = 32;\n\n/// The mathematical constant `Ï†` or the golden ratio.\npub const PHI: f64 = (1.0 + SQRT5) / 2.0;\n\n/// The mathematical constant `Ï€`.\npub const PI: f64 = std::f64::consts::PI;\n\n/// The Planck constant, `h`.\npub const PLANCK: f64 = 6.626_070_15e-34_f64;\n\n/// A set of special characters.\npub const SPECIAL_CHARS: \u0026[char] = \u0026[\n    '!', '@', '#', '$', '%', '^', '\u0026', '*', '(', ')', '_', '+', '=', '[', ']', '{', '}', '|', ';',\n    ':', '\"', '\u003c', '\u003e', ',', '.', '?', '/', '~', '`',\n];\n\n/// The square root of 5.\npub const SQRT5: f64 = 2.236_067_977_499_79_f64;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! A Rust library for accessing a collection of mathematical and cryptographic constants\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-cmn.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/cmn.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/cmn)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/cmn)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/cmn)\n//! [![License](https://img.shields.io/crates/l/cmn.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Common (CMN), a Rust library designed for developers who are looking\n//! for a comprehensive collection of mathematical and cryptographic\n//! constants.\n//!\n//!`CMN` is a modern, fast, and user-friendly library that makes it easy\n//! to access a wide range of mathematical and cryptographic constants,\n//! including the mathematical constant \"Euler\", the hash algorithm\n//! used, the cost of the hash algorithm, the length of the hash, the\n//! mathematical constant \"Phi\", the mathematical constant \"Pi\", the\n//! Planck constant, a set of special characters, and much more.\n//!\n//! ## Features\n//!\n//! The following table lists the Constants available in the Common\n//! library.\n//!\n//! | Constants | Description |\n//! | --- | --- |\n//! | `EULER` | Euler's constant is a mathematical constant approximately equal to 2.71828. |\n//! | `HASH_ALGORITHM` | The hash algorithm used to generate the hash. The default is Blake3. |\n//! | `HASH_COST` | The cost of the hash. |\n//! | `HASH_LENGTH` | The length of the hash. |\n//! | `PHI` | The golden ratio is a number approximately equal to 1.618033988749895. |\n//! | `PI` | Pi is the ratio of a circle's circumference to its diameter. |\n//! | `PLANCK` | Planck's constant is a physical constant that is approximately equal to 6.62607015 Ã— 10âˆ’34 joule seconds. |\n//! | `SQRT5` | The square root of 5 is a number approximately equal to 2.23606797749979. |\n//! | `SPECIAL_CHARS` | A list of special characters. |\n//!\n//! The following table lists the dictionaries available in the Common\n//! library.\n//!\n//! | Words | Description |\n//! | --- | --- |\n//! | `words` | Contains a dictionary of common words. |\n//!\n//! ## Usage\n//!\n//! Common can be any `serde::Serialize` or `serde::Deserialize` types\n//!\n//! ## Examples\n//!\n//! ```rust\n//!\n//! // Import the Common libraries\n//! use self::cmn::Constants;\n//! use self::cmn::Words;\n//!\n//! // Constants\n//! let constants = Constants.constants();\n//! for constant in constants {\n//!     println!(\"Name: {} Value: {}\", constant.name, constant.value);\n//! }\n//!\n//! // Words\n//! let words = Words::new();\n//! let words_list = words.words_list();\n//! assert_eq!(words_list[0], \"aboard\");\n//!\n//! ```\n//!\n#![warn(missing_docs)]\n#![forbid(unsafe_code)]\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cmn.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-cmn.svg\",\n    html_root_url = \"https://docs.rs/cmn\"\n)]\n#![crate_name = \"cmn\"]\n#![crate_type = \"lib\"]\n\nextern crate serde;\npub use serde::{Deserialize, Serialize};\n\n/// The `constants` module contains the `Constants` structure, which\n/// provides a collection of constant values that are used throughout\n/// the library.\npub mod constants;\n\n/// The `words` module contains the `Words` structure, which provides a\n/// collection of words that are used throughout the library.\npub mod words;\n\npub use constants::Constants;\npub use words::Words;\n\n/// The `Common` structure provides a central location to store data\n/// that is commonly used throughout the library. The structure\n/// implements the `Serialize` and `Deserialize` traits from the `serde`\n/// crate to enable serialization and deserialization of the data.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Common;\n\nimpl Common {\n    /// Creates a new instance of the `Common` structure.\n    pub fn new() -\u003e Self {\n        Self\n    }\n    /// Returns the `Constants` instance.\n    pub fn constants(\u0026self) -\u003e Constants {\n        Constants\n    }\n    /// Returns a new instance of the `Words` structure.\n    pub fn words(\u0026self) -\u003e Words {\n        Words::new()\n    }\n}\n\nimpl Default for Common {\n    /// Creates a new instance of the `Common` structure by calling\n    /// `Self::new()`.\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","src","words.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n/// Contains several words for use in generating passphrases.\npub struct Words;\n\nimpl Words {\n    /// Creates a new instance of `Words`.\n    pub fn new() -\u003e Self {\n        Words\n    }\n    /// Returns a list of words for use in generating passphrases.\n    pub fn words_list(\u0026self) -\u003e \u0026'static [\u0026'static str] {\n        WORD_LIST\n    }\n}\n\nimpl Default for Words {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// The list of words.\npub const WORD_LIST: \u0026[\u0026str] = \u0026[\n    \"aboard\", \"abode\", \"abort\", \"abound\", \"about\", \"above\", \"abroad\", \"abrupt\", \"absent\", \"absorb\",\n    \"absurd\", \"abuse\", \"accent\", \"accept\", \"access\", \"accord\", \"accuse\", \"ace\", \"ache\", \"aching\",\n    \"acid\", \"acidic\", \"acorn\", \"acre\", \"across\", \"act\", \"action\", \"active\", \"actor\", \"actual\",\n    \"acute\", \"adapt\", \"add\", \"added\", \"addict\", \"adept\", \"adhere\", \"adjust\", \"admire\", \"admit\",\n    \"adam\", \"afghan\", \"alaska\", \"alice\", \"allah\", \"amazon\", \"andrew\", \"anglo\", \"angola\", \"antony\",\n    \"adobe\", \"adopt\", \"adrift\", \"adult\", \"adverb\", \"advert\", \"aerial\", \"afar\", \"affair\", \"affect\",\n    \"afford\", \"afield\", \"afloat\", \"afraid\", \"afresh\", \"after\", \"again\", \"age\", \"agency\", \"agenda\",\n    \"agent\", \"aghast\", \"agile\", \"ago\", \"agony\", \"agree\", \"agreed\", \"ahead\", \"aid\", \"aide\", \"aim\",\n    \"air\", \"airman\", \"airy\", \"akin\", \"alarm\", \"albeit\", \"album\", \"alert\", \"alibi\", \"alien\",\n    \"alight\", \"align\", \"alike\", \"alive\", \"alkali\", \"all\", \"alley\", \"allied\", \"allow\", \"alloy\",\n    \"ally\", \"almond\", \"almost\", \"aloft\", \"alone\", \"along\", \"aloof\", \"aloud\", \"alpha\", \"alpine\",\n    \"also\", \"altar\", \"alter\", \"always\", \"amaze\", \"amber\", \"ambush\", \"amen\", \"amend\", \"amid\",\n    \"amidst\", \"amiss\", \"among\", \"amount\", \"ample\", \"amuse\", \"anchor\", \"and\", \"anew\", \"angel\",\n    \"anger\", \"angle\", \"angry\", \"animal\", \"ankle\", \"annoy\", \"annual\", \"answer\", \"anthem\", \"anti\",\n    \"any\", \"anyhow\", \"anyway\", \"apart\", \"apathy\", \"apex\", \"apiece\", \"appeal\", \"appear\", \"apple\",\n    \"apply\", \"apron\", \"arcade\", \"arcane\", \"arch\", \"ardent\", \"are\", \"area\", \"argue\", \"arid\",\n    \"april\", \"arab\", \"arctic\", \"athens\", \"austin\", \"bach\", \"baltic\", \"basque\", \"berlin\", \"bible\",\n    \"arise\", \"arm\", \"armful\", \"armpit\", \"army\", \"aroma\", \"around\", \"arouse\", \"array\", \"arrest\",\n    \"arrive\", \"arrow\", \"arson\", \"art\", \"artery\", \"artful\", \"artist\", \"ascent\", \"ashen\", \"ashore\",\n    \"aside\", \"ask\", \"asleep\", \"aspect\", \"assay\", \"assent\", \"assert\", \"assess\", \"asset\", \"assign\",\n    \"assist\", \"assume\", \"assure\", \"asthma\", \"astute\", \"asylum\", \"ate\", \"atlas\", \"atom\", \"atomic\",\n    \"attach\", \"attack\", \"attain\", \"attend\", \"attic\", \"auburn\", \"audio\", \"audit\", \"august\", \"aunt\",\n    \"auntie\", \"aura\", \"author\", \"auto\", \"autumn\", \"avail\", \"avenge\", \"avenue\", \"avert\", \"avid\",\n    \"avoid\", \"await\", \"awake\", \"awaken\", \"award\", \"aware\", \"awash\", \"away\", \"awful\", \"awhile\",\n    \"axes\", \"axiom\", \"axis\", \"axle\", \"aye\", \"babe\", \"baby\", \"back\", \"backup\", \"bacon\", \"bad\",\n    \"badge\", \"badly\", \"bag\", \"baggy\", \"bail\", \"bait\", \"bake\", \"baker\", \"bakery\", \"bald\", \"ball\",\n    \"ballad\", \"ballet\", \"ballot\", \"bamboo\", \"ban\", \"banal\", \"banana\", \"band\", \"bang\", \"bank\",\n    \"bar\", \"barber\", \"bare\", \"barely\", \"barge\", \"bark\", \"barley\", \"barn\", \"baron\", \"barrel\",\n    \"barren\", \"basalt\", \"base\", \"basic\", \"basil\", \"basin\", \"basis\", \"basket\", \"bass\", \"bat\",\n    \"batch\", \"bath\", \"baton\", \"battle\", \"bay\", \"beach\", \"beacon\", \"beak\", \"beam\", \"bean\", \"bear\",\n    \"beard\", \"beast\", \"beat\", \"beauty\", \"become\", \"bed\", \"beech\", \"beef\", \"beefy\", \"beep\", \"beer\",\n    \"beet\", \"beetle\", \"before\", \"beggar\", \"begin\", \"behalf\", \"behave\", \"behind\", \"beige\", \"being\",\n    \"belief\", \"bell\", \"belly\", \"belong\", \"below\", \"belt\", \"bench\", \"bend\", \"benign\", \"bent\",\n    \"berry\", \"berth\", \"beset\", \"beside\", \"best\", \"bestow\", \"bet\", \"beta\", \"betray\", \"better\",\n    \"beware\", \"beyond\", \"bias\", \"biceps\", \"bicker\", \"bid\", \"big\", \"bigger\", \"bike\", \"bile\", \"bill\",\n    \"binary\", \"bind\", \"biopsy\", \"birch\", \"bird\", \"birdie\", \"birth\", \"bishop\", \"bit\", \"bitch\",\n    \"bite\", \"bitter\", \"black\", \"blade\", \"blame\", \"bland\", \"blast\", \"blaze\", \"bleak\", \"blend\",\n    \"bless\", \"blew\", \"blind\", \"blink\", \"blip\", \"bliss\", \"blitz\", \"block\", \"blond\", \"blood\",\n    \"bloody\", \"bloom\", \"blot\", \"blouse\", \"blow\", \"blue\", \"bluff\", \"blunt\", \"blur\", \"blush\", \"boar\",\n    \"board\", \"boast\", \"boat\", \"bodily\", \"body\", \"bogus\", \"boil\", \"bold\", \"bolt\", \"bomb\", \"bond\",\n    \"bombay\", \"bonn\", \"boston\", \"brazil\", \"briton\", \"buddha\", \"burma\", \"caesar\", \"cairo\", \"canada\",\n    \"bone\", \"bonnet\", \"bonus\", \"bony\", \"book\", \"boom\", \"boost\", \"boot\", \"booth\", \"booze\", \"border\",\n    \"bore\", \"borrow\", \"bosom\", \"boss\", \"both\", \"bother\", \"bottle\", \"bottom\", \"bought\", \"bounce\",\n    \"bound\", \"bounty\", \"bout\", \"bovine\", \"bow\", \"bowel\", \"bowl\", \"box\", \"boy\", \"boyish\", \"brace\",\n    \"brain\", \"brainy\", \"brake\", \"bran\", \"branch\", \"brand\", \"brandy\", \"brass\", \"brave\", \"bravo\",\n    \"breach\", \"bread\", \"break\", \"breast\", \"breath\", \"bred\", \"breed\", \"breeze\", \"brew\", \"brick\",\n    \"bride\", \"bridge\", \"brief\", \"bright\", \"brim\", \"brine\", \"bring\", \"brink\", \"brisk\", \"broad\",\n    \"broke\", \"broken\", \"bronze\", \"brook\", \"broom\", \"brown\", \"bruise\", \"brush\", \"brutal\", \"brute\",\n    \"bubble\", \"buck\", \"bucket\", \"buckle\", \"budget\", \"buffet\", \"buggy\", \"build\", \"bulb\", \"bulge\",\n    \"bulk\", \"bulky\", \"bull\", \"bullet\", \"bully\", \"bump\", \"bumpy\", \"bunch\", \"bundle\", \"bunk\",\n    \"bunny\", \"burden\", \"bureau\", \"burial\", \"buried\", \"burly\", \"burn\", \"burnt\", \"burrow\", \"burst\",\n    \"bury\", \"bus\", \"bush\", \"bust\", \"bustle\", \"busy\", \"but\", \"butler\", \"butt\", \"butter\", \"button\",\n    \"buy\", \"buyer\", \"buzz\", \"bye\", \"byte\", \"cab\", \"cabin\", \"cable\", \"cache\", \"cactus\", \"cage\",\n    \"cake\", \"calf\", \"call\", \"caller\", \"calm\", \"calmly\", \"came\", \"camel\", \"camera\", \"camp\",\n    \"campus\", \"can\", \"canal\", \"canary\", \"cancel\", \"cancer\", \"candid\", \"candle\", \"candy\", \"cane\",\n    \"canine\", \"canoe\", \"canopy\", \"canvas\", \"canyon\", \"cap\", \"cape\", \"car\", \"carbon\", \"card\",\n    \"care\", \"career\", \"caress\", \"cargo\", \"carnal\", \"carp\", \"carpet\", \"carrot\", \"carry\", \"cart\",\n    \"carl\", \"carol\", \"celtic\", \"chile\", \"china\", \"christ\", \"congo\", \"cuba\", \"cyprus\", \"czech\",\n    \"cartel\", \"case\", \"cash\", \"cask\", \"cast\", \"castle\", \"casual\", \"cat\", \"catch\", \"cater\",\n    \"cattle\", \"caught\", \"causal\", \"cause\", \"cave\", \"cease\", \"celery\", \"cell\", \"cellar\", \"cement\",\n    \"censor\", \"census\", \"cereal\", \"cervix\", \"chain\", \"chair\", \"chalk\", \"chalky\", \"champ\", \"chance\",\n    \"change\", \"chant\", \"chaos\", \"chap\", \"chapel\", \"charge\", \"charm\", \"chart\", \"chase\", \"chat\",\n    \"cheap\", \"cheat\", \"check\", \"cheek\", \"cheeky\", \"cheer\", \"cheery\", \"cheese\", \"chef\", \"cherry\",\n    \"chess\", \"chest\", \"chew\", \"chic\", \"chick\", \"chief\", \"child\", \"chill\", \"chilly\", \"chin\", \"chip\",\n    \"choice\", \"choir\", \"choose\", \"chop\", \"choppy\", \"chord\", \"chorus\", \"chose\", \"chosen\", \"chrome\",\n    \"chunk\", \"chunky\", \"church\", \"cider\", \"cigar\", \"cinema\", \"circa\", \"circle\", \"circus\", \"cite\",\n    \"city\", \"civic\", \"civil\", \"clad\", \"claim\", \"clammy\", \"clan\", \"clap\", \"clash\", \"clasp\", \"class\",\n    \"clause\", \"claw\", \"clay\", \"clean\", \"clear\", \"clergy\", \"clerk\", \"clever\", \"click\", \"client\",\n    \"cliff\", \"climax\", \"climb\", \"clinch\", \"cling\", \"clinic\", \"clip\", \"cloak\", \"clock\", \"clone\",\n    \"close\", \"closer\", \"closet\", \"cloth\", \"cloud\", \"cloudy\", \"clout\", \"clown\", \"club\", \"clue\",\n    \"clumsy\", \"clung\", \"clutch\", \"coach\", \"coal\", \"coarse\", \"coast\", \"coat\", \"coax\", \"cobalt\",\n    \"cobra\", \"coca\", \"cock\", \"cocoa\", \"code\", \"coffee\", \"coffin\", \"cohort\", \"coil\", \"coin\", \"coke\",\n    \"cold\", \"collar\", \"colon\", \"colony\", \"colt\", \"column\", \"comb\", \"combat\", \"come\", \"comedy\",\n    \"comic\", \"commit\", \"common\", \"compel\", \"comply\", \"concur\", \"cone\", \"confer\", \"consul\",\n    \"convex\", \"convey\", \"convoy\", \"cook\", \"cool\", \"cope\", \"copper\", \"copy\", \"coral\", \"cord\",\n    \"core\", \"cork\", \"corn\", \"corner\", \"corps\", \"corpse\", \"corpus\", \"cortex\", \"cosmic\", \"cosmos\",\n    \"cost\", \"costly\", \"cosy\", \"cotton\", \"couch\", \"cough\", \"could\", \"count\", \"county\", \"coup\",\n    \"couple\", \"coupon\", \"course\", \"court\", \"cousin\", \"cove\", \"cover\", \"covert\", \"cow\", \"coward\",\n    \"cowboy\", \"crab\", \"crack\", \"cradle\", \"craft\", \"crafty\", \"crag\", \"crane\", \"crap\", \"crash\",\n    \"crate\", \"crater\", \"crawl\", \"crazy\", \"creak\", \"cream\", \"creamy\", \"create\", \"credit\", \"creed\",\n    \"creek\", \"creep\", \"creepy\", \"crept\", \"crest\", \"crew\", \"cried\", \"crime\", \"crisis\", \"crisp\",\n    \"critic\", \"croft\", \"crook\", \"crop\", \"cross\", \"crow\", \"crowd\", \"crown\", \"crude\", \"cruel\",\n    \"cruise\", \"crunch\", \"crush\", \"crust\", \"crux\", \"cry\", \"crypt\", \"cube\", \"cubic\", \"cuckoo\",\n    \"cuff\", \"cult\", \"cup\", \"curb\", \"cure\", \"curfew\", \"curl\", \"curry\", \"curse\", \"cursor\", \"curve\",\n    \"custom\", \"cut\", \"cute\", \"cycle\", \"cyclic\", \"cynic\", \"dad\", \"daddy\", \"dagger\", \"daily\",\n    \"dairy\", \"daisy\", \"dale\", \"damage\", \"damn\", \"damp\", \"dampen\", \"dance\", \"danger\", \"dare\",\n    \"dallas\", \"danish\", \"darwin\", \"david\", \"delhi\", \"derby\", \"diana\", \"dublin\", \"dutch\", \"east\",\n    \"dark\", \"darken\", \"dash\", \"data\", \"date\", \"dawn\", \"day\", \"dead\", \"deadly\", \"deaf\", \"deal\",\n    \"dealer\", \"dean\", \"dear\", \"death\", \"debate\", \"debit\", \"debris\", \"debt\", \"debtor\", \"decade\",\n    \"decay\", \"decent\", \"decide\", \"deck\", \"decor\", \"decree\", \"deduce\", \"deed\", \"deep\", \"deeply\",\n    \"deer\", \"defeat\", \"defect\", \"defend\", \"defer\", \"define\", \"defy\", \"degree\", \"deity\", \"delay\",\n    \"delete\", \"delta\", \"demand\", \"demise\", \"demo\", \"demon\", \"demure\", \"denial\", \"denote\", \"dense\",\n    \"dental\", \"deny\", \"depart\", \"depend\", \"depict\", \"deploy\", \"depot\", \"depth\", \"deputy\", \"derive\",\n    \"desert\", \"design\", \"desire\", \"desist\", \"desk\", \"detail\", \"detect\", \"deter\", \"detest\",\n    \"detour\", \"device\", \"devil\", \"devise\", \"devoid\", \"devote\", \"devour\", \"dial\", \"diary\", \"dice\",\n    \"dictum\", \"did\", \"die\", \"diesel\", \"diet\", \"differ\", \"digest\", \"digit\", \"dine\", \"dinghy\",\n    \"dinner\", \"diode\", \"dire\", \"direct\", \"dirt\", \"dirty\", \"disc\", \"disco\", \"dish\", \"disk\",\n    \"dismal\", \"dispel\", \"ditch\", \"dive\", \"divert\", \"divide\", \"divine\", \"dizzy\", \"docile\", \"dock\",\n    \"doctor\", \"dog\", \"dogma\", \"dole\", \"doll\", \"dollar\", \"dolly\", \"domain\", \"dome\", \"domino\",\n    \"donate\", \"done\", \"donkey\", \"donor\", \"doom\", \"door\", \"dorsal\", \"dose\", \"double\", \"doubt\",\n    \"dough\", \"dour\", \"dove\", \"down\", \"dozen\", \"draft\", \"drag\", \"dragon\", \"drain\", \"drama\", \"drank\",\n    \"draw\", \"drawer\", \"dread\", \"dream\", \"dreary\", \"dress\", \"drew\", \"dried\", \"drift\", \"drill\",\n    \"drink\", \"drip\", \"drive\", \"driver\", \"drop\", \"drove\", \"drown\", \"drug\", \"drum\", \"drunk\", \"dry\",\n    \"dual\", \"duck\", \"duct\", \"due\", \"duel\", \"duet\", \"duke\", \"dull\", \"duly\", \"dumb\", \"dummy\", \"dump\",\n    \"dune\", \"dung\", \"duress\", \"during\", \"dusk\", \"dust\", \"dusty\", \"duty\", \"dwarf\", \"dwell\", \"dyer\",\n    \"dying\", \"dynamo\", \"each\", \"eager\", \"eagle\", \"ear\", \"earl\", \"early\", \"earn\", \"earth\", \"ease\",\n    \"easel\", \"easily\", \"easter\", \"easy\", \"eat\", \"eaten\", \"eater\", \"echo\", \"eddy\", \"edge\", \"edible\",\n    \"eden\", \"edward\", \"eric\", \"essex\", \"europe\", \"eve\", \"exodus\", \"france\", \"french\", \"friday\",\n    \"edict\", \"edit\", \"editor\", \"eerie\", \"eerily\", \"effect\", \"effort\", \"egg\", \"ego\", \"eight\",\n    \"eighth\", \"eighty\", \"either\", \"elbow\", \"elder\", \"eldest\", \"elect\", \"eleven\", \"elicit\", \"elite\",\n    \"else\", \"elude\", \"elves\", \"embark\", \"emblem\", \"embryo\", \"emerge\", \"emit\", \"empire\", \"employ\",\n    \"empty\", \"enable\", \"enamel\", \"end\", \"endure\", \"enemy\", \"energy\", \"engage\", \"engine\", \"enjoy\",\n    \"enlist\", \"enough\", \"ensure\", \"entail\", \"enter\", \"entire\", \"entry\", \"envoy\", \"envy\", \"enzyme\",\n    \"epic\", \"epoch\", \"equal\", \"equate\", \"equip\", \"equity\", \"era\", \"erase\", \"erect\", \"erode\",\n    \"erotic\", \"errant\", \"error\", \"escape\", \"escort\", \"essay\", \"estate\", \"esteem\", \"ethic\",\n    \"ethnic\", \"evade\", \"even\", \"event\", \"ever\", \"every\", \"evict\", \"evil\", \"evoke\", \"evolve\",\n    \"exact\", \"exam\", \"exceed\", \"excel\", \"except\", \"excess\", \"excise\", \"excite\", \"excuse\", \"exempt\",\n    \"exert\", \"exile\", \"exist\", \"exit\", \"exotic\", \"expand\", \"expect\", \"expert\", \"expire\", \"export\",\n    \"expose\", \"extend\", \"extra\", \"eye\", \"eyed\", \"fabric\", \"face\", \"facial\", \"fact\", \"factor\",\n    \"fade\", \"fail\", \"faint\", \"fair\", \"fairly\", \"fairy\", \"faith\", \"fake\", \"falcon\", \"fall\", \"false\",\n    \"falter\", \"fame\", \"family\", \"famine\", \"famous\", \"fan\", \"fancy\", \"far\", \"farce\", \"fare\", \"farm\",\n    \"farmer\", \"fast\", \"fasten\", \"faster\", \"fat\", \"fatal\", \"fate\", \"father\", \"fatty\", \"fault\",\n    \"faulty\", \"fauna\", \"fear\", \"feast\", \"feat\", \"fed\", \"fee\", \"feeble\", \"feed\", \"feel\", \"feet\",\n    \"fell\", \"fellow\", \"felt\", \"female\", \"fence\", \"fend\", \"ferry\", \"fetal\", \"fetch\", \"feudal\",\n    \"fever\", \"few\", \"fewer\", \"fiance\", \"fiasco\", \"fiddle\", \"field\", \"fiend\", \"fierce\", \"fiery\",\n    \"fifth\", \"fifty\", \"fig\", \"fight\", \"figure\", \"file\", \"fill\", \"filled\", \"filler\", \"film\",\n    \"filter\", \"filth\", \"filthy\", \"final\", \"finale\", \"find\", \"fine\", \"finger\", \"finish\", \"finite\",\n    \"fire\", \"firm\", \"firmly\", \"first\", \"fiscal\", \"fish\", \"fisher\", \"fist\", \"fit\", \"fitful\", \"five\",\n    \"fix\", \"flag\", \"flair\", \"flak\", \"flame\", \"flank\", \"flap\", \"flare\", \"flash\", \"flask\", \"flat\",\n    \"flaw\", \"fled\", \"flee\", \"fleece\", \"fleet\", \"flesh\", \"fleshy\", \"flew\", \"flick\", \"flight\",\n    \"flimsy\", \"flint\", \"flirt\", \"float\", \"flock\", \"flood\", \"floor\", \"floppy\", \"flora\", \"floral\",\n    \"flour\", \"flow\", \"flower\", \"fluent\", \"fluffy\", \"fluid\", \"flung\", \"flurry\", \"flush\", \"flute\",\n    \"flux\", \"fly\", \"flyer\", \"foal\", \"foam\", \"focal\", \"focus\", \"fog\", \"foil\", \"fold\", \"folk\",\n    \"follow\", \"folly\", \"fond\", \"fondly\", \"font\", \"food\", \"fool\", \"foot\", \"for\", \"forbid\", \"force\",\n    \"ford\", \"forest\", \"forge\", \"forget\", \"fork\", \"form\", \"formal\", \"format\", \"former\", \"fort\",\n    \"forth\", \"forty\", \"forum\", \"fossil\", \"foster\", \"foul\", \"found\", \"four\", \"fourth\", \"fox\",\n    \"foyer\", \"frail\", \"frame\", \"franc\", \"frank\", \"fraud\", \"free\", \"freed\", \"freely\", \"freer\",\n    \"freeze\", \"frenzy\", \"fresh\", \"friar\", \"fridge\", \"fried\", \"friend\", \"fright\", \"fringe\", \"frock\",\n    \"frog\", \"from\", \"front\", \"frost\", \"frosty\", \"frown\", \"frozen\", \"frugal\", \"fruit\", \"fudge\",\n    \"fuel\", \"fulfil\", \"full\", \"fully\", \"fun\", \"fund\", \"funny\", \"fur\", \"furry\", \"fury\", \"fuse\",\n    \"fusion\", \"fuss\", \"fussy\", \"futile\", \"future\", \"fuzzy\", \"gadget\", \"gag\", \"gain\", \"gala\",\n    \"galaxy\", \"gale\", \"gall\", \"galley\", \"gallon\", \"gallop\", \"gamble\", \"game\", \"gamma\", \"gang\",\n    \"gandhi\", \"gaul\", \"gemini\", \"geneva\", \"george\", \"german\", \"gloria\", \"god\", \"gothic\", \"greece\",\n    \"gap\", \"garage\", \"garden\", \"garlic\", \"gas\", \"gasp\", \"gate\", \"gather\", \"gauge\", \"gaunt\", \"gave\",\n    \"gay\", \"gaze\", \"gear\", \"geese\", \"gender\", \"gene\", \"genial\", \"genius\", \"genre\", \"gentle\",\n    \"gently\", \"gentry\", \"genus\", \"get\", \"ghetto\", \"ghost\", \"giant\", \"gift\", \"giggle\", \"gill\",\n    \"gilt\", \"ginger\", \"girl\", \"give\", \"given\", \"glad\", \"glade\", \"glance\", \"gland\", \"glare\",\n    \"glass\", \"glassy\", \"gleam\", \"glee\", \"glide\", \"global\", \"globe\", \"gloom\", \"gloomy\", \"glory\",\n    \"gloss\", \"glossy\", \"glove\", \"glow\", \"glue\", \"goal\", \"goat\", \"gold\", \"golden\", \"golf\", \"gone\",\n    \"gong\", \"good\", \"goose\", \"gorge\", \"gory\", \"gosh\", \"gospel\", \"gossip\", \"got\", \"govern\", \"gown\",\n    \"grab\", \"grace\", \"grade\", \"grain\", \"grand\", \"grant\", \"grape\", \"graph\", \"grasp\", \"grass\",\n    \"grassy\", \"grate\", \"grave\", \"gravel\", \"gravy\", \"gray\", \"grease\", \"greasy\", \"great\", \"greed\",\n    \"greedy\", \"green\", \"greet\", \"grew\", \"grey\", \"grid\", \"grief\", \"grill\", \"grim\", \"grin\", \"grind\",\n    \"greek\", \"hague\", \"haiti\", \"hanoi\", \"harry\", \"havana\", \"hawaii\", \"hebrew\", \"henry\", \"hermes\",\n    \"grip\", \"grit\", \"gritty\", \"groan\", \"groin\", \"groom\", \"groove\", \"gross\", \"ground\", \"group\",\n    \"grove\", \"grow\", \"grown\", \"growth\", \"grudge\", \"grunt\", \"guard\", \"guess\", \"guest\", \"guide\",\n    \"guild\", \"guilt\", \"guilty\", \"guise\", \"guitar\", \"gulf\", \"gully\", \"gun\", \"gunman\", \"guru\", \"gut\",\n    \"guy\", \"gypsy\", \"habit\", \"hack\", \"had\", \"hail\", \"hair\", \"hairy\", \"hale\", \"half\", \"hall\",\n    \"halt\", \"hamlet\", \"hammer\", \"hand\", \"handle\", \"handy\", \"hang\", \"hangar\", \"happen\", \"happy\",\n    \"harass\", \"hard\", \"harder\", \"hardly\", \"hare\", \"harem\", \"harm\", \"harp\", \"harsh\", \"has\", \"hash\",\n    \"hassle\", \"haste\", \"hasten\", \"hasty\", \"hat\", \"hatch\", \"hate\", \"haul\", \"haunt\", \"have\", \"haven\",\n    \"havoc\", \"hawk\", \"hazard\", \"haze\", \"hazel\", \"hazy\", \"head\", \"heal\", \"health\", \"heap\", \"hear\",\n    \"heard\", \"heart\", \"hearth\", \"hearty\", \"heat\", \"heater\", \"heaven\", \"heavy\", \"heck\", \"hectic\",\n    \"hedge\", \"heel\", \"hefty\", \"height\", \"heir\", \"held\", \"helium\", \"helix\", \"hell\", \"hello\", \"helm\",\n    \"helmet\", \"help\", \"hemp\", \"hence\", \"her\", \"herald\", \"herb\", \"herd\", \"here\", \"hereby\", \"hernia\",\n    \"hero\", \"heroic\", \"heroin\", \"hey\", \"heyday\", \"hick\", \"hidden\", \"hide\", \"high\", \"higher\",\n    \"highly\", \"hill\", \"him\", \"hind\", \"hint\", \"hippy\", \"hire\", \"his\", \"hiss\", \"hit\", \"hive\",\n    \"hindu\", \"hitler\", \"idaho\", \"inca\", \"india\", \"indian\", \"iowa\", \"iran\", \"iraq\", \"irish\",\n    \"hoard\", \"hoarse\", \"hobby\", \"hockey\", \"hold\", \"holder\", \"hole\", \"hollow\", \"holly\", \"holy\",\n    \"home\", \"honest\", \"honey\", \"hood\", \"hook\", \"hope\", \"horn\", \"horny\", \"horrid\", \"horror\",\n    \"horse\", \"hose\", \"host\", \"hot\", \"hotel\", \"hound\", \"hour\", \"house\", \"hover\", \"how\", \"huge\",\n    \"hull\", \"human\", \"humane\", \"humble\", \"humid\", \"hung\", \"hunger\", \"hungry\", \"hunt\", \"hurdle\",\n    \"hurl\", \"hurry\", \"hurt\", \"hush\", \"hut\", \"hybrid\", \"hymn\", \"hyphen\", \"ice\", \"icing\", \"icon\",\n    \"idea\", \"ideal\", \"idiom\", \"idiot\", \"idle\", \"idly\", \"idol\", \"ignite\", \"ignore\", \"ill\", \"image\",\n    \"immune\", \"impact\", \"imply\", \"import\", \"impose\", \"incest\", \"inch\", \"income\", \"incur\", \"indeed\",\n    \"index\", \"indoor\", \"induce\", \"inept\", \"inert\", \"infant\", \"infect\", \"infer\", \"influx\", \"inform\",\n    \"inject\", \"injure\", \"injury\", \"inlaid\", \"inland\", \"inlet\", \"inmate\", \"inn\", \"innate\", \"inner\",\n    \"input\", \"insane\", \"insect\", \"insert\", \"inset\", \"inside\", \"insist\", \"insult\", \"insure\",\n    \"intact\", \"intake\", \"intend\", \"inter\", \"into\", \"invade\", \"invent\", \"invest\", \"invite\",\n    \"invoke\", \"inward\", \"iron\", \"ironic\", \"irony\", \"island\", \"isle\", \"issue\", \"itch\", \"item\",\n    \"isaac\", \"isabel\", \"islam\", \"israel\", \"italy\", \"ivan\", \"jack\", \"jacob\", \"james\", \"japan\",\n    \"itself\", \"ivory\", \"jacket\", \"jade\", \"jaguar\", \"jail\", \"jargon\", \"jaw\", \"jazz\", \"jeep\", \"java\",\n    \"jersey\", \"jesus\", \"jewish\", \"jim\", \"john\", \"jordan\", \"joseph\", \"judas\", \"judy\", \"jelly\",\n    \"jerky\", \"jest\", \"jet\", \"jewel\", \"job\", \"jock\", \"jockey\", \"join\", \"joint\", \"joke\", \"jolly\",\n    \"jolt\", \"joy\", \"joyful\", \"joyous\", \"judge\", \"juice\", \"juicy\", \"jumble\", \"jumbo\", \"july\",\n    \"june\", \"kansas\", \"karl\", \"kenya\", \"koran\", \"korea\", \"kuwait\", \"laos\", \"latin\", \"leo\", \"jump\",\n    \"jungle\", \"junior\", \"junk\", \"junta\", \"jury\", \"just\", \"karate\", \"keel\", \"keen\", \"keep\",\n    \"keeper\", \"kept\", \"kernel\", \"kettle\", \"key\", \"khaki\", \"kick\", \"kid\", \"kidnap\", \"kidney\",\n    \"kill\", \"killer\", \"kin\", \"kind\", \"kindly\", \"king\", \"kiss\", \"kite\", \"kitten\", \"knack\", \"knee\",\n    \"knew\", \"knife\", \"knight\", \"knit\", \"knob\", \"knock\", \"knot\", \"know\", \"known\", \"label\", \"lace\",\n    \"lack\", \"lad\", \"ladder\", \"laden\", \"lady\", \"lagoon\", \"laity\", \"lake\", \"lamb\", \"lame\", \"lamp\",\n    \"lance\", \"land\", \"lane\", \"lap\", \"lapse\", \"large\", \"larval\", \"laser\", \"last\", \"latch\", \"late\",\n    \"lately\", \"latent\", \"later\", \"latest\", \"latter\", \"laugh\", \"launch\", \"lava\", \"lavish\", \"law\",\n    \"lawful\", \"lawn\", \"lawyer\", \"lay\", \"layer\", \"layman\", \"lazy\", \"lead\", \"leader\", \"leaf\",\n    \"leafy\", \"league\", \"leak\", \"leaky\", \"lean\", \"leap\", \"learn\", \"lease\", \"leash\", \"least\",\n    \"leave\", \"led\", \"ledge\", \"left\", \"leg\", \"legacy\", \"legal\", \"legend\", \"legion\", \"lemon\", \"lend\",\n    \"length\", \"lens\", \"lent\", \"leper\", \"lesion\", \"less\", \"lessen\", \"lesser\", \"lesson\", \"lest\",\n    \"let\", \"lethal\", \"letter\", \"level\", \"lever\", \"levy\", \"lewis\", \"liable\", \"liar\", \"libel\",\n    \"libya\", \"lima\", \"lisbon\", \"liz\", \"london\", \"louvre\", \"lucy\", \"luther\", \"madame\", \"madrid\",\n    \"lice\", \"lick\", \"lid\", \"lie\", \"lied\", \"life\", \"lift\", \"light\", \"like\", \"likely\", \"limb\",\n    \"lime\", \"limit\", \"limp\", \"line\", \"linear\", \"linen\", \"linger\", \"link\", \"lion\", \"lip\", \"liquid\",\n    \"liquor\", \"list\", \"listen\", \"lit\", \"live\", \"lively\", \"liver\", \"lizard\", \"load\", \"loaf\", \"loan\",\n    \"lobby\", \"lobe\", \"local\", \"locate\", \"lock\", \"locus\", \"lodge\", \"loft\", \"lofty\", \"log\", \"logic\",\n    \"logo\", \"lone\", \"lonely\", \"long\", \"longer\", \"look\", \"loop\", \"loose\", \"loosen\", \"loot\", \"lord\",\n    \"lorry\", \"lose\", \"loss\", \"lost\", \"lot\", \"lotion\", \"lotus\", \"loud\", \"loudly\", \"lounge\", \"lousy\",\n    \"love\", \"lovely\", \"lover\", \"low\", \"lower\", \"lowest\", \"loyal\", \"lucid\", \"luck\", \"lucky\", \"lull\",\n    \"lump\", \"lumpy\", \"lunacy\", \"lunar\", \"lunch\", \"lung\", \"lure\", \"lurid\", \"lush\", \"lust\", \"lute\",\n    \"luxury\", \"lying\", \"lymph\", \"lynch\", \"lyric\", \"macho\", \"macro\", \"mad\", \"madam\", \"made\",\n    \"mafia\", \"magic\", \"magma\", \"magnet\", \"magnum\", \"maid\", \"maiden\", \"mail\", \"main\", \"mainly\",\n    \"major\", \"make\", \"maker\", \"male\", \"malice\", \"mall\", \"malt\", \"mammal\", \"manage\", \"mane\",\n    \"malta\", \"maria\", \"mars\", \"mary\", \"maya\", \"mecca\", \"mexico\", \"miami\", \"mickey\", \"milan\",\n    \"mania\", \"manic\", \"manner\", \"manor\", \"mantle\", \"manual\", \"manure\", \"many\", \"map\", \"maple\",\n    \"marble\", \"march\", \"mare\", \"margin\", \"marina\", \"mark\", \"market\", \"marry\", \"marsh\", \"martin\",\n    \"martyr\", \"mask\", \"mason\", \"mass\", \"mast\", \"master\", \"match\", \"mate\", \"matrix\", \"matter\",\n    \"mature\", \"maxim\", \"may\", \"maybe\", \"mayor\", \"maze\", \"mead\", \"meadow\", \"meal\", \"mean\", \"meant\",\n    \"meat\", \"medal\", \"media\", \"median\", \"medic\", \"medium\", \"meet\", \"mellow\", \"melody\", \"melon\",\n    \"melt\", \"member\", \"memo\", \"memory\", \"menace\", \"mend\", \"mental\", \"mentor\", \"menu\", \"mercy\",\n    \"mere\", \"merely\", \"merge\", \"merger\", \"merit\", \"merry\", \"mesh\", \"mess\", \"messy\", \"met\", \"metal\",\n    \"meter\", \"method\", \"methyl\", \"metric\", \"metro\", \"mid\", \"midday\", \"middle\", \"midst\", \"midway\",\n    \"might\", \"mighty\", \"mild\", \"mildew\", \"mile\", \"milk\", \"milky\", \"mill\", \"mimic\", \"mince\", \"mind\",\n    \"mine\", \"mini\", \"mink\", \"minor\", \"mint\", \"minus\", \"minute\", \"mirror\", \"mirth\", \"misery\",\n    \"miss\", \"mist\", \"misty\", \"mite\", \"mix\", \"moan\", \"moat\", \"mobile\", \"mock\", \"mode\", \"model\",\n    \"modem\", \"modern\", \"modest\", \"modify\", \"module\", \"moist\", \"molar\", \"mole\", \"molten\", \"moment\",\n    \"monaco\", \"monday\", \"moscow\", \"moses\", \"moslem\", \"mrs\", \"munich\", \"muslim\", \"naples\", \"nazi\",\n    \"money\", \"monies\", \"monk\", \"monkey\", \"month\", \"mood\", \"moody\", \"moon\", \"moor\", \"moral\",\n    \"morale\", \"morbid\", \"more\", \"morgue\", \"mortal\", \"mortar\", \"mosaic\", \"mosque\", \"moss\", \"most\",\n    \"mostly\", \"moth\", \"mother\", \"motion\", \"motive\", \"motor\", \"mould\", \"mount\", \"mourn\", \"mouse\",\n    \"mouth\", \"move\", \"movie\", \"much\", \"muck\", \"mucus\", \"mud\", \"muddle\", \"muddy\", \"mule\", \"mummy\",\n    \"murder\", \"murky\", \"murmur\", \"muscle\", \"museum\", \"music\", \"mussel\", \"must\", \"mutant\", \"mute\",\n    \"mutiny\", \"mutter\", \"mutton\", \"mutual\", \"muzzle\", \"myopic\", \"myriad\", \"myself\", \"mystic\",\n    \"myth\", \"nadir\", \"nail\", \"naked\", \"name\", \"namely\", \"nape\", \"napkin\", \"narrow\", \"nasal\",\n    \"nasty\", \"nation\", \"native\", \"nature\", \"nausea\", \"naval\", \"nave\", \"navy\", \"near\", \"nearer\",\n    \"nearly\", \"neat\", \"neatly\", \"neck\", \"need\", \"needle\", \"needy\", \"negate\", \"neon\", \"nephew\",\n    \"nepal\", \"newark\", \"nile\", \"nobel\", \"north\", \"norway\", \"ohio\", \"oscar\", \"oslo\", \"oxford\",\n    \"nerve\", \"nest\", \"neural\", \"never\", \"newly\", \"next\", \"nice\", \"nicely\", \"niche\", \"nickel\",\n    \"niece\", \"night\", \"nimble\", \"nine\", \"ninety\", \"ninth\", \"noble\", \"nobody\", \"node\", \"noise\",\n    \"noisy\", \"non\", \"none\", \"noon\", \"nor\", \"norm\", \"normal\", \"nose\", \"nosy\", \"not\", \"note\",\n    \"notice\", \"notify\", \"notion\", \"nought\", \"noun\", \"novel\", \"novice\", \"now\", \"nozzle\", \"nude\",\n    \"null\", \"numb\", \"number\", \"nurse\", \"nylon\", \"nymph\", \"oak\", \"oasis\", \"oath\", \"obese\", \"obey\",\n    \"object\", \"oblige\", \"oboe\", \"obtain\", \"occult\", \"occupy\", \"occur\", \"ocean\", \"octave\", \"odd\",\n    \"off\", \"offend\", \"offer\", \"office\", \"offset\", \"often\", \"oil\", \"oily\", \"okay\", \"old\", \"older\",\n    \"oldest\", \"olive\", \"omega\", \"omen\", \"omit\", \"once\", \"one\", \"onion\", \"only\", \"onset\", \"onto\",\n    \"onus\", \"onward\", \"opaque\", \"open\", \"openly\", \"opera\", \"opium\", \"oppose\", \"optic\", \"option\",\n    \"oracle\", \"oral\", \"orange\", \"orbit\", \"orchid\", \"ordeal\", \"order\", \"organ\", \"orgasm\", \"orient\",\n    \"origin\", \"ornate\", \"orphan\", \"other\", \"otter\", \"ought\", \"ounce\", \"our\", \"out\", \"outer\",\n    \"output\", \"outset\", \"oval\", \"oven\", \"over\", \"overt\", \"owe\", \"owing\", \"owl\", \"own\", \"owner\",\n    \"oxide\", \"oxygen\", \"oyster\", \"ozone\", \"pace\", \"pack\", \"packet\", \"pact\", \"paddle\", \"paddy\",\n    \"pagan\", \"page\", \"paid\", \"pain\", \"paint\", \"pair\", \"palace\", \"pale\", \"palm\", \"panel\", \"panic\",\n    \"panama\", \"paris\", \"pascal\", \"paul\", \"peking\", \"peru\", \"peter\", \"philip\", \"poland\", \"polish\",\n    \"papa\", \"papal\", \"paper\", \"parade\", \"parcel\", \"pardon\", \"parent\", \"parish\", \"park\", \"parody\",\n    \"parrot\", \"part\", \"partly\", \"party\", \"pass\", \"past\", \"paste\", \"pastel\", \"pastor\", \"pastry\",\n    \"pat\", \"patch\", \"patent\", \"path\", \"patio\", \"patrol\", \"patron\", \"pause\", \"pave\", \"pawn\", \"pay\",\n    \"peace\", \"peach\", \"peak\", \"pear\", \"pearl\", \"pedal\", \"peel\", \"peer\", \"pelvic\", \"pelvis\", \"pen\",\n    \"penal\", \"pence\", \"pencil\", \"penis\", \"penny\", \"people\", \"pepper\", \"per\", \"perch\", \"peril\",\n    \"period\", \"perish\", \"permit\", \"person\", \"pest\", \"petite\", \"petrol\", \"petty\", \"phase\", \"phone\",\n    \"photo\", \"phrase\", \"piano\", \"pick\", \"picket\", \"picnic\", \"pie\", \"piece\", \"pier\", \"pierce\",\n    \"piety\", \"pig\", \"pigeon\", \"piggy\", \"pike\", \"pile\", \"pill\", \"pillar\", \"pillow\", \"pilot\", \"pin\",\n    \"pinch\", \"pine\", \"pink\", \"pint\", \"pious\", \"pipe\", \"pirate\", \"piss\", \"pistol\", \"piston\", \"pit\",\n    \"pitch\", \"pity\", \"pivot\", \"pixel\", \"pizza\", \"place\", \"placid\", \"plague\", \"plain\", \"plan\",\n    \"plane\", \"planet\", \"plank\", \"plant\", \"plasma\", \"plate\", \"play\", \"player\", \"plea\", \"plead\",\n    \"please\", \"pledge\", \"plenty\", \"plenum\", \"plight\", \"plot\", \"ploy\", \"plug\", \"plum\", \"plump\",\n    \"plunge\", \"plural\", \"plus\", \"plush\", \"pocket\", \"poem\", \"poet\", \"poetic\", \"poetry\", \"point\",\n    \"poison\", \"polar\", \"pole\", \"police\", \"policy\", \"polite\", \"poll\", \"pollen\", \"polo\", \"pond\",\n    \"ponder\", \"pony\", \"pool\", \"poor\", \"poorly\", \"pop\", \"pope\", \"poppy\", \"pore\", \"pork\", \"port\",\n    \"portal\", \"pose\", \"posh\", \"post\", \"postal\", \"pot\", \"potato\", \"potent\", \"pouch\", \"pound\",\n    \"pour\", \"powder\", \"power\", \"praise\", \"pray\", \"prayer\", \"preach\", \"prefer\", \"prefix\", \"press\",\n    \"prague\", \"quebec\", \"rex\", \"rhine\", \"ritz\", \"robert\", \"roman\", \"rome\", \"rosa\", \"russia\",\n    \"pretty\", \"price\", \"pride\", \"priest\", \"primal\", \"prime\", \"prince\", \"print\", \"prior\", \"prism\",\n    \"prison\", \"privy\", \"prize\", \"probe\", \"profit\", \"prompt\", \"prone\", \"proof\", \"propel\", \"proper\",\n    \"prose\", \"proton\", \"proud\", \"prove\", \"proven\", \"proxy\", \"prune\", \"psalm\", \"pseudo\", \"psyche\",\n    \"pub\", \"public\", \"puff\", \"pull\", \"pulp\", \"pulpit\", \"pulsar\", \"pulse\", \"pump\", \"punch\",\n    \"punish\", \"punk\", \"pupil\", \"puppet\", \"puppy\", \"pure\", \"purely\", \"purge\", \"purify\", \"purple\",\n    \"purse\", \"pursue\", \"push\", \"pushy\", \"pussy\", \"put\", \"putt\", \"puzzle\", \"quaint\", \"quake\",\n    \"quarry\", \"quartz\", \"quay\", \"queen\", \"queer\", \"query\", \"quest\", \"queue\", \"quick\", \"quid\",\n    \"quiet\", \"quilt\", \"quirk\", \"quit\", \"quite\", \"quiver\", \"quiz\", \"quota\", \"quote\", \"rabbit\",\n    \"race\", \"racial\", \"racism\", \"rack\", \"racket\", \"radar\", \"radio\", \"radish\", \"radius\", \"raffle\",\n    \"raft\", \"rage\", \"raid\", \"rail\", \"rain\", \"rainy\", \"raise\", \"rally\", \"ramp\", \"random\", \"range\",\n    \"rank\", \"ransom\", \"rape\", \"rapid\", \"rare\", \"rarely\", \"rarity\", \"rash\", \"rat\", \"rate\", \"rather\",\n    \"ratify\", \"ratio\", \"rattle\", \"rave\", \"raven\", \"raw\", \"ray\", \"razor\", \"reach\", \"react\", \"read\",\n    \"reader\", \"ready\", \"real\", \"really\", \"realm\", \"reap\", \"rear\", \"reason\", \"rebel\", \"recall\",\n    \"recent\", \"recess\", \"recipe\", \"reckon\", \"record\", \"recoup\", \"rector\", \"red\", \"redeem\",\n    \"reduce\", \"reed\", \"reef\", \"refer\", \"reform\", \"refuge\", \"refuse\", \"regal\", \"regard\", \"regent\",\n    \"regime\", \"region\", \"regret\", \"reign\", \"reject\", \"relate\", \"relax\", \"relay\", \"relic\", \"relief\",\n    \"relish\", \"rely\", \"remain\", \"remark\", \"remedy\", \"remind\", \"remit\", \"remote\", \"remove\", \"renal\",\n    \"render\", \"rent\", \"rental\", \"repair\", \"repeal\", \"repeat\", \"repent\", \"reply\", \"report\",\n    \"rescue\", \"resent\", \"reside\", \"resign\", \"resin\", \"resist\", \"resort\", \"rest\", \"result\",\n    \"resume\", \"retail\", \"retain\", \"retina\", \"retire\", \"return\", \"reveal\", \"review\", \"revise\",\n    \"revive\", \"revolt\", \"reward\", \"rhino\", \"rhyme\", \"rhythm\", \"ribbon\", \"rice\", \"rich\", \"rick\",\n    \"rid\", \"ride\", \"rider\", \"ridge\", \"rife\", \"rifle\", \"rift\", \"right\", \"rigid\", \"ring\", \"rinse\",\n    \"riot\", \"ripe\", \"ripen\", \"ripple\", \"rise\", \"risk\", \"risky\", \"rite\", \"ritual\", \"rival\", \"river\",\n    \"road\", \"roar\", \"roast\", \"rob\", \"robe\", \"robin\", \"robot\", \"robust\", \"rock\", \"rocket\", \"rocky\",\n    \"rod\", \"rode\", \"rodent\", \"rogue\", \"role\", \"roll\", \"roof\", \"room\", \"root\", \"rope\", \"rose\",\n    \"rosy\", \"rotate\", \"rotor\", \"rotten\", \"rouge\", \"rough\", \"round\", \"route\", \"rover\", \"row\",\n    \"royal\", \"rubble\", \"ruby\", \"rudder\", \"rude\", \"rugby\", \"ruin\", \"rule\", \"ruler\", \"rumble\",\n    \"rump\", \"run\", \"rune\", \"rung\", \"runway\", \"rural\", \"rush\", \"rust\", \"rustic\", \"rusty\", \"sack\",\n    \"sacred\", \"sad\", \"saddle\", \"sadism\", \"sadly\", \"safari\", \"safe\", \"safely\", \"safer\", \"safety\",\n    \"saga\", \"sage\", \"said\", \"sail\", \"sailor\", \"saint\", \"sake\", \"salad\", \"salary\", \"sale\", \"saline\",\n    \"sahara\", \"sam\", \"saturn\", \"saudi\", \"saxon\", \"scot\", \"seoul\", \"somali\", \"sony\", \"soviet\",\n    \"saliva\", \"salmon\", \"saloon\", \"salt\", \"salty\", \"salute\", \"same\", \"sample\", \"sand\", \"sandy\",\n    \"sane\", \"sash\", \"satan\", \"satin\", \"satire\", \"sauce\", \"sauna\", \"savage\", \"save\", \"say\", \"scale\",\n    \"scalp\", \"scan\", \"scant\", \"scar\", \"scarce\", \"scare\", \"scarf\", \"scary\", \"scene\", \"scenic\",\n    \"scent\", \"school\", \"scope\", \"score\", \"scorn\", \"scotch\", \"scout\", \"scrap\", \"scream\", \"screen\",\n    \"screw\", \"script\", \"scroll\", \"scrub\", \"scum\", \"sea\", \"seal\", \"seam\", \"seaman\", \"search\",\n    \"season\", \"seat\", \"second\", \"secret\", \"sect\", \"sector\", \"secure\", \"see\", \"seed\", \"seeing\",\n    \"seek\", \"seem\", \"seize\", \"seldom\", \"select\", \"self\", \"sell\", \"seller\", \"semi\", \"senate\",\n    \"send\", \"senile\", \"senior\", \"sense\", \"sensor\", \"sent\", \"sentry\", \"sequel\", \"serene\", \"serial\",\n    \"series\", \"sermon\", \"serum\", \"serve\", \"server\", \"set\", \"settle\", \"seven\", \"severe\", \"sewage\",\n    \"sex\", \"sexual\", \"sexy\", \"shabby\", \"shade\", \"shadow\", \"shady\", \"shaft\", \"shaggy\", \"shah\",\n    \"shake\", \"shaky\", \"shall\", \"sham\", \"shame\", \"shape\", \"share\", \"shark\", \"sharp\", \"shawl\", \"she\",\n    \"shear\", \"sheen\", \"sheep\", \"sheer\", \"sheet\", \"shelf\", \"shell\", \"sherry\", \"shield\", \"shift\",\n    \"shine\", \"shiny\", \"ship\", \"shire\", \"shirt\", \"shit\", \"shiver\", \"shock\", \"shoe\", \"shook\",\n    \"shoot\", \"shop\", \"shore\", \"short\", \"shot\", \"should\", \"shout\", \"show\", \"shower\", \"shrank\",\n    \"shrewd\", \"shrill\", \"shrimp\", \"shrine\", \"shrink\", \"shrub\", \"shrug\", \"shut\", \"shy\", \"shyly\",\n    \"sick\", \"side\", \"siege\", \"sigh\", \"sight\", \"sigma\", \"sign\", \"signal\", \"silent\", \"silk\",\n    \"silken\", \"silky\", \"sill\", \"silly\", \"silver\", \"simple\", \"simply\", \"since\", \"sinful\", \"sing\",\n    \"singer\", \"single\", \"sink\", \"sir\", \"siren\", \"sister\", \"sit\", \"site\", \"six\", \"sixth\", \"sixty\",\n    \"size\", \"sketch\", \"skill\", \"skin\", \"skinny\", \"skip\", \"skirt\", \"skull\", \"sky\", \"slab\", \"slack\",\n    \"slain\", \"slam\", \"slang\", \"slap\", \"slate\", \"slater\", \"slave\", \"sleek\", \"sleep\", \"sleepy\",\n    \"sleeve\", \"slice\", \"slick\", \"slid\", \"slide\", \"slight\", \"slim\", \"slimy\", \"sling\", \"slip\",\n    \"slit\", \"slogan\", \"slope\", \"sloppy\", \"slot\", \"slow\", \"slowly\", \"slug\", \"slum\", \"slump\",\n    \"smack\", \"small\", \"smart\", \"smash\", \"smear\", \"smell\", \"smelly\", \"smelt\", \"smile\", \"smoke\",\n    \"smoky\", \"smooth\", \"smug\", \"snack\", \"snail\", \"snake\", \"snap\", \"snatch\", \"sneak\", \"snow\",\n    \"snowy\", \"snug\", \"soak\", \"soap\", \"sober\", \"soccer\", \"social\", \"sock\", \"socket\", \"soda\",\n    \"sodden\", \"sodium\", \"sofa\", \"soft\", \"soften\", \"softly\", \"soggy\", \"soil\", \"solar\", \"sold\",\n    \"sole\", \"solely\", \"solemn\", \"solid\", \"solo\", \"solve\", \"some\", \"son\", \"sonar\", \"sonata\", \"song\",\n    \"sonic\", \"soon\", \"sooner\", \"soot\", \"soothe\", \"sordid\", \"sore\", \"sorrow\", \"sorry\", \"sort\",\n    \"soul\", \"sound\", \"soup\", \"sour\", \"source\", \"space\", \"spade\", \"span\", \"spare\", \"spark\", \"spain\",\n    \"stalin\", \"sudan\", \"suez\", \"sunday\", \"sweden\", \"swiss\", \"sydney\", \"syria\", \"taiwan\", \"sparse\",\n    \"spasm\", \"spat\", \"spate\", \"speak\", \"spear\", \"speech\", \"speed\", \"speedy\", \"spell\", \"spend\",\n    \"sperm\", \"sphere\", \"spice\", \"spicy\", \"spider\", \"spiky\", \"spill\", \"spin\", \"spinal\", \"spine\",\n    \"spiral\", \"spirit\", \"spit\", \"spite\", \"splash\", \"split\", \"spoil\", \"spoke\", \"sponge\", \"spoon\",\n    \"sport\", \"spot\", \"spouse\", \"spray\", \"spread\", \"spree\", \"spring\", \"sprint\", \"spur\", \"squad\",\n    \"square\", \"squash\", \"squat\", \"squid\", \"stab\", \"stable\", \"stack\", \"staff\", \"stage\", \"stain\",\n    \"stair\", \"stake\", \"stale\", \"stall\", \"stamp\", \"stance\", \"stand\", \"staple\", \"star\", \"starch\",\n    \"stare\", \"stark\", \"start\", \"starve\", \"state\", \"static\", \"statue\", \"status\", \"stay\", \"stead\",\n    \"steady\", \"steak\", \"steal\", \"steam\", \"steel\", \"steep\", \"steer\", \"stem\", \"stench\", \"step\",\n    \"stereo\", \"stern\", \"stew\", \"stick\", \"sticky\", \"stiff\", \"stifle\", \"stigma\", \"still\", \"sting\",\n    \"stint\", \"stir\", \"stitch\", \"stock\", \"stocky\", \"stone\", \"stony\", \"stool\", \"stop\", \"store\",\n    \"storm\", \"stormy\", \"story\", \"stout\", \"stove\", \"strain\", \"strait\", \"strand\", \"strap\", \"strata\",\n    \"straw\", \"stray\", \"streak\", \"stream\", \"street\", \"stress\", \"strict\", \"stride\", \"strife\",\n    \"strike\", \"string\", \"strip\", \"strive\", \"stroke\", \"stroll\", \"strong\", \"stud\", \"studio\", \"study\",\n    \"stuff\", \"stuffy\", \"stunt\", \"stupid\", \"sturdy\", \"style\", \"submit\", \"subtle\", \"subtly\",\n    \"suburb\", \"such\", \"suck\", \"sudden\", \"sue\", \"suffer\", \"sugar\", \"suit\", \"suite\", \"suitor\",\n    \"sullen\", \"sultan\", \"sum\", \"summer\", \"summit\", \"summon\", \"sun\", \"sunny\", \"sunset\", \"super\",\n    \"superb\", \"supper\", \"supple\", \"supply\", \"sure\", \"surely\", \"surf\", \"surge\", \"survey\", \"suture\",\n    \"swamp\", \"swan\", \"swap\", \"swarm\", \"sway\", \"swear\", \"sweat\", \"sweaty\", \"sweep\", \"sweet\",\n    \"swell\", \"swift\", \"swim\", \"swine\", \"swing\", \"swirl\", \"switch\", \"sword\", \"swore\", \"symbol\",\n    \"synod\", \"syntax\", \"syrup\", \"system\", \"table\", \"tablet\", \"taboo\", \"tacit\", \"tackle\", \"tact\",\n    \"tactic\", \"tail\", \"tailor\", \"take\", \"tale\", \"talent\", \"talk\", \"tall\", \"tally\", \"tame\",\n    \"tandem\", \"tangle\", \"tank\", \"tap\", \"tape\", \"target\", \"tariff\", \"tart\", \"task\", \"taste\",\n    \"tarzan\", \"taurus\", \"tehran\", \"teresa\", \"texas\", \"thomas\", \"tibet\", \"tokyo\", \"tom\", \"turk\",\n    \"tasty\", \"tattoo\", \"taut\", \"tavern\", \"tax\", \"taxi\", \"tea\", \"teach\", \"teak\", \"team\", \"tear\",\n    \"tease\", \"tech\", \"teeth\", \"tell\", \"temper\", \"temple\", \"tempo\", \"tempt\", \"ten\", \"tenant\",\n    \"tend\", \"tender\", \"tendon\", \"tennis\", \"tenor\", \"tense\", \"tensor\", \"tent\", \"tenth\", \"tenure\",\n    \"term\", \"terror\", \"test\", \"text\", \"than\", \"thank\", \"that\", \"the\", \"their\", \"them\", \"theme\",\n    \"then\", \"thence\", \"theory\", \"there\", \"these\", \"thesis\", \"they\", \"thick\", \"thief\", \"thigh\",\n    \"thin\", \"thing\", \"think\", \"third\", \"thirst\", \"thirty\", \"this\", \"thorn\", \"those\", \"though\",\n    \"thread\", \"threat\", \"three\", \"thrill\", \"thrive\", \"throat\", \"throne\", \"throng\", \"throw\",\n    \"thrust\", \"thud\", \"thug\", \"thumb\", \"thus\", \"thyme\", \"tick\", \"ticket\", \"tidal\", \"tide\", \"tidy\",\n    \"tie\", \"tier\", \"tiger\", \"tight\", \"tile\", \"till\", \"tilt\", \"timber\", \"time\", \"timid\", \"tin\",\n    \"tiny\", \"tip\", \"tissue\", \"title\", \"toad\", \"toast\", \"today\", \"toilet\", \"token\", \"told\", \"toll\",\n    \"tomato\", \"tomb\", \"tonal\", \"tone\", \"tongue\", \"tonic\", \"too\", \"took\", \"tool\", \"tooth\", \"top\",\n    \"topaz\", \"topic\", \"torch\", \"torque\", \"torso\", \"tort\", \"toss\", \"total\", \"touch\", \"tough\",\n    \"tour\", \"toward\", \"towel\", \"tower\", \"town\", \"toxic\", \"toxin\", \"trace\", \"track\", \"tract\",\n    \"trade\", \"tragic\", \"trail\", \"train\", \"trait\", \"tram\", \"trance\", \"trap\", \"trauma\", \"travel\",\n    \"tray\", \"tread\", \"treat\", \"treaty\", \"treble\", \"tree\", \"trek\", \"tremor\", \"trench\", \"trend\",\n    \"trendy\", \"trial\", \"tribal\", \"tribe\", \"trick\", \"tricky\", \"tried\", \"trifle\", \"trim\", \"trio\",\n    \"trip\", \"triple\", \"troop\", \"trophy\", \"trot\", \"trough\", \"trout\", \"truce\", \"truck\", \"true\",\n    \"truly\", \"trunk\", \"trust\", \"truth\", \"try\", \"tsar\", \"tube\", \"tumble\", \"tuna\", \"tundra\", \"tune\",\n    \"tung\", \"tunic\", \"tunnel\", \"turban\", \"turf\", \"turn\", \"turtle\", \"tutor\", \"tweed\", \"twelve\",\n    \"turkey\", \"uganda\", \"venice\", \"venus\", \"vienna\", \"viking\", \"virgo\", \"warsaw\", \"west\", \"yale\",\n    \"twenty\", \"twice\", \"twin\", \"twist\", \"two\", \"tycoon\", \"tying\", \"type\", \"tyrant\", \"ugly\",\n    \"ulcer\", \"ultra\", \"umpire\", \"unable\", \"uncle\", \"under\", \"uneasy\", \"unfair\", \"unify\", \"union\",\n    \"unique\", \"unit\", \"unite\", \"unity\", \"unlike\", \"unrest\", \"unruly\", \"until\", \"update\", \"upheld\",\n    \"uphill\", \"uphold\", \"upon\", \"uproar\", \"upset\", \"upshot\", \"uptake\", \"upturn\", \"upward\", \"urban\",\n    \"urge\", \"urgent\", \"urging\", \"urine\", \"usable\", \"usage\", \"use\", \"useful\", \"user\", \"usual\",\n    \"uterus\", \"utmost\", \"utter\", \"vacant\", \"vacuum\", \"vagina\", \"vague\", \"vain\", \"valet\", \"valid\",\n    \"valley\", \"value\", \"valve\", \"van\", \"vanish\", \"vanity\", \"vary\", \"vase\", \"vast\", \"vat\", \"vault\",\n    \"vector\", \"veil\", \"vein\", \"velvet\", \"vendor\", \"veneer\", \"venom\", \"vent\", \"venue\", \"verb\",\n    \"verbal\", \"verge\", \"verify\", \"verity\", \"verse\", \"versus\", \"very\", \"vessel\", \"vest\", \"veto\",\n    \"via\", \"viable\", \"vicar\", \"vice\", \"victim\", \"victor\", \"video\", \"view\", \"vigil\", \"vile\",\n    \"villa\", \"vine\", \"vinyl\", \"viola\", \"violet\", \"violin\", \"viral\", \"virgin\", \"virtue\", \"virus\",\n    \"visa\", \"vision\", \"visit\", \"visual\", \"vital\", \"vivid\", \"vocal\", \"vodka\", \"vogue\", \"voice\",\n    \"void\", \"volley\", \"volume\", \"vomit\", \"vote\", \"vowel\", \"voyage\", \"vulgar\", \"wade\", \"wage\",\n    \"waist\", \"wait\", \"waiter\", \"wake\", \"walk\", \"walker\", \"wall\", \"wallet\", \"walnut\", \"wander\",\n    \"want\", \"war\", \"warden\", \"warm\", \"warmth\", \"warn\", \"warp\", \"wary\", \"was\", \"wash\", \"wasp\",\n    \"waste\", \"watch\", \"water\", \"watery\", \"wave\", \"way\", \"weak\", \"weaken\", \"wealth\", \"weapon\",\n    \"wear\", \"weary\", \"wedge\", \"wee\", \"weed\", \"week\", \"weekly\", \"weep\", \"weight\", \"weird\", \"well\",\n    \"were\", \"wet\", \"whale\", \"wharf\", \"what\", \"wheat\", \"wheel\", \"when\", \"whence\", \"where\", \"which\",\n    \"whiff\", \"whig\", \"while\", \"whim\", \"whip\", \"whisky\", \"white\", \"who\", \"whole\", \"wholly\", \"whom\",\n    \"whore\", \"whose\", \"why\", \"wide\", \"widely\", \"widen\", \"wider\", \"widow\", \"width\", \"wife\", \"wild\",\n    \"wildly\", \"wilful\", \"will\", \"willow\", \"win\", \"wind\", \"window\", \"windy\", \"wine\", \"wing\", \"wink\",\n    \"winner\", \"winter\", \"wipe\", \"wire\", \"wisdom\", \"wise\", \"wish\", \"wit\", \"witch\", \"with\", \"within\",\n    \"witty\", \"wizard\", \"woke\", \"wolf\", \"wolves\", \"woman\", \"womb\", \"won\", \"wonder\", \"wood\",\n    \"wooden\", \"woods\", \"woody\", \"wool\", \"word\", \"work\", \"worker\", \"world\", \"worm\", \"worry\",\n    \"worse\", \"worst\", \"worth\", \"worthy\", \"would\", \"wound\", \"wrap\", \"wrath\", \"wreath\", \"wreck\",\n    \"wright\", \"wrist\", \"writ\", \"write\", \"writer\", \"wrong\", \"xerox\", \"yacht\", \"yard\", \"yarn\",\n    \"yeah\", \"year\", \"yeast\", \"yellow\", \"yet\", \"yield\", \"yogurt\", \"yolk\", \"you\", \"young\", \"your\",\n    \"yemen\", \"york\", \"zaire\", \"zurich\", \"aback\", \"abbey\", \"abbot\", \"abide\", \"ablaze\", \"able\",\n    \"youth\", \"zeal\", \"zebra\", \"zenith\", \"zero\", \"zigzag\", \"zinc\", \"zombie\", \"zone\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","tests","common.rs"],"content":"#[cfg(test)]\nmod tests {\n    pub use cmn::Words;\n    use cmn::*;\n\n    #[test]\n    fn test_new() {\n        let constants = Constants.constants();\n        assert!(constants.len() \u003e= 9);\n        // assert_eq!(common.constants().constant().len(), 9);\n    }\n\n    #[test]\n    fn test_constants() {\n        let constants = Constants.constants();\n        assert!(constants.len() \u003e= 9);\n    }\n\n    #[test]\n    fn test_words() {\n        let common = Common::new();\n        let words = common.words();\n        assert_eq!(words.words_list().len(), 4096);\n    }\n\n    #[test]\n    fn test_default() {\n        let common = Common::default();\n        assert_eq!(common.constants().constants().len(), 9);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","tests","constants.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate cmn;\n    pub use cmn::Constants;\n\n    #[test]\n    fn test_constant() {\n        let constants = Constants.constants();\n        for constant in constants {\n            println!(\"Name: {} Value: {}\", constant.name, constant.value);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","cmn","tests","words.rs"],"content":"#[cfg(test)]\nmod tests {\n    pub use cmn::Words;\n\n    #[test]\n    fn test_words_list() {\n        let words = Words::new();\n        let words_list = words.words_list();\n        assert_eq!(words_list[0], \"aboard\");\n        assert_eq!(words_list[1], \"abode\");\n        assert_eq!(words_list[2], \"abort\");\n    }\n\n    #[test]\n    fn test_default_words() {\n        let words = Words::default();\n        let words_list = words.words_list();\n        assert_eq!(words_list[0], \"aboard\");\n        assert_eq!(words_list[1], \"abode\");\n        assert_eq!(words_list[2], \"abort\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","benches","dtt.rs"],"content":"extern crate criterion;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nextern crate dtt;\nuse self::dtt::DateTime;\n\nfn new_date(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| b.iter(|| DateTime::new));\n}\n\nfn new_day(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"day\", move |b| b.iter(|| date.day));\n}\n\nfn new_hour(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"hour\", move |b| b.iter(|| date.hour));\n}\n\nfn new_iso_8601(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"iso_8601\", move |b| b.iter(|| date.iso_8601.to_owned()));\n}\nfn new_iso_week(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"iso_week\", move |b| b.iter(|| date.iso_week));\n}\nfn new_minute(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"minute\", move |b| b.iter(|| date.minute));\n}\n\nfn new_month(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"month\", move |b| b.iter(|| date.month.to_owned()));\n}\nfn new_offset(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"offset\", move |b| b.iter(|| date.offset.to_owned()));\n}\nfn new_ordinal(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"ordinal\", move |b| b.iter(|| date.ordinal));\n}\nfn new_second(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"second\", move |b| b.iter(|| date.second));\n}\nfn new_time(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"time\", move |b| b.iter(|| date.time.to_owned()));\n}\nfn new_weekday(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"weekday\", move |b| b.iter(|| date.weekday.to_owned()));\n}\n\nfn new_year(c: \u0026mut Criterion) {\n    let date = black_box(DateTime::new());\n    c.bench_function(\"year\", move |b| b.iter(|| date.year));\n}\n\n// fn scalability(c: \u0026mut Criterion) {\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 10],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 100],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 1000],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 10000],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n//     c.bench_function(\"scalability\", |b| {\n//         b.iter_with_setup(\n//             || vec![DateTime::new(); 100000],\n//             |dates| {\n//                 for date in \u0026dates {\n//                     date.year;\n//                     date.iso_week;\n//                 }\n//             },\n//         );\n//     });\n// }\n\ncriterion_group!(\n    benches,\n    new_date,\n    new_day,\n    new_hour,\n    new_iso_8601,\n    new_iso_week,\n    new_minute,\n    new_month,\n    new_offset,\n    new_ordinal,\n    new_second,\n    new_time,\n    new_weekday,\n    new_year,\n    // scalability\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","examples","dtt.rs"],"content":"extern crate dtt;\nuse self::dtt::DateTime;\n\npub fn main() {\n    let date = DateTime::new();\n    println!(\"ðŸ¦€ Date:              âœ… {}\", date.now);\n    println!(\"ðŸ¦€ Day:               âœ… {}\", date.day);\n    println!(\"ðŸ¦€ Hour:              âœ… {}\", date.hour);\n    println!(\"ðŸ¦€ ISO 8601:          âœ… {}\", date.iso_8601);\n    println!(\"ðŸ¦€ ISO Week Number:   âœ… {}\", date.iso_week);\n    println!(\"ðŸ¦€ Minute:            âœ… {}\", date.minute);\n    println!(\"ðŸ¦€ Month:             âœ… {}\", date.month);\n    println!(\"ðŸ¦€ Offset:            âœ… {}\", date.offset);\n    println!(\"ðŸ¦€ Ordinal Date:      âœ… {}\", date.ordinal);\n    println!(\"ðŸ¦€ Second:            âœ… {}\", date.second);\n    println!(\"ðŸ¦€ Microsecond:       âœ… {}\", date.microsecond);\n    println!(\"ðŸ¦€ Time:              âœ… {}\", date.time);\n    println!(\"ðŸ¦€ Weekday:           âœ… {}\", date.weekday);\n    println!(\"ðŸ¦€ Year:              âœ… {}\", date.year);\n\n    println!(\n        \"ðŸ¦€ Invalid day (32):       âŒ {}\",\n        DateTime::is_valid_day(\"32\")\n    );\n    println!(\n        \"ðŸ¦€ Valid day:         âœ… {}\",\n        DateTime::is_valid_day(\u0026date.day.to_string())\n    );\n    println!(\n        \"ðŸ¦€ Invalid hour (24):      âŒ {}\",\n        DateTime::is_valid_hour(\"24\")\n    );\n    println!(\n        \"ðŸ¦€ Valid hour:        âœ… {}\",\n        DateTime::is_valid_hour(\u0026date.hour.to_string())\n    );\n    // println!(\n    //     \"ðŸ¦€ Invalid month:     âŒ {}\",\n    //     DateTime::is_valid_month(\"13\")\n    // );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for parsing, validating, manipulating, and formatting dates and times\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-dtt.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/dtt.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/dtt)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/dtt)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/dtt)\n//! [![License](https://img.shields.io/crates/l/dtt.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The DateTime (DTT) library is a comprehensive and flexible tool that\n//! enables developers to manage dates and times with ease. It provides\n//! drop-in replacement methods for parsing, validating, manipulating,\n//! and formatting dates and times in Rust.\n//!\n//! The [**`DateTime`**](./struct.DateTime.html) type to represent a\n//! date and a time in a defined timezone.\n//!\n//! ## Features\n//!\n//! - Day of the month: (1-31),\n//! - Hour of the day: (0-23),\n//! - ISO 8601 date and time: (e.g. \"2023-01-01T00:00:00+00:00\"),\n//! - ISO week number: (1-53),\n//! - Microsecond: (0-999999),\n//! - Minute of the hour: (0-59),\n//! - Month: (e.g. \"January\"),\n//! - Now object: (e.g. \"2023-01-01\"),\n//! - Offset from UTC: (e.g. \"+00:00\"),\n//! - Ordinal date: (1-366),\n//! - Second of the minute: (0-59),\n//! - Time object: (e.g. \"00:00:00\"),\n//! - Tz object: (e.g. \"UTC\"),\n//! - Weekday object: (e.g. \"Monday\"),\n//! - Year object: (e.g. \"2023\"),\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! ## Examples\n//!\n//! ```rust\n//!\n//! extern crate dtt;\n//! use self::dtt::DateTime;\n//!\n//! let dt = DateTime::new();\n//! println!(\"Date: {}\", dt.now);\n//! println!(\"Day: {}\", dt.day);\n//! println!(\"Hour: {}\", dt.hour);\n//! println!(\"ISO 8601: {}\", dt.iso_8601);\n//! println!(\"ISO Week Number: {}\", dt.iso_week);\n//! println!(\"Minute: {}\", dt.minute);\n//! println!(\"Month: {}\", dt.month);\n//! println!(\"Offset: {}\", dt.offset);\n//! println!(\"Ordinal Date: {}\", dt.ordinal);\n//! println!(\"Second: {}\", dt.second);\n//! println!(\"Time: {}\", dt.time);\n//! println!(\"Weekday: {}\", dt.weekday);\n//! println!(\"Year: {}\", dt.year);\n//!\n//! ```\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-dtt.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-dtt.svg\",\n    html_root_url = \"https://docs.rs/dtt\"\n)]\n#![crate_name = \"dtt\"]\n#![crate_type = \"lib\"]\n\nextern crate serde;\n\npub use serde::{Deserialize, Serialize};\n\nextern crate time;\nuse time::{Duration, OffsetDateTime};\n\nextern crate regex;\nuse regex::Regex;\n\n/// # DateTime\n///\n/// [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/claims)\n/// [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n///\n/// DateTime struct to ease dates and times manipulation.\n///\n/// This module includes date and time types, such as day, hour,ISO 8601\n/// date and time, and many more methods.\n///\n#[derive(Clone, Debug, Default, Deserialize, PartialEq, Serialize)]\npub struct DateTime {\n    /// Day of the month: (1-31)\n    pub day: u8,\n    /// Hour of the day: (0-23)\n    pub hour: u8,\n    /// ISO 8601 date and time: (e.g. \"2023-01-01T00:00:00+00:00\")\n    pub iso_8601: String,\n    /// ISO week number: (1-53)\n    pub iso_week: u8,\n    /// Microsecond: (0-999999)\n    pub microsecond: u32,\n    /// Minute of the hour: (0-59)\n    pub minute: u8,\n    /// Month: (e.g. \"January\")\n    pub month: String,\n    /// Now object: (e.g. \"2023-01-01\")\n    pub now: String,\n    /// Offset from UTC: (e.g. \"+00:00\")\n    pub offset: String,\n    /// Ordinal date: (1-366)\n    pub ordinal: u16,\n    /// Second of the minute: (0-59)\n    pub second: u8,\n    /// Time object: (e.g. \"00:00:00\")\n    pub time: String,\n    /// Tz object: (e.g. \"UTC\")\n    pub tz: String,\n    /// Weekday object: (e.g. \"Monday\")\n    pub weekday: String,\n    /// Year object: (e.g. \"2023\")\n    pub year: i32,\n}\n\nimpl DateTime {\n    /// Create a new Date object with UTC timezone.\n    pub fn new() -\u003e Self {\n        Self::new_with_tz(\"UTC\")\n    }\n\n    /// Create a new DateTime object with a custom timezone.\n    pub fn new_with_tz(tz: \u0026str) -\u003e Self {\n        let offset = match tz {\n            \"UTC\" =\u003e time::UtcOffset::UTC,\n            _ =\u003e time::UtcOffset::from_hms(0, 0, 0).unwrap(),\n        };\n        let now_utc = if tz == \"UTC\" {\n            OffsetDateTime::now_utc()\n        } else {\n            let (hours, minutes, _) = offset.as_hms();\n            let total_seconds = (hours as i16 * 3600) + (minutes as i16 * 60);\n            OffsetDateTime::now_utc() + Duration::seconds(total_seconds as i64)\n        };\n        let iso_8601 = now_utc.to_string();\n\n        Self {\n            day: now_utc.day(),\n            hour: now_utc.hour(),\n            iso_8601,\n            iso_week: now_utc.iso_week(),\n            microsecond: now_utc.microsecond(),\n            minute: now_utc.minute(),\n            month: now_utc.month().to_string(),\n            now: now_utc.date().to_string(),\n            offset: now_utc.offset().to_string(),\n            ordinal: now_utc.ordinal(),\n            second: now_utc.second(),\n            time: now_utc.time().to_string(),\n            tz: now_utc.time().to_string(),\n            weekday: now_utc.weekday().to_string(),\n            year: now_utc.year(),\n        }\n    }\n    /// Check if the input is a valid day.\n    /// 31 is valid.\n    /// 32 is not valid.\n    pub fn is_valid_day(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(day) = input.parse::\u003cu8\u003e() {\n            if (1..=31).contains(\u0026day) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid hour.\n    /// 23:59 is valid.\n    /// 24:00 is not valid.\n    pub fn is_valid_hour(input: \u0026str) -\u003e bool {\n        let re: Regex = Regex::new(r\"^([0-1][0-9]|2[0-3])(:[0-5][0-9])?$\").unwrap();\n        re.is_match(input)\n    }\n    /// Check if the input is a valid ISO 8601 date and time.\n    /// 2023-01-01T00:00:00+00:00 is valid.\n    /// 2023-01-01T00:00:00+00:00:00 is not valid.\n    pub fn is_valid_iso_8601(input: \u0026str) -\u003e bool {\n        let re = Regex::new(\n            r\"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.\\d+)?(Z|[+-]\\d{2}:\\d{2})$\",\n        )\n        .unwrap();\n        if !re.is_match(input) {\n            return false;\n        }\n        let captures = re.captures(input).unwrap();\n        // let year = captures[1].parse::\u003ci32\u003e().unwrap();\n        let month = captures[2].parse::\u003cu32\u003e().unwrap();\n        let day = captures[3].parse::\u003cu32\u003e().unwrap();\n        let hour = captures[4].parse::\u003cu32\u003e().unwrap();\n        let minute = captures[5].parse::\u003cu32\u003e().unwrap();\n        let second = captures[6].parse::\u003cu32\u003e().unwrap();\n        let tz = captures[7].to_string();\n        if !(1..=12).contains(\u0026month)\n            || !(1..=31).contains(\u0026day)\n            || hour \u003e= 24\n            || minute \u003e= 60\n            || second \u003e= 60\n        {\n            return false;\n        }\n        if tz != \"Z\" {\n            let re = Regex::new(r\"^[+-](\\d{2}):(\\d{2})$\").unwrap();\n            let captures = re.captures(\u0026tz).unwrap();\n            let tz_hour = captures[1].parse::\u003ci32\u003e().unwrap();\n            let tz_minute = captures[2].parse::\u003ci32\u003e().unwrap();\n            if !(0..=23).contains(\u0026tz_hour) || !(0..=59).contains(\u0026tz_minute) {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// Check if the input is a valid ISO week number.\n    /// 53 is valid.\n    /// 54 is not valid.\n    pub fn is_valid_iso_week(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(iso_week) = input.parse::\u003cu8\u003e() {\n            if (1..=53).contains(\u0026iso_week) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid microsecond.\n    /// 999999 is valid.\n    /// 1000000 is not valid.\n    pub fn is_valid_microsecond(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(microsecond) = input.parse::\u003cu32\u003e() {\n            if (0..=999999).contains(\u0026microsecond) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid minute.\n    /// 59 is valid.\n    /// 60 is not valid.\n    pub fn is_valid_minute(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(minute) = input.parse::\u003cu8\u003e() {\n            if (0..=59).contains(\u0026minute) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid month.\n    /// 12 is valid.\n    /// 13 is not valid.\n    pub fn is_valid_month(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(month) = input.parse::\u003cu8\u003e() {\n            if (1..=12).contains(\u0026month) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid ordinal date.\n    /// 366 is valid.\n    /// 367 is not valid.\n    pub fn is_valid_ordinal(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(ordinal) = input.parse::\u003cu16\u003e() {\n            if (1..=366).contains(\u0026ordinal) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid second.\n    /// 59 is valid.\n    /// 60 is not valid.\n    pub fn is_valid_second(input: \u0026str) -\u003e bool {\n        let mut valid = false;\n        if let Ok(second) = input.parse::\u003cu8\u003e() {\n            if (0..=59).contains(\u0026second) {\n                valid = true;\n            }\n        }\n        valid\n    }\n    /// Check if the input is a valid time.\n    /// 23:59:59 is valid.\n    /// 24:00:00 is not valid.\n    pub fn is_valid_time(input: \u0026str) -\u003e bool {\n        let re = Regex::new(r\"^([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$\").unwrap();\n        re.is_match(input)\n    }\n}\n\nimpl std::fmt::Display for DateTime {\n    /// Display the date and time in ISO 8601 format.\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Year: {}\\nMonth: {}\\nDay: {}\\nWeekday: {}\\nHour: {}\\nMinute: {}\\nSecond: {}\\nMicrosecond: {}\\nOrdinal: {}\\nIso 8601: {}\\nIso Week: {}\\nTime: {}\\nTZ: {}\\nOffset: {}\\nNow: {}\", self.year, self.month, self.day, self.weekday, self.hour, self.minute, self.second, self.microsecond, self.ordinal, self.iso_8601, self.iso_week, self.time, self.tz, self.offset, self.now)\n    }\n}\n\n/// Generates a function with the given name `$name` that checks whether\n/// a string `input` can be parsed into a value of type `$type`.\n///\n/// # Examples\n///\n/// ```rust\n///\n/// extern crate dtt;\n/// use dtt::is_valid;\n///\n/// is_valid!(day, u32);\n/// let input = \"31\";\n/// let result = day(input);\n/// assert!(result);\n///\n/// ```\n#[macro_export]\nmacro_rules! is_valid {\n    ($name:ident, $type:ty) =\u003e {\n        fn $name(input: \u0026str) -\u003e bool {\n            let mut valid = false;\n            if let Ok(_input) = input.parse::\u003c$type\u003e() {\n                valid = true;\n            }\n            valid\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","dtt","tests","dtt.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n\n    extern crate dtt;\n    use dtt::{is_valid, DateTime};\n\n    extern crate time;\n    use time::{Duration, OffsetDateTime};\n\n    #[test]\n    fn test_new() {\n        let date = DateTime::new();\n        assert!(!date.now.is_empty());\n        assert!(date.day \u003c= 31);\n        assert!(date.hour \u003c= 23);\n        assert!(!date.iso_8601.is_empty());\n        assert!(date.iso_week \u003e 0 \u0026\u0026 date.iso_week \u003c= 53);\n        assert!(date.minute \u003c= 59);\n        assert!(!date.month.is_empty());\n        assert!(!date.offset.is_empty());\n        assert!(date.ordinal \u003e 0 \u0026\u0026 date.ordinal \u003c= 366);\n        assert!(date.second \u003c= 59);\n        assert!(!date.time.is_empty());\n        assert!(!date.weekday.is_empty());\n        assert!(date.year \u003e 0);\n    }\n    #[test]\n    fn test_is_valid_day() {\n        assert!(!DateTime::is_valid_day(\"32\"));\n        assert!(DateTime::is_valid_day(\"31\"));\n    }\n    #[test]\n    fn test_is_valid_hour() {\n        assert!(DateTime::is_valid_hour(\"23\"));\n        assert!(DateTime::is_valid_hour(\"23:59\"));\n        assert!(!DateTime::is_valid_hour(\"24:00\"));\n    }\n    #[test]\n    fn test_valid_iso_8601() {\n        assert!(DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00Z\"));\n        assert!(DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00+01:00\"));\n        assert!(DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00.123456Z\"));\n        assert!(DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456+01:00\"\n        ));\n    }\n\n    #[test]\n    fn test_invalid_iso_8601() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25 17:30:00Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00+25:00\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-06-25T17:30:00+01:61\"));\n    }\n\n    #[test]\n    fn test_month_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-13-25T17:30:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-00-25T17:30:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_day_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-32T17:30:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-00T17:30:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_hour_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T24:30:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T-1:30:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_minute_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:60:00.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:-1:00.1234567Z\"));\n    }\n\n    #[test]\n    fn test_second_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:59:60.1234567Z\"));\n        assert!(!DateTime::is_valid_iso_8601(\"2022-12-31T23:59:-1.1234567Z\"));\n    }\n    #[test]\n    fn test_tz_out_of_range() {\n        assert!(!DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456Z+25:00\"\n        ));\n        assert!(!DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456Z+24:61\"\n        ));\n        assert!(!DateTime::is_valid_iso_8601(\n            \"2022-06-25T17:30:00.123456Z+99:59\"\n        ));\n    }\n    #[test]\n    fn test_update_date() {\n        let date = DateTime::new();\n        let date_before_update = date.now.clone();\n        assert_eq!(date_before_update, date.now);\n    }\n\n    #[test]\n    fn test_update_day() {\n        let date = DateTime::new();\n        let day_before_update = date.day;\n        assert_eq!(day_before_update, date.day);\n        assert!(date.day \u003c= 31);\n    }\n\n    #[test]\n    fn test_update_hour() {\n        let date = DateTime::new();\n        let hour_before_update = date.hour;\n        assert_eq!(hour_before_update, date.hour);\n        assert!(date.hour \u003c= 23);\n    }\n\n    #[test]\n    fn test_update_iso_8601() {\n        let date = DateTime::new();\n        let iso_8601_before_update = date.iso_8601.clone();\n        assert_eq!(iso_8601_before_update, date.iso_8601);\n    }\n\n    #[test]\n    fn test_update_iso_week() {\n        let date = DateTime::new();\n        let iso_week_before_update = date.iso_week;\n        assert_eq!(iso_week_before_update, date.iso_week);\n        assert!(date.iso_week \u003c= 53);\n    }\n\n    #[test]\n    fn test_update_minute() {\n        let date = DateTime::new();\n        let minute_before_update = date.minute;\n        assert_eq!(minute_before_update, date.minute);\n        assert!(date.minute \u003c= 59);\n    }\n\n    #[test]\n    fn test_update_month() {\n        let date = DateTime::new();\n        let month_before_update = date.month.clone();\n        assert_eq!(month_before_update, date.month);\n    }\n\n    #[test]\n    fn test_update_offset() {\n        let date = DateTime::new();\n        let offset_before_update = date.offset.clone();\n        assert_eq!(offset_before_update, date.offset);\n    }\n\n    #[test]\n    fn test_update_ordinal() {\n        let date = DateTime::new();\n        let ordinal_before_update = date.ordinal;\n        assert_eq!(ordinal_before_update, date.ordinal);\n        assert!(date.ordinal \u003e 0 \u0026\u0026 date.ordinal \u003c= 366);\n    }\n    #[test]\n    fn test_update_second() {\n        let date = DateTime::new();\n        let second_before_update = date.second;\n        assert_eq!(second_before_update, date.second);\n        assert!(date.second \u003c= 59);\n    }\n    #[test]\n    fn test_update_time() {\n        let date = DateTime::new();\n        let time_before_update = date.time.clone();\n        assert_eq!(time_before_update, date.time);\n    }\n\n    #[test]\n    fn test_update_weekday() {\n        let date = DateTime::new();\n        let weekday_before_update = date.weekday.clone();\n        assert_eq!(weekday_before_update, date.weekday);\n    }\n    #[test]\n    fn test_update_year() {\n        let date = DateTime::new();\n        let year_before_update = date.year;\n        assert_eq!(year_before_update, date.year);\n        assert!(date.year \u003e 0);\n    }\n    #[test]\n    fn test_new_with_tz_utc() {\n        let date_time = DateTime::new_with_tz(\"UTC\");\n        let offset = time::UtcOffset::UTC;\n\n        let now_utc = OffsetDateTime::now_utc();\n        let (hours, minutes, _) = offset.as_hms();\n        let total_seconds = (hours as i16 * 3600) + (minutes as i16 * 60);\n        let expected_date_time = now_utc + Duration::seconds(total_seconds as i64);\n\n        assert_eq!(date_time.hour, expected_date_time.hour());\n        assert_eq!(date_time.minute, expected_date_time.minute());\n        assert_eq!(date_time.offset, expected_date_time.offset().to_string());\n    }\n    #[test]\n    fn test_new_with_tz_custom() {\n        let date_time = DateTime::new_with_tz(\"Custom\");\n        let offset = time::UtcOffset::from_hms(0, 0, 0).unwrap();\n\n        let now_utc = OffsetDateTime::now_utc();\n        let (hours, minutes, _) = offset.as_hms();\n        let total_seconds = (hours as i16 * 3600) + (minutes as i16 * 60);\n        let expected_date_time = now_utc + Duration::seconds(total_seconds as i64);\n\n        assert_eq!(date_time.hour, expected_date_time.hour());\n        assert_eq!(date_time.minute, expected_date_time.minute());\n        assert_eq!(date_time.offset, expected_date_time.offset().to_string());\n    }\n    #[test]\n    fn test_new_with_tz_to_paris() {\n        let date = DateTime::new_with_tz(\"Europe/Paris\");\n        assert!(!date.now.is_empty());\n        assert!(date.day \u003c= 31);\n        assert!(date.hour \u003c= 23);\n        assert!(!date.iso_8601.is_empty());\n        assert!(date.iso_week \u003e 0 \u0026\u0026 date.iso_week \u003c= 53);\n        assert!(date.minute \u003c= 59);\n        assert!(!date.month.is_empty());\n        assert!(!date.offset.is_empty());\n        assert!(date.ordinal \u003e 0 \u0026\u0026 date.ordinal \u003c= 366);\n        assert!(date.second \u003c= 59);\n        assert!(!date.time.is_empty());\n        assert!(!date.weekday.is_empty());\n        assert!(date.year \u003e 0);\n    }\n    #[test]\n    fn test_is_valid() {\n        is_valid!(day, u32);\n        let input = \"31\";\n        let result = day(input);\n        assert!(result);\n    }\n    #[test]\n    fn test_display_format() {\n        let date_time = DateTime::new();\n        let formatted = format!(\"{date_time}\");\n\n        assert!(formatted.starts_with(\"Year:\"));\n        assert!(formatted.contains(\"Month:\"));\n        assert!(formatted.contains(\"Day:\"));\n        assert!(formatted.contains(\"Weekday:\"));\n        assert!(formatted.contains(\"Hour:\"));\n        assert!(formatted.contains(\"Minute:\"));\n        assert!(formatted.contains(\"Second:\"));\n        assert!(formatted.contains(\"Microsecond:\"));\n        assert!(formatted.contains(\"Ordinal:\"));\n        assert!(formatted.contains(\"Iso 8601:\"));\n        assert!(formatted.contains(\"Iso Week:\"));\n        assert!(formatted.contains(\"Time:\"));\n        assert!(formatted.contains(\"TZ:\"));\n        assert!(formatted.contains(\"Offset:\"));\n        assert!(formatted.contains(\"Now:\"));\n    }\n    #[test]\n    fn test_is_valid_iso_week() {\n        assert!(DateTime::is_valid_iso_week(\"53\"));\n        assert!(!DateTime::is_valid_iso_week(\"54\"));\n        assert!(!DateTime::is_valid_iso_week(\"a\"));\n    }\n\n    #[test]\n    fn test_is_valid_microsecond() {\n        assert!(DateTime::is_valid_microsecond(\"999999\"));\n        assert!(!DateTime::is_valid_microsecond(\"1000000\"));\n        assert!(!DateTime::is_valid_microsecond(\"b\"));\n    }\n\n    #[test]\n    fn test_is_valid_minute() {\n        assert!(DateTime::is_valid_minute(\"59\"));\n        assert!(!DateTime::is_valid_minute(\"60\"));\n        assert!(!DateTime::is_valid_minute(\"c\"));\n    }\n\n    #[test]\n    fn test_is_valid_month() {\n        assert!(DateTime::is_valid_month(\"12\"));\n        assert!(!DateTime::is_valid_month(\"13\"));\n        assert!(!DateTime::is_valid_month(\"d\"));\n    }\n\n    #[test]\n    fn test_is_valid_ordinal() {\n        assert!(DateTime::is_valid_ordinal(\"366\"));\n        assert!(!DateTime::is_valid_ordinal(\"367\"));\n        assert!(!DateTime::is_valid_ordinal(\"e\"));\n    }\n\n    #[test]\n    fn test_is_valid_second() {\n        assert!(DateTime::is_valid_second(\"59\"));\n        assert!(!DateTime::is_valid_second(\"60\"));\n        assert!(!DateTime::is_valid_second(\"f\"));\n    }\n    #[test]\n    fn test_is_valid_time() {\n        assert!(DateTime::is_valid_time(\"23:59:59\"));\n        assert!(!DateTime::is_valid_time(\"24:00:00\"));\n        assert!(!DateTime::is_valid_time(\"g\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","benches","hsh.rs"],"content":"use blake3::Hasher;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse hsh::Hash;\n\nfn generate_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"generate_hash\", |b| {\n        let mut hasher = Hasher::new();\n        let password = \"password\";\n        b.iter(|| {\n            hasher.update(password.as_bytes());\n            hasher.finalize();\n        });\n    });\n}\n\nfn hash_entropy(c: \u0026mut Criterion) {\n    let mut hash_struct = Hash::new();\n    hash_struct.set_password(\"password\");\n    hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n    c.bench_function(\"hash_entropy\", |b| {\n        b.iter(|| {\n            black_box(\u0026hash_struct).entropy();\n        });\n    });\n}\n\nfn verify_password(c: \u0026mut Criterion) {\n    let mut hash_struct = Hash::new();\n    hash_struct.set_password(\"password\");\n    hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n    c.bench_function(\"verify_password\", |b| {\n        let hash = \"abcdefghijklmnopqrstuvwxyz\";\n        let password = \"password\";\n        b.iter(|| {\n            black_box(hash_struct.verify(hash, password));\n        });\n    });\n}\n\nfn bench_generate_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"generate_hash\", |b| {\n        let password = \"password\";\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(password);\n        b.iter(|| {\n            hash_struct.generate_hash();\n        });\n    });\n}\n\nfn bench_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"hash\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n        b.iter(|| {\n            black_box(hash_struct.hash());\n        });\n    });\n}\n\nfn bench_hash_length(c: \u0026mut Criterion) {\n    c.bench_function(\"hash_length\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n        b.iter(|| {\n            black_box(hash_struct.hash_length());\n        });\n    });\n}\n\nfn bench_new(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| {\n        b.iter(|| {\n            Hash::new();\n        });\n    });\n}\n\nfn bench_password(c: \u0026mut Criterion) {\n    c.bench_function(\"password\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        b.iter(|| {\n            black_box(hash_struct.password());\n        });\n    });\n}\n\nfn bench_password_length(c: \u0026mut Criterion) {\n    c.bench_function(\"password_length\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        b.iter(|| {\n            black_box(hash_struct.password_length());\n        });\n    });\n}\n\nfn bench_set_hash(c: \u0026mut Criterion) {\n    c.bench_function(\"set_hash\", |b| {\n        let mut hash_struct = Hash::new();\n        let hash = \"abcdefghijklmnopqrstuvwxyz\";\n        b.iter(|| {\n            hash_struct.set_hash(hash);\n        });\n    });\n}\n\nfn bench_set_password(c: \u0026mut Criterion) {\n    c.bench_function(\"set_password\", |b| {\n        let mut hash_struct = Hash::new();\n        let password = \"password\";\n        b.iter(|| {\n            hash_struct.set_password(password);\n        });\n    });\n}\n\nfn bench_verify(c: \u0026mut Criterion) {\n    c.bench_function(\"verify\", |b| {\n        let mut hash_struct = Hash::new();\n        hash_struct.set_password(\"password\");\n        hash_struct.set_hash(\"abcdefghijklmnopqrstuvwxyz\");\n        let hash = \"abcdefghijklmnopqrstuvwxyz\";\n        let password = \"password\";\n        b.iter(|| {\n            black_box(hash_struct.verify(hash, password));\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_generate_hash,\n    bench_hash,\n    bench_hash_length,\n    bench_new,\n    bench_password,\n    bench_password_length,\n    bench_set_hash,\n    bench_set_password,\n    bench_verify,\n    generate_hash,\n    hash_entropy,\n    verify_password\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","examples","hsh.rs"],"content":"extern crate hsh;\nuse self::hsh::Hash;\n\nfn main() {\n    let mut hash = Hash::new();\n    let mut default = Hash::default();\n    let is_valid = hash.verify(\n        \"7f2611ba158b6dcea4a69c229c303358c5e04493abeadee106a4bfa464d55787\",\n        \"password\",\n    );\n    hash.set_password(\"password\");\n    default.set_password(\"password\");\n    hash.set_hash(\"1.61803398874989484820\");\n    default.set_hash(\"1.61803398874989484820\");\n\n    println!(\"ðŸ¦€ Hash::new():                âœ… {hash}\");\n    println!(\"ðŸ¦€ Hash::default():            âœ… {default}\");\n    println!(\"ðŸ¦€ Hash::generate_hash():      âœ… {}\", hash.generate_hash());\n    if is_valid {\n        println!(\n            \"ðŸ¦€ Hash::verify():             âœ… {}\",\n            hash.verify(hash.hash(), \"password\")\n        );\n    } else {\n        println!(\"ðŸ¦€ Hash::verify() :            âŒ The password or hash is invalid.\");\n    }\n    println!(\n        \"ðŸ¦€ Hash::set_password():       âœ… {}\",\n        hash.password() == \"password\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::set_hash():           âœ… {}\",\n        hash.hash() == \"1.61803398874989484820\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::password():           âœ… {}\",\n        hash.password() == \"password\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::password_length():    âœ… {}\",\n        hash.password_length() == 8\n    );\n    println!(\n        \"ðŸ¦€ Hash::hash():               âœ… {}\",\n        hash.hash() == \"1.61803398874989484820\"\n    );\n    println!(\n        \"ðŸ¦€ Hash::hash_length():        âœ… {}\",\n        hash.hash_length() == 22\n    );\n    println!(\"ðŸ¦€ Hash::entropy():            âœ… {}\", hash.entropy() \u003e 0.0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Cryptographic Hash Algorithms Library for Rust\n//!\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-hsh.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/hsh.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/hsh)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/hsh)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/hsh)\n//! [![License](https://img.shields.io/crates/l/hsh.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Hash (HSH), is a Cryptographic Hash Algorithms Library for secure\n//! password management.\n//!\n//! Utilizing the cutting-edge [Blake3][11] algorithm, this library\n//! generates and verifies hashed passwords with ease. The library\n//! features a struct for storing and verifying hashed passwords, as\n//! well as a series of methods for calculating entropy, generating\n//! hashes, accessing password and hash values, and more.\n//!\n//! `HSH` also implements the Default and Display traits for flexible\n//! use and easy readability.\n//!\n//! ## Features\n//!\n//! - [x] Hashes passwords using the [blake3](https://crates.io/crates/blake3) crate.\n//! - [x] Verifies passwords against stored hashes.\n//! - [x] Calculates the entropy of the hash in bits based on the Shannon entropy formula.\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-hsh.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-hsh.svg\",\n    html_root_url = \"https://docs.rs/hsh\"\n)]\n#![crate_name = \"hsh\"]\n#![crate_type = \"lib\"]\n\nextern crate blake3;\nuse blake3::Hasher;\n\n/// A struct for storing and verifying hashed passwords based on\n/// the [blake3](https://crates.io/crates/blake3) crate.\n#[non_exhaustive]\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\npub struct Hash {\n    /// The password.\n    pub password: String,\n    /// The password hash.\n    pub hash: String,\n}\n\nimpl Hash {\n    /// Calculates the entropy of the hash in bits based on the Shannon\n    /// entropy formula. \u003chttps://en.wikipedia.org/wiki/Entropy\u003e`\n    pub fn entropy(\u0026self) -\u003e f64 {\n        // Shannon entropy formula in bits.\n        let mut entropy = 0.0;\n        for c in self.hash.chars() {\n            let p = (c as u8) as f64 / 255.0;\n            entropy -= p * p.log2();\n        }\n        entropy\n    }\n\n    /// Hashes the password.\n    pub fn generate_hash(\u0026self) -\u003e String {\n        let mut hasher = Hasher::new();\n        hasher.update(self.password.as_bytes());\n        let hash = hasher.finalize().to_hex();\n        hash.to_string()\n    }\n\n    /// Returns the hash.\n    pub fn hash(\u0026self) -\u003e \u0026str {\n        \u0026self.hash\n    }\n\n    /// Returns the hash length.\n    pub fn hash_length(\u0026self) -\u003e usize {\n        self.hash.len()\n    }\n\n    /// Returns a new instance of `Hash`.\n    pub fn new() -\u003e Self {\n        Self {\n            password: String::default(),\n            hash: String::default(),\n        }\n    }\n\n    /// Returns the password.\n    pub fn password(\u0026self) -\u003e \u0026str {\n        \u0026self.password\n    }\n\n    /// Returns the password length.\n    pub fn password_length(\u0026self) -\u003e usize {\n        self.password.len()\n    }\n\n    /// Sets the hash.\n    pub fn set_hash(\u0026mut self, hash: \u0026str) {\n        self.hash = hash.to_string();\n    }\n\n    /// Sets the password and updates the hash.\n    pub fn set_password(\u0026mut self, password: \u0026str) {\n        self.password = password.to_string();\n        self.hash = self.generate_hash();\n    }\n    /// Verifies the password against the stored hash.\n    ///\n    /// Returns `true` if the password and hash match, `false` otherwise.\n    pub fn verify(\u0026self, hash: \u0026str, password: \u0026str) -\u003e bool {\n        let mut hasher = Hasher::new();\n        hasher.update(password.as_bytes());\n        let password_hash = hasher.finalize().to_hex();\n        let password_hash_str = password_hash.to_string();\n        password_hash_str == hash\n    }\n}\n\nimpl std::fmt::Display for Hash {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Hash {{ password: {}, hash: {} }}\",\n            self.password, self.hash\n        )\n    }\n}\n\nimpl Default for Hash {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","hsh","tests","hsh.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate hsh;\n    use self::hsh::Hash;\n\n    #[test]\n    fn test_hash_fmt() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        hash.set_hash(\"hash\");\n        assert_eq!(format!(\"{hash}\"), \"Hash { password: password, hash: hash }\");\n    }\n\n    #[test]\n    fn test_hash_password() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.password, \"password\");\n    }\n\n    #[test]\n    fn test_hash_hash() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash, \"hash\");\n    }\n\n    #[test]\n    fn test_new() {\n        let hash = Hash::new();\n        assert_eq!(hash.password(), \"\");\n        assert_eq!(hash.hash(), \"\");\n    }\n\n    #[test]\n    fn test_default() {\n        let hash = Hash::default();\n        assert_eq!(hash.password(), \"\");\n        assert_eq!(hash.hash(), \"\");\n    }\n\n    #[test]\n    fn test_generate_hash() {\n        let hash = Hash::new();\n        let hash = hash.generate_hash();\n        assert_eq!(hash.len(), 64);\n    }\n\n    #[test]\n    fn test_verify() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert!(hash.verify(\n            \"7f2611ba158b6dcea4a69c229c303358c5e04493abeadee106a4bfa464d55787\",\n            \"password\",\n        ));\n    }\n\n    #[test]\n    fn test_set_password() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert_eq!(hash.password(), \"password\");\n    }\n    #[test]\n    fn test_set_hash() {\n        let mut hash = Hash::new();\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash(), \"hash\");\n    }\n\n    #[test]\n    fn test_password() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert_eq!(hash.password(), \"password\");\n    }\n    #[test]\n    fn test_password_length() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert_eq!(hash.password_length(), 8);\n    }\n    #[test]\n    fn test_hash() {\n        let mut hash = Hash::new();\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash(), \"hash\");\n    }\n    #[test]\n    fn test_hash_length() {\n        let mut hash = Hash::new();\n        hash.set_hash(\"hash\");\n        assert_eq!(hash.hash_length(), 4);\n    }\n    #[test]\n    fn test_entropy() {\n        let mut hash = Hash::new();\n        hash.set_password(\"password\");\n        assert!(hash.entropy() \u003e 0.0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","benches","idk.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","examples","idk.rs"],"content":"extern crate idk;\nuse idk::common::ErrorType;\n\nfn main() {\n    let error_type = ErrorType::new(\"illegal_argument\");\n    let error_type_new_subtype = error_type.new_subtype(\"subtype\");\n\n    println!(\"ðŸ¦€ Error::error_type_new():             âœ… {error_type:?}\\n\",);\n    println!(\"ðŸ¦€ Error::error_type_new_subtype():        âœ… {error_type_new_subtype:?}\\n\",);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","common.rs"],"content":"/// ErrorType is a struct that holds a name and an Error enum instance\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ErrorType {\n    /// name is a string that holds the name of the error type\n    pub name: String,\n    /// error_type is an instance of the Error enum\n    pub error_type: Error,\n}\n/// Error is an enumeration of different error types\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub enum Error {\n    /// Argument error\n    Argument(String),\n    /// Assertion error\n    Assertion(String),\n    /// Concurrency error\n    Concurrency(String),\n    /// Data error\n    Data(String),\n    /// External error\n    External(String),\n    /// Format error\n    Format(String),\n    /// Implementation error\n    Implementation(String),\n    /// Initialization error\n    Initialization(String),\n    /// Internal error\n    Internal(String),\n    /// Interruption error\n    Interruption(String),\n    /// Operation error\n    Operation(String),\n    /// Rejection error\n    Rejection(String),\n    /// State error\n    State(String),\n    /// Timeout error\n    Timeout(String),\n    /// Unknown error\n    Unknown(String),\n    /// Version error\n    Version(String),\n}\n\nimpl Error {\n    /// new creates a new Error enum instance based on the name\n    pub fn new(err_type: ErrorType) -\u003e Self {\n        match err_type.name.as_str() {\n            \"argument\" =\u003e Error::Argument(String::from(\"Illegal argument\")),\n            \"assertion\" =\u003e Error::Assertion(String::from(\"Assertion failed\")),\n            \"concurrency\" =\u003e Error::Concurrency(String::from(\"Concurrency update\")),\n            \"data\" =\u003e Error::Data(String::from(\"Data unavailable\")),\n            \"external\" =\u003e Error::External(String::from(\"External error\")),\n            \"format\" =\u003e Error::Format(String::from(\"Illegal format\")),\n            \"implementation\" =\u003e Error::Implementation(String::from(\"No implementation\")),\n            \"initialization\" =\u003e Error::Initialization(String::from(\"Initialization failed\")),\n            \"internal\" =\u003e Error::Internal(String::from(\"Internal error\")),\n            \"interruption\" =\u003e Error::Interruption(String::from(\"Interruption occurred\")),\n            \"operation\" =\u003e Error::Operation(String::from(\"Unsupported operation\")),\n            \"rejection\" =\u003e Error::Rejection(String::from(\"Rejection occurred\")),\n            \"state\" =\u003e Error::State(String::from(\"Illegal state\")),\n            \"timeout\" =\u003e Error::Timeout(String::from(\"Timeout elapsed\")),\n            \"version\" =\u003e Error::Version(String::from(\"Unsupported version\")),\n            _ =\u003e Error::Unknown(String::from(\"Unknown error\")),\n        }\n    }\n}\n\nimpl ErrorType {\n    /// new creates a new ErrorType struct instance\n    pub fn new(name: \u0026str) -\u003e ErrorType {\n        ErrorType {\n            name: String::from(name),\n            error_type: Error::new(ErrorType {\n                name: name.to_string(),\n                error_type: Error::Unknown(String::from(name)),\n            }),\n        }\n    }\n    /// new_subtype creates a new ErrorType struct instance\n    pub fn new_subtype(\u0026self, name: \u0026str) -\u003e ErrorType {\n        ErrorType {\n            name: String::from(name),\n            error_type: Error::new(ErrorType {\n                name: name.to_string(),\n                error_type: Error::Unknown(String::from(name)),\n            }),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","error.rs"],"content":"use crate::common::ErrorType;\nuse std::error::Error as StdError;\nuse std::fmt;\n\n#[derive(Debug)]\n/// Error struct for the crate\npub struct Error {\n    /// The error message\n    pub message: String,\n\n    /// The error type\n    pub error_type: ErrorType,\n\n    /// The context of the error\n    pub ctx: String,\n}\n\nimpl Error {\n    /// Create a new error\n    pub fn new(message: \u0026str, error_type: ErrorType) -\u003e Error {\n        Error {\n            message: message.to_owned(),\n            error_type,\n            ctx: \"\".to_owned(),\n        }\n    }\n\n    /// Create a new error type\n    pub fn error_type(name: \u0026str, error_type: ErrorType, ctx: \u0026str) -\u003e Error {\n        Error {\n            message: name.to_owned(),\n            error_type,\n            ctx: ctx.to_owned(),\n        }\n    }\n\n    /// Add context to the error\n    pub fn with_context(mut self, ctx: \u0026str) -\u003e Error {\n        self.ctx = ctx.to_owned();\n        self\n    }\n}\n\nimpl StdError for Error {\n    /// Source of the error\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn StdError + 'static)\u003e {\n        None\n    }\n}\n\nimpl fmt::Display for Error {\n    /// Display the error\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}, ctx: {}\", self.message, self.ctx)\n    }\n}\n\nimpl fmt::Display for ErrorType {\n    /// Display the error type\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.name)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","jwt.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nextern crate base64;\n// extern crate openssl;\nextern crate serde_json;\n\n// use openssl::error::ErrorStack;\n// use self::error::Error;\nuse base64::DecodeError;\nuse hmac::digest::InvalidLength as InvLen;\nuse serde_json::Error as SJError;\nuse std::error::Error;\nuse std::fmt;\nuse std::io::Error as IoError;\n\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n/// Custom error type for JWT. This type is used to represent all\n/// possible errors that can occur when working with JWTs. It is\n/// implemented as an enum with variants for each possible error. It\n/// also implements the `Default`, `Display`, and `Error` traits.\npub enum JwtError {\n    /// The Audience is invalid.\n    AudienceInvalid(String),\n\n    /// Decode error.\n    DecodeError(String),\n\n    /// Expiration is invalid.\n    ExpirationInvalid(String),\n\n    /// Format is invalid\n    FormatInvalid(String),\n\n    /// Invalid header.\n    InvalidHeader(String),\n\n    /// Invalid payload.\n    InvalidPayload(String),\n\n    /// Invalid signature\n    InvalidSignature(String),\n\n    /// Invalid length\n    InvalidLength(String),\n\n    /// IO error.\n    IoError(String),\n\n    /// Issuer is invalid.\n    IssuerInvalid(String),\n\n    /// JWT is invalid.\n    JWTInvalid(String),\n\n    /// Open SSL error.\n    OpenSslError(String),\n\n    /// Protocol error.\n    ProtocolError(String),\n\n    /// Signature is expired.\n    SignatureExpired(String),\n\n    /// Signature is invalid.\n    SignatureInvalid(String),\n\n    /// Token not found.\n    TokenNotFound(String),\n}\n\nimpl Error for JwtError {}\n\nimpl fmt::Display for JwtError {\n    /// The formatted error.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            JwtError::AudienceInvalid(err) =\u003e write!(f, \"Audience Invalid Error: {err}\"),\n            JwtError::ExpirationInvalid(err) =\u003e write!(f, \"Expiration Invalid Error: {err}\"),\n            // implement display for other variants as well\n            _ =\u003e write!(f, \"Unknown error\"),\n        }\n    }\n}\n\nimpl From\u003cDecodeError\u003e for JwtError {\n    /// Converts a `DecodeError` to a `JwtError`.\n    fn from(error: DecodeError) -\u003e Self {\n        JwtError::DecodeError(error.to_string())\n    }\n}\n\nimpl From\u003cSJError\u003e for JwtError {\n    fn from(error: SJError) -\u003e Self {\n        JwtError::InvalidPayload(error.to_string())\n    }\n}\n\nimpl From\u003cInvLen\u003e for JwtError {\n    fn from(error: InvLen) -\u003e Self {\n        JwtError::InvalidLength(error.to_string())\n    }\n}\n\n// impl From\u003cErrorStack\u003e for JwtError {\n//     fn from(error: ErrorStack) -\u003e Self {\n//         JwtError::OpenSslError(error.to_string())\n//     }\n// }\n\nimpl From\u003cIoError\u003e for JwtError {\n    fn from(error: IoError) -\u003e Self {\n        JwtError::IoError(error.to_string())\n    }\n}\n\nimpl JwtError {\n    /// Returns `true` if the error is a signature error.\n    pub fn is_signature_error(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            JwtError::SignatureExpired(_) | JwtError::SignatureInvalid(_)\n        )\n    }\n\n    /// Returns `true` if the error is a JWT error.\n    pub fn is_jwt_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::JWTInvalid(_))\n    }\n\n    /// Returns `true` if the error is an issuer error.\n    pub fn is_issuer_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::IssuerInvalid(_))\n    }\n\n    /// Returns `true` if the error is an expiration error.\n    pub fn is_expiration_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::ExpirationInvalid(_))\n    }\n\n    /// Returns `true` if the error is an audience error.\n    pub fn is_audience_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::AudienceInvalid(_))\n    }\n\n    /// Returns `true` if the error is a format error.\n    pub fn is_format_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::FormatInvalid(_))\n    }\n\n    /// Returns `true` if the error is a header error.\n    pub fn is_invalid_length_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::InvalidLength(_))\n    }\n\n    /// Returns `true` if the error is an IO error.\n    pub fn is_io_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::IoError(_))\n    }\n\n    /// Returns `true` if the error is an Open SSL error.\n    pub fn is_openssl_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::OpenSslError(_))\n    }\n\n    /// Returns `true` if the error is a protocol error.\n    pub fn is_protocol_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::ProtocolError(_))\n    }\n    /// Returns `true` if the error is a token not found error.\n    pub fn is_token_not_found_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::TokenNotFound(_))\n    }\n    /// Returns `true` if the error is an invalid base 64.\n    pub fn is_base64_error(\u0026self) -\u003e bool {\n        matches!(self, JwtError::DecodeError(_))\n    }\n}\n\n// Implementation of `Default` for `Error` to provide a default error.\nimpl Default for JwtError {\n    fn default() -\u003e Self {\n        Self::SignatureExpired(\"Signature expired.\".to_owned())\n    }\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":40},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for managing errors and exceptions\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-idk.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/idk.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/idk)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/idk)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/tree/main/idk)\n//! [![License](https://img.shields.io/crates/l/idk.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! IDontKnow (IDK) is a Rust library that has functions and variables\n//! designed to make it easy for your program to report informative\n//! error messages. You can use the IDK library to create error messages\n//! that are clear, concise, and actionable.\n//!\n//! ## Features\n//!\n//! The library includes multiple modules: `Common`, `Error`, `Jwt`,\n//! `Property`, `Stacktrace`, and `Traits`.\n//!\n//! - **The common module:** This module provides a foundation of common\n//! functionalities that can be utilized throughout the entire project.\n//! These functionalities serve as a building block for the rest of the\n//! project, making it easier for developers to create and manage their\n//! code.\n//! - **The error module:** This module contains all the error types\n//! that are used in the project. By providing a centralized location\n//! for errors, developers can quickly and easily identify and resolve\n//! any issues that may arise.\n//! - **The jwt module:** This module offers the tools necessary to\n//! encode and decode JSON Web Tokens (JWT). With a simple, easy-to-use\n//! interface, developers can ensure secure communication between\n//! parties.\n//! - **The property module:** This module provides the functionality to\n//! create and manage properties. By utilizing this module, developers\n//! can keep track of all properties within the project and make changes\n//! as necessary.\n//! - **The stacktrace module:** This module offers the tools to create\n//! and manage stacktraces. By providing detailed information about the\n//! execution of the code, developers can quickly identify and resolve\n//! any issues that may arise.\n//! - **The traits module:** This module provides functionality to\n//! create and manage traits. By utilizing this module, developers can\n//! ensure that all traits within the project are consistent and\n//! well-defined.\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-idk.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-idk.svg\",\n    html_root_url = \"https://docs.rs/idk\"\n)]\n#![crate_name = \"idk\"]\n#![crate_type = \"lib\"]\n\n/// The common module provides common functionality that can be used\n/// throughout the entire crate.\npub mod common;\n\n/// The error module contains all the error types used in the crate.\npub mod error;\n\n/// The jwt module provides functionality to encode and decode\n/// JSON Web Tokens (JWT).\npub mod jwt;\n\n/// The property module provides functionality to create and manage\n/// properties.\npub mod property;\n\n/// The stacktrace module provides functionality to create and manage\n/// stacktraces.\npub mod stacktrace;\n\n/// The traits module provides functionality to create and manage\n/// traits.\npub mod traits;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","property.rs"],"content":"#[derive(Clone, Debug, Ord, PartialEq, PartialOrd, Hash)]\n/// The property of the error.\npub struct Property {\n    /// The label of the property.\n    pub label: String,\n    /// Whether the property is printable.\n    pub printable: bool,\n}\n\nimpl Eq for Property {}\n\nimpl Property {\n    /// Creates a new property.\n    pub fn new(label: \u0026str, printable: bool) -\u003e Property {\n        Property {\n            label: label.to_owned(),\n            printable,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","stacktrace.rs"],"content":"use std::fmt;\n\nconst STACK_TRACE_DEPTH: usize = 128;\n\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n/// The program counter of the stack trace.\npub struct StackTrace {\n    /// The program counter of the stack trace.\n    pub pc: Vec\u003cusize\u003e,\n    /// The cause stack trace of the stack trace.\n    pub cause_stack_trace: Option\u003cBox\u003cStackTrace\u003e\u003e,\n}\n\nimpl StackTrace {\n    /// Formats the stack trace.\n    pub fn format_stack_trace(stack_trace: Vec\u003cString\u003e) -\u003e String {\n        format!(\n            \"Stack trace:\\n{}\",\n            stack_trace\n                .iter()\n                .map(|elem| format!(\"\\t- {elem}\"))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\\n\")\n        )\n    }\n\n    /// Creates a new stack trace.\n    pub fn new() -\u003e StackTrace {\n        let pc = Vec::with_capacity(STACK_TRACE_DEPTH);\n        StackTrace {\n            pc,\n            cause_stack_trace: Some(Box::new(StackTrace {\n                pc: Vec::with_capacity(STACK_TRACE_DEPTH),\n                cause_stack_trace: None,\n            })),\n        }\n    }\n}\n\nimpl Default for StackTrace {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for StackTrace {\n    /// The formatted stack trace.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let stack_trace = self\n            .pc\n            .iter()\n            .map(|\u0026pc| format!(\"{pc:#x}\"))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let formatted_stack_trace = StackTrace::format_stack_trace(stack_trace);\n\n        match \u0026self.cause_stack_trace {\n            Some(cause_stack_trace) =\u003e {\n                write!(f, \"{formatted_stack_trace}\\n{cause_stack_trace}\")\n            }\n            None =\u003e write!(f, \"{formatted_stack_trace}\"),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","src","traits.rs"],"content":"use std::sync::atomic::AtomicU64;\n\nstatic INTERNAL_ID_COUNTER: AtomicU64 = AtomicU64::new(0);\n\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n/// The `Trait` struct with id as a unique identifier and label as a\n/// string representation of the trait.\npub struct Trait {\n    /// The `id` field holds the unique identifier of the trait.\n    pub id: u64,\n    /// The `label` field holds the string representation of the trait.\n    pub label: String,\n}\n\nimpl Trait {\n    /// Creates a new instance of Trait with a unique identifier and the\n    /// given label string.\n    pub fn new(label: \u0026str) -\u003e Self {\n        Trait {\n            id: INTERNAL_ID_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed),\n            label: label.to_string(),\n        }\n    }\n    /// A convenient alias to new().\n    pub fn register_trait(label: \u0026str) -\u003e Trait {\n        Trait::new(label)\n    }\n}\n/// A struct to manage a collection of Trait instances.\npub struct TraitBuilder {\n    /// A vector of Trait instances\n    pub traits: Vec\u003cTrait\u003e,\n}\n\nimpl TraitBuilder {\n    /// Creates a new instance of TraitBuilder.\n    pub fn new() -\u003e Self {\n        TraitBuilder { traits: Vec::new() }\n    }\n    /// Adds a new Trait instance with the given label to the collection.\n    pub fn add_trait(\u0026mut self, label: \u0026str) -\u003e \u0026Trait {\n        let trait_ = Trait::new(label);\n        self.traits.push(trait_);\n        self.traits.last().unwrap()\n    }\n    /// Finds and returns the Trait instance with the given label.\n    pub fn get_trait(\u0026self, label: \u0026str) -\u003e Option\u003c\u0026Trait\u003e {\n        self.traits.iter().find(|t| t.label == label)\n    }\n    /// Deletes the Trait instance with the given label from the\n    /// collection.\n    pub fn delete_trait(\u0026mut self, label: \u0026str) -\u003e bool {\n        let pos = self.traits.iter().position(|t| t.label == label);\n        if let Some(pos) = pos {\n            self.traits.remove(pos);\n            true\n        } else {\n            false\n        }\n    }\n}\n\nimpl Default for TraitBuilder {\n    /// A default implementation of TraitBuilder, creating a new\n    /// instance of TraitBuilder.\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n/// A struct to represent the presence of a Trait instance.\npub struct HasTrait {\n    /// The identifier of the Trait instance.\n    pub trait_id: u64,\n    /// Whether the Trait instance is present.\n    pub has_trait: bool,\n    /// Whether the Trait instance was added.\n    pub add_trait: bool,\n}\nimpl HasTrait {\n    /// Creates a new instance of HasTrait with the given trait_id.\n    pub fn new(trait_id: u64) -\u003e Self {\n        HasTrait {\n            trait_id,\n            has_trait: false,\n            add_trait: false,\n        }\n    }\n    /// Returns true if the HasTrait instance has the given Trait key.\n    pub fn has_trait(\u0026self, key: \u0026Trait) -\u003e bool {\n        self.trait_id == key.id\n    }\n    /// Adds the given Trait key to the HasTrait instance.\n    pub fn add_trait(\u0026mut self, key: \u0026Trait) {\n        self.trait_id = key.id;\n        self.has_trait = true;\n        self.add_trait = true;\n    }\n    /// Removes the given Trait key from the HasTrait instance.\n    pub fn remove_trait(\u0026mut self, key: \u0026Trait) {\n        self.trait_id = key.id;\n        self.has_trait = false;\n        self.add_trait = false;\n    }\n    /// Returns true if the Trait instance was added to the HasTrait\n    /// instance.\n    pub fn is_add_trait(\u0026self) -\u003e bool {\n        self.add_trait\n    }\n    /// Returns true if the HasTrait instance has the Trait instance.\n    pub fn is_has_trait(\u0026self) -\u003e bool {\n        self.has_trait\n    }\n    /// Returns true if the Trait instance was removed from the HasTrait\n    /// instance.\n    pub fn is_remove_trait(\u0026self) -\u003e bool {\n        !self.add_trait\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":38},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","common.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::common::{Error, ErrorType};\n\n    #[test]\n    fn test_error_type_new() {\n        let error_type = ErrorType::new(\"argument\");\n        assert_eq!(error_type.name, \"argument\");\n        match error_type.error_type {\n            Error::Argument(s) =\u003e assert_eq!(s, \"Illegal argument\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn test_error_type_new_subtype() {\n        let error_type = ErrorType::new(\"illegal_argument\");\n        let subtype = error_type.new_subtype(\"subtype\");\n        assert_eq!(subtype.name, \"subtype\");\n        match subtype.error_type {\n            Error::Unknown(s) =\u003e assert_eq!(s, \"Unknown error\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn test_error_type_name() {\n        let error_type = ErrorType::new(\"illegal_argument\");\n        assert_eq!(error_type.name, \"illegal_argument\");\n    }\n\n    #[test]\n    fn test_error_type_error_type() {\n        let error_type = ErrorType::new(\"argument\");\n        match error_type.error_type {\n            Error::Argument(s) =\u003e assert_eq!(s, \"Illegal argument\"),\n            _ =\u003e panic!(\"Unexpected error type\"),\n        }\n    }\n\n    #[test]\n    fn test_new() {\n        let err_type = ErrorType {\n            name: String::from(\"argument\"),\n            error_type: Error::Argument(String::from(\"argument\")),\n        };\n        let err = Error::new(err_type);\n        assert_eq!(err, Error::Argument(String::from(\"Illegal argument\")));\n\n        let err_type = ErrorType {\n            name: String::from(\"operation\"),\n            error_type: Error::Operation(String::from(\"operation\")),\n        };\n        let err = Error::new(err_type);\n        assert_eq!(err, Error::Operation(String::from(\"Unsupported operation\")));\n\n        let err_type = ErrorType {\n            name: String::from(\"unknown_error\"),\n            error_type: Error::Unknown(String::from(\"unknown_error\")),\n        };\n        let err = Error::new(err_type);\n        assert_eq!(err, Error::Unknown(String::from(\"Unknown error\")));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","error.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::{common::ErrorType, error::Error as OtherError};\n    use std::error::Error as StdError;\n\n    #[test]\n    fn test_error_new() {\n        let error_type = ErrorType::new(\"illegal_argument\");\n        let err = OtherError::new(\"message\", error_type);\n        assert_eq!(err.message, \"message\");\n        assert_eq!(err.error_type.name, \"illegal_argument\");\n    }\n    #[test]\n    fn test_with_context() {\n        let error_type = ErrorType::new(\"test_error\");\n        let err =\n            OtherError::with_context(OtherError::new(\"message\", error_type), \"Additional context\");\n        assert_eq!(err.message, \"message\");\n        assert_eq!(err.error_type.name, \"test_error\");\n        assert_eq!(err.ctx, \"Additional context\");\n    }\n\n    #[test]\n    fn test_source() {\n        let error_type = ErrorType::new(\"test_error\");\n        let err = OtherError::new(\"message\", error_type);\n        assert!(StdError::source(\u0026err).is_none());\n    }\n\n    #[test]\n    fn test_display() {\n        let err = OtherError::new(\"Test error\", ErrorType::new(\"test_error\"));\n        let display = format!(\"{err}\");\n        assert_eq!(display, \"Test error, ctx: \");\n    }\n\n    #[test]\n    fn test_display_error_type() {\n        let err_type = ErrorType::new(\"test_error_type\");\n        let display = format!(\"{err_type}\");\n        assert_eq!(display, \"test_error_type\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","jwt.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::jwt::JwtError;\n\n    #[test]\n    fn test_jwt_error() {\n        let jwt_error = JwtError::JWTInvalid(\"JWT is invalid\".to_string());\n        assert!(jwt_error.is_jwt_error());\n        assert!(!jwt_error.is_signature_error());\n        assert!(!jwt_error.is_issuer_error());\n        assert!(!jwt_error.is_expiration_error());\n        assert!(!jwt_error.is_audience_error());\n    }\n    #[test]\n    fn test_jwt_display() {\n        let jwt_audience_error = JwtError::AudienceInvalid(\"Audience is invalid\".to_string());\n        assert!(jwt_audience_error\n            .to_string()\n            .contains(\"Audience is invalid\"));\n\n        let jwt_expiration_invalid =\n            JwtError::ExpirationInvalid(\"Expiration is invalid\".to_string());\n        assert!(jwt_expiration_invalid\n            .to_string()\n            .contains(\"Expiration is invalid\"));\n\n        let jwt_error = JwtError::default();\n        assert_eq!(jwt_error.to_string(), \"Unknown error\");\n    }\n    #[test]\n    fn test_signature_error() {\n        let jwt_error = JwtError::SignatureInvalid(\"Signature is invalid\".to_string());\n        assert!(!jwt_error.is_jwt_error());\n        assert!(jwt_error.is_signature_error());\n        assert!(!jwt_error.is_issuer_error());\n        assert!(!jwt_error.is_expiration_error());\n        assert!(!jwt_error.is_audience_error());\n        assert!(!jwt_error.is_format_error());\n        assert!(!jwt_error.is_invalid_length_error());\n        assert!(!jwt_error.is_io_error());\n        assert!(!jwt_error.is_openssl_error());\n        assert!(!jwt_error.is_protocol_error());\n        assert!(!jwt_error.is_token_not_found_error());\n        assert!(!jwt_error.is_base64_error());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","property.rs"],"content":"#[cfg(test)]\n\nmod tests {\n    extern crate idk;\n    use idk::property::Property;\n\n    #[test]\n    fn test_property_error() {\n        let err = Property::new(\"test\", true);\n        assert_eq!(err.label, \"test\");\n        assert!(err.printable);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","stacktrace.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::stacktrace::StackTrace;\n\n    #[test]\n    fn test_stack_trace_new() {\n        let stack_trace = StackTrace::new();\n        assert_eq!(stack_trace.pc.len(), 0);\n    }\n\n    #[test]\n    fn test_format_stack_trace_default() {\n        let stack_trace = StackTrace::default();\n        assert_eq!(stack_trace.pc.len(), 0);\n    }\n\n    #[test]\n    fn test_display_stack_trace() {\n        let test_display_stack_trace = StackTrace::new();\n        assert!(!test_display_stack_trace.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","idk","tests","traits.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate idk;\n    use idk::traits::{HasTrait, Trait, TraitBuilder};\n\n    #[test]\n    fn test_trait_new() {\n        let trait_test = Trait::new(\"test\");\n        assert_eq!(trait_test.label, \"test\");\n    }\n\n    #[test]\n    fn register_trait() {\n        let trait_test = Trait::new(\"test\");\n        assert_eq!(trait_test.label, \"test\");\n        Trait::register_trait(\"test\");\n    }\n\n    #[test]\n    fn test_traits_builder() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        trait_builder.delete_trait(\"test\");\n        assert_eq!(trait_builder.traits.len(), 0);\n    }\n\n    #[test]\n    fn test_trait_new_builder() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n    }\n\n    #[test]\n    fn test_get_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n    }\n\n    #[test]\n    fn test_has_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n    }\n    #[test]\n    fn test_add_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.add_trait(trait_test.unwrap());\n        assert!(has_trait.add_trait);\n    }\n    #[test]\n    fn test_remove_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.remove_trait(trait_test.unwrap());\n    }\n    #[test]\n    fn test_is_add_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.add_trait(trait_test.unwrap());\n        assert!(has_trait.is_add_trait());\n    }\n    #[test]\n    fn test_is_has_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.add_trait(trait_test.unwrap());\n        assert!(has_trait.is_has_trait());\n    }\n    #[test]\n    fn is_remove_trait() {\n        let mut trait_builder = TraitBuilder::new();\n        trait_builder.add_trait(\"test\");\n        assert_eq!(trait_builder.traits[0].label, \"test\");\n        let trait_test = trait_builder.get_trait(\"test\");\n        assert_eq!(trait_test.unwrap().label, \"test\");\n        let mut has_trait = HasTrait::new(trait_test.unwrap().id);\n        assert!(has_trait.has_trait(trait_test.unwrap()));\n        has_trait.remove_trait(trait_test.unwrap());\n        assert!(has_trait.is_remove_trait());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","benches","mdg.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nextern crate mdg;\nuse mdg::*;\n\npub const BLOCK_LENGTH: usize = 64;\n\nfn finalize_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"finalize\", |b| {\n        let mut mdg = MD5::new();\n        let data = vec![0u8; BLOCK_LENGTH];\n        mdg.update(\u0026data);\n\n        b.iter(|| {\n            mdg.finalize();\n            // mdg.digest;\n        });\n    });\n}\n\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| {\n        b.iter(|| MD5::new);\n    });\n}\n\nfn transform_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let data = vec![0u8; BLOCK_LENGTH];\n\n    c.bench_function(\"transform\", |b| {\n        b.iter(|| {\n            mdg.transform(black_box(\u0026data));\n        });\n    });\n}\n\nfn update_with_len_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let data = vec![0u8; BLOCK_LENGTH];\n    let nbytes = Some(BLOCK_LENGTH);\n\n    c.bench_function(\"update_with_len\", |b| {\n        b.iter(|| {\n            // mdg.update_with_len(black_box(\u0026data), black_box(nbytes));\n            mdg.update_with_len(black_box(\u0026data), black_box(nbytes.unwrap_or(BLOCK_LENGTH)));\n        });\n    });\n}\n\nfn reset_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n\n    c.bench_function(\"reset\", |b| {\n        b.iter(|| {\n            mdg.reset();\n        });\n    });\n}\n\nfn update_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let data = vec![0u8; BLOCK_LENGTH];\n\n    c.bench_function(\"update\", |b| {\n        b.iter(|| {\n            mdg.update(black_box(\u0026data));\n        });\n    });\n}\n\nfn update_file_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let path = \"file.txt\";\n\n    c.bench_function(\"update_file\", |b| {\n        b.iter(|| {\n            mdg.update_file(black_box(path));\n        });\n    });\n}\n\nfn hexdigest_benchmark(c: \u0026mut Criterion) {\n    let data = vec![0u8; BLOCK_LENGTH];\n\n    c.bench_function(\"hexdigest\", |b| {\n        b.iter(|| {\n            let data_str = String::from_utf8(data.to_vec()).unwrap();\n            MD5::hexdigest(black_box(\u0026data_str));\n        });\n    });\n}\n\nfn hexdigest_file_benchmark(c: \u0026mut Criterion) {\n    let path = \"file.txt\";\n\n    c.bench_function(\"hexdigest_file\", |b| {\n        b.iter(|| {\n            MD5::hexdigest_file(black_box(path));\n        });\n    });\n}\n\nfn reset_file_benchmark(c: \u0026mut Criterion) {\n    let mut mdg = MD5::new();\n    let path = \"file.txt\";\n\n    c.bench_function(\"reset_file\", |b| {\n        b.iter(|| {\n            mdg.reset_file(black_box(path));\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    finalize_benchmark,\n    hexdigest_benchmark,\n    hexdigest_file_benchmark,\n    new_benchmark,\n    reset_benchmark,\n    reset_file_benchmark,\n    transform_benchmark,\n    update_benchmark,\n    update_file_benchmark,\n    update_with_len_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","examples","mdg.rs"],"content":"extern crate mdg;\nuse mdg::{Digest, MD5};\n\nfn main() {\n    // Example using MD5::hexdigest() for a string input\n    let input = \"Hello, world!\";\n    let digest = MD5::hexdigest(input);\n    println!(\"ðŸ¦€ MD5::hexdigest() for a string input:            âœ… {digest}\",);\n    // Expected 6cd3556deb0da54bca060b4c39479839\n\n    // Example using MD5::hexdigest() for a byte array input\n    let input = [72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]; // \"Hello, world!\"\n    let input_str = String::from_utf8(input.to_vec()).unwrap();\n    let digest = MD5::hexdigest(\u0026input_str);\n    println!(\"ðŸ¦€ MD5::hexdigest() for a byte array input:        âœ… {digest}\",);\n    // Expected 6cd3556deb0da54bca060b4c39479839\n\n    // Example using MD5::hexdigest() for a file input\n    let digest = MD5::hexdigest_file(\"mdg/file.txt\"); // file.txt contains \"Hello, world!\"\n    println!(\"ðŸ¦€ MD5::hexdigest_file() for a file input:         âœ… {digest}\",);\n    // Expected 6cd3556deb0da54bca060b4c39479839\n\n    // Example using MD5::update() for a byte array input\n    let mut mdg = MD5::new();\n    let input = [\n        67, 111, 117, 99, 111, 117, 44, 32, 108, 101, 32, 109, 111, 110, 100, 101, 33,\n    ]; // \"Coucou, le monde!\"\n    mdg.update(\u0026input);\n    let digest = mdg.finalize();\n    println!(\"ðŸ¦€ MD5::update() for a byte array input:           âœ… {digest}\",);\n    // Expected 47353a0e5ed2e1e0d57213a39e9bb7c4\n\n    // Example using MD5::update() for a string input\n    let mut mdg = MD5::new();\n    let input = \"Coucou, le monde!\";\n    mdg.update(input.as_bytes());\n    let digest = mdg.finalize();\n    println!(\"ðŸ¦€ MD5::update() for a string input:               âœ… {digest}\",);\n    // Expected 47353a0e5ed2e1e0d57213a39e9bb7c4\n\n    // Example using MD5::update() for a file input\n    let mut mdg = MD5::new();\n    println!(\n        \"ðŸ¦€ MD5::new() is:                                  âœ… {}\",\n        mdg.finalize()\n    );\n    // Expected d41d8cd98f00b204e9800998ecf8427e\n    mdg.update_file(\"mdg/update.txt\"); // update.txt contains \"Coucou, le monde!\"\n    let digest = mdg.finalize();\n    println!(\"ðŸ¦€ MD5::update_file() is:                          âœ… {digest}\",);\n    // Expected 7fc3e27776139278c6b8e0b6f096b4fb\n\n    // Example using MD5::reset() for a string input\n    let mut mdg = MD5::new();\n    println!(\n        \"ðŸ¦€ MD5::new() is:                                  âœ… {}\",\n        mdg.finalize()\n    );\n    // Expected d41d8cd98f00b204e9800998ecf8427e\n    println!(\n        \"ðŸ¦€ MD5::reset() for a string input:                âœ… {}\",\n        mdg.reset()\n    );\n    // Expected 00000000000000000000000000000000\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","constants.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n/// The block length.\npub const BLOCK_LENGTH: usize = 64;\n/// The digest length.\npub const DIGEST_LENGTH: usize = 16;\n/// The number of bytes in a word.\npub const INITIAL_STATE: [u32; 4] = [0x6745_2301, 0xefcd_ab89, 0x98ba_dcfe, 0x1032_5476];\n/// The number of bytes in a word.\npub const SHIFTS: [u8; 64] = [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,\n    14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,\n    21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n/// Padding used in the algorithm implementation of MD5.\npub const PADDING: [u8; 64] = [\n    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0,\n];\n/// The number of bytes in a word.\npub const T_VALUES: [u32; 64] = [\n    0xd76a_a478,\n    0xe8c7_b756,\n    0x2420_70db,\n    0xc1bd_ceee,\n    0xf57c_0faf,\n    0x4787_c62a,\n    0xa830_4613,\n    0xfd46_9501,\n    0x6980_98d8,\n    0x8b44_f7af,\n    0xffff_5bb1,\n    0x895c_d7be,\n    0x6b90_1122,\n    0xfd98_7193,\n    0xa679_438e,\n    0x49b4_0821,\n    0xf61e_2562,\n    0xc040_b340,\n    0x265e_5a51,\n    0xe9b6_c7aa,\n    0xd62f_105d,\n    0x0244_1453,\n    0xd8a1_e681,\n    0xe7d3_fbc8,\n    0x21e1_cde6,\n    0xc337_07d6,\n    0xf4d5_0d87,\n    0x455a_14ed,\n    0xa9e3_e905,\n    0xfcef_a3f8,\n    0x676f_02d9,\n    0x8d2a_4c8a,\n    0xfffa_3942,\n    0x8771_f681,\n    0x6d9d_6122,\n    0xfde5_380c,\n    0xa4be_ea44,\n    0x4bde_cfa9,\n    0xf6bb_4b60,\n    0xbebf_bc70,\n    0x289b_7ec6,\n    0xeaa1_27fa,\n    0xd4ef_3085,\n    0x0488_1d05,\n    0xd9d4_d039,\n    0xe6db_99e5,\n    0x1fa2_7cf8,\n    0xc4ac_5665,\n    0xf429_2244,\n    0x432a_ff97,\n    0xab94_23a7,\n    0xfc93_a039,\n    0x655b_59c3,\n    0x8f0c_cc92,\n    0xffef_f47d,\n    0x8584_5dd1,\n    0x6fa8_7e4f,\n    0xfe2c_e6e0,\n    0xa301_4314,\n    0x4e08_11a1,\n    0xf753_7e82,\n    0xbd3a_f235,\n    0x2ad7_d2bb,\n    0xeb86_d391,\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","digest.rs"],"content":"use crate::{INITIAL_STATE, MD5};\nuse std::{fs::File, io::Read};\n\n/// The `Digest` trait.\npub trait Digest {\n    /// reset the internal state of the object\n    fn reset(\u0026mut self) -\u003e \u0026mut Self;\n    /// update the internal state of the object with new data\n    fn update(\u0026mut self, value: \u0026[u8]) -\u003e \u0026mut Self;\n    /// update the internal state of the object with new data from a file\n    fn update_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self;\n    /// return the digest value as a string of hexadecimal digits\n    fn hexdigest(value: \u0026str) -\u003e String;\n    /// return the digest value as a string of hexadecimal digits from a file\n    fn hexdigest_file(path: \u0026str) -\u003e String;\n    /// reset the internal state of the object and update it with new data from a file\n    fn reset_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self;\n}\n\nimpl Digest for MD5 {\n    /// Reset the internal state of the MD5 object.\n    fn reset(\u0026mut self) -\u003e \u0026mut Self {\n        self.state = INITIAL_STATE;\n        self.count.fill(0);\n        self.buffer.fill(0);\n        self.digest.fill(0);\n\n        self\n    }\n    /// Update the internal state of the MD5 object with new data.\n    fn update(\u0026mut self, value: \u0026[u8]) -\u003e \u0026mut Self {\n        self.update_with_len(value, value.len())\n    }\n    /// Update the internal state of the MD5 object with new data from a file.\n    fn update_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self {\n        let mut file = File::open(path).expect(\"Couldn't open file\");\n        let mut buffer = [0; 1024];\n\n        loop {\n            let nbytes = file.read(\u0026mut buffer).expect(\"Couldn't read file\");\n            if nbytes == 0 {\n                break;\n            }\n            self.update_with_len(\u0026buffer, nbytes);\n        }\n\n        self\n    }\n    /// Return the digest value as a string of hexadecimal digits.\n    fn hexdigest(value: \u0026str) -\u003e String {\n        Self::new().update(value.as_bytes()).finalize().to_string()\n    }\n\n    /// Return the digest value as a string of hexadecimal digits from a file.\n    fn hexdigest_file(path: \u0026str) -\u003e String {\n        let mut file = File::open(path).expect(\"Couldn't open file\");\n        let mut buffer = [0; 1024];\n        let mut mdg = Self::new();\n\n        loop {\n            let nbytes = file.read(\u0026mut buffer).expect(\"Couldn't read file\");\n            if nbytes == 0 {\n                break;\n            }\n            mdg.update_with_len(\u0026buffer, nbytes);\n        }\n\n        mdg.finalize().to_string()\n    }\n    /// Reset the internal state of the MD5 object and update it with new data from a file.\n    fn reset_file(\u0026mut self, path: \u0026str) -\u003e \u0026mut Self {\n        self.reset();\n        self.update_file(path)\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library that implements the MD5 cryptographic hash function\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-mdg.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The Message Digest (MDG) is an easy way to produces a 128-bit\n//! (16-byte) hash value using the MD5 cryptographic hash function. It\n//! provides a struct, MD5, that can generate a message digest of data\n//! in a secure, one-way hash. The message digest can verify the\n//! integrity of the data without having to store the entire message.\n//!\n//! Several options are available to produce the hash value:\n//!\n//! - `MD5::default()` - Returns the hash value of an empty string.\n//! - `MD5::digest()` - Returns the hash value of a string.\n//! - `MD5::finalize()` - Finalize the MD5 object and return the result\n//!    as a 16-byte array.\n//! - `MD5::hexdigest()` - Returns the hash value of a string as a\n//!    hexadecimal string.\n//! - `MD5::new()` - Create a new instance of the MD5 struct.\n//! - `MD5::reset()` - Reset the internal state of the MD5 object.\n//! - `MD5::to_hex_string()` - Returns the hash value of a string as a\n//!    hexadecimal string.\n//! - `MD5::to_string()` - Returns the hash value of a string as a\n//!    string.\n//! - `MD5::update()` - Update the internal state of the MD5 object\n//!    with new data.\n//! - `MD5::update_file()` - Update the internal state of the MD5\n//!    object with new data from a file.\n//!\n//! To use this crate, add `mdg` to your `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! mdg = \"0.0.1\"\n//! ```\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! # Examples\n//!\n//! ```no_run\n//! use mdg::MD5;\n//!\n//! let hash = MD5::default();\n//! assert_eq!(hash.to_string(), \"d41d8cd98f00b204e9800998ecf8427e\");\n//! ```\n//! # Warning\n//!\n//! This crate is not intended for cryptographic use. MD5 is not a\n//! cryptographically secure hashing algorithm and should not be used\n//! for applications that require a collision-resistant hash function.\n//!\n//! MD5 is sensitive to length extension attacks, which alter the hash\n//! value if additional data is appended to the input.\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mdg.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mdg.svg\",\n    html_root_url = \"https://docs.rs/mdg\"\n)]\n#![crate_name = \"mdg\"]\n#![crate_type = \"lib\"]\n\n/// Import the `params` module.\nmod params;\npub use params::*;\n\n/// Import the `constants` module.\npub mod constants;\npub use constants::*;\n\n/// Import the `digest` module.\npub mod digest;\npub use digest::*;\n\nuse std::convert::TryInto;\nuse std::fmt::Display;\n\n/// The MD5 struct.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct MD5 {\n    /// The buffer.\n    pub buffer: [u8; BLOCK_LENGTH],\n    /// The count.\n    pub count: [u32; 2],\n    /// The digest.\n    pub digest: [u8; DIGEST_LENGTH],\n    /// The state.\n    pub state: [u32; 4],\n}\n\nimpl MD5 {\n    /// Finalize the MD5 object and return the result as a 16-byte array.\n    pub fn finalize(\u0026mut self) -\u003e \u0026Self {\n        // Save the length before padding.\n        let bits: [u8; 8] = (0..8)\n            .into_iter()\n            .map(|i| (self.count[i \u003e\u003e 2] \u003e\u003e ((i \u0026 3) \u003c\u003c 3)) as u8)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .try_into()\n            .expect(\"Couldn't transform vec into array\");\n\n        // Pad out to 56 mod 64\n        let index = (self.count[0] \u003e\u003e 3) \u0026 63;\n        let pad_len = if index \u003c 56 { 56 - index } else { 120 - index };\n        self.update_with_len(\u0026PADDING, pad_len as usize);\n\n        // Append the length\n        self.update(\u0026bits);\n\n        self.digest = (0..DIGEST_LENGTH)\n            .into_iter()\n            .map(|i| (self.state[i \u003e\u003e 2] \u003e\u003e ((i \u0026 3) \u003c\u003c 3)) as u8)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .try_into()\n            .expect(\"Couldn't transform vec into array\");\n\n        self\n    }\n    /// Create a new instance of the MD5 struct.\n    pub fn new() -\u003e Self {\n        Self {\n            state: INITIAL_STATE,\n            count: [0, 0],\n            buffer: [0; BLOCK_LENGTH],\n            digest: [0; DIGEST_LENGTH],\n        }\n    }\n    /// Update the internal state of the MD5 object with new data.\n    pub fn transform(\u0026mut self, data: \u0026[u8]) -\u003e \u0026mut Self {\n        const fn f(x: u32, y: u32, z: u32) -\u003e u32 {\n            (x \u0026 y) | (!x \u0026 z)\n        }\n\n        const fn g(x: u32, y: u32, z: u32) -\u003e u32 {\n            (x \u0026 z) | (y \u0026 !z)\n        }\n\n        const fn h(x: u32, y: u32, z: u32) -\u003e u32 {\n            x ^ y ^ z\n        }\n\n        const fn i(x: u32, y: u32, z: u32) -\u003e u32 {\n            y ^ (x | !z)\n        }\n        let (mut a, mut b, mut c, mut d): (u32, u32, u32, u32) =\n            (self.state[0], self.state[1], self.state[2], self.state[3]);\n\n        for (idx, t_value) in T_VALUES.iter().enumerate() {\n            let (value, g): (u32, usize) = match idx {\n                0..=15 =\u003e (f(b, c, d), idx),\n                16..=31 =\u003e (g(b, c, d), (5 * idx + 1) % DIGEST_LENGTH),\n                32..=47 =\u003e (h(b, c, d), (3 * idx + 5) % DIGEST_LENGTH),\n                48..=63 =\u003e (i(b, c, d), (7 * idx) % DIGEST_LENGTH),\n                _ =\u003e unreachable!(),\n            };\n            let part_value = u32::from_ne_bytes(\n                data[4 * g..4 * g + 4]\n                    .try_into()\n                    .expect(\"Couldn't transform slice into array\"),\n            );\n            let f = value\n                .wrapping_add(a)\n                .wrapping_add(*t_value)\n                .wrapping_add(part_value);\n            a = d;\n            d = c;\n            c = b;\n            b = b.wrapping_add(f.rotate_left(SHIFTS[idx].into()));\n        }\n        self.state[0] = self.state[0].wrapping_add(a);\n        self.state[1] = self.state[1].wrapping_add(b);\n        self.state[2] = self.state[2].wrapping_add(c);\n        self.state[3] = self.state[3].wrapping_add(d);\n\n        self\n    }\n    /// Update the internal state of the MD5 object with new data.\n    pub fn update_with_len(\u0026mut self, value: \u0026[u8], nbytes: usize) -\u003e \u0026mut Self {\n        // Compute number of bytes mod 64\n        let mut offset = ((self.count[0] \u003e\u003e 3) \u0026 63) as usize;\n        let nbits = (nbytes \u003c\u003c 3) as u32;\n        let p = value;\n\n        if nbytes == 0 {\n            return self;\n        }\n\n        // Update the number of bits\n        self.count[0] = self.count[0].wrapping_add(nbits);\n        if self.count[0] \u003c nbits {\n            self.count[1] += 1;\n        }\n\n        self.count[1] += (nbytes \u003e\u003e 29) as u32;\n\n        let part_len = BLOCK_LENGTH - offset;\n        let mut i = part_len;\n\n        // Transform as many times as possible\n        if nbytes \u003e= part_len {\n            self.buffer[offset..(offset + part_len)].clone_from_slice(\u0026p[..part_len]);\n            let buf = self.buffer;\n            self.transform(\u0026buf);\n\n            while i \u003c nbytes - part_len {\n                if nbytes - i \u003e= 64 {\n                    let buf = self.buffer[i..i + part_len].to_vec();\n                    self.transform(\u0026buf);\n                    i += 64;\n                } else {\n                    break;\n                }\n            }\n            offset = 0;\n        } else {\n            i = 0;\n        }\n\n        // Add remaining input in buffer\n        self.buffer[offset..(offset + nbytes - i)].clone_from_slice(\u0026p[i..nbytes]);\n        self\n    }\n}\n\nimpl Default for MD5 {\n    /// Create a new instance of the MD5 struct.\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Display for MD5 {\n    /// Display the current MD5 value.\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        for di in self.digest {\n            write!(f, \"{di:02x}\")?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":120,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":200},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":3474},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3447},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2153},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1727},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1296},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":864},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1728},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":693},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":21},"fn_name":null}],"covered":86,"coverable":89},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","src","params.rs"],"content":"/// MD5Params\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct MD5Params {\n    /// A\n    pub a: u32,\n    /// B\n    pub b: u32,\n    /// C\n    pub c: u32,\n    /// D\n    pub d: u32,\n    /// X\n    pub x: u32,\n    /// S\n    pub s: u8,\n    /// AC\n    pub ac: u32,\n}\n\nimpl MD5Params {\n    /// Create a new instance of the MD5Params struct.\n    pub fn new(a: u32, b: u32, c: u32, d: u32, x: u32, s: u8, ac: u32) -\u003e Self {\n        Self {\n            a,\n            b,\n            c,\n            d,\n            x,\n            s,\n            ac,\n        }\n    }\n}\n/// Rotate left\npub fn f(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    let res = mdg_f(b, c, d);\n\n    params.a = params\n        .a\n        .wrapping_add(res.wrapping_add(params.x.wrapping_add(params.ac)));\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(res)\n}\n/// Rotate left\npub fn g(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    params.a = params.a.wrapping_add(params.x.wrapping_add(params.ac));\n    params.a = params.a.wrapping_add(!d \u0026 c);\n    params.a = params.a.wrapping_add(d \u0026 b);\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(!d \u0026 c)\n}\n/// Rotate left\npub fn h(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    params.a = params.a.wrapping_add(params.x.wrapping_add(params.ac));\n    params.a = params.a.wrapping_add(b ^ c ^ d);\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(b ^ c ^ d)\n}\n/// Rotate left\npub fn i(params: \u0026mut MD5Params) -\u003e u32 {\n    // let a = params.a;\n    let b = params.b;\n    let c = params.c;\n    let d = params.d;\n    // let x = params.x;\n    // let s = params.s;\n    // let ac = params.ac;\n\n    params.a = params.a.wrapping_add(params.x.wrapping_add(params.ac));\n    params.a = params.a.wrapping_add(c ^ (d | !b));\n    params.a = rotate_left(params.a, params.s.into());\n    params.a = params.a.wrapping_add(params.b);\n\n    b.wrapping_add(c ^ (d | !b))\n}\n#[inline(always)]\n/// mdg_f\npub fn mdg_f(x: u32, y: u32, z: u32) -\u003e u32 {\n    (x \u0026 y) | (!x \u0026 z)\n}\n\n#[inline(always)]\n/// mdg_h\npub fn mdg_h(x: u32, y: u32, z: u32) -\u003e u32 {\n    x ^ y ^ z\n}\n/// mdg_i\n#[inline(always)]\npub fn mdg_i(x: u32, y: u32, z: u32) -\u003e u32 {\n    y ^ (x | !z)\n}\n/// Rotate left\n#[inline(always)]\npub fn rotate_left(x: u32, n: u32) -\u003e u32 {\n    (x \u003c\u003c n) | (x \u003e\u003e (32 - n))\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":64,"coverable":64},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","constants.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate mdg;\n    use self::mdg::constants::{\n        BLOCK_LENGTH, DIGEST_LENGTH, INITIAL_STATE, PADDING, SHIFTS, T_VALUES,\n    };\n\n    #[test]\n    fn test_block_length() {\n        assert_eq!(BLOCK_LENGTH, 64);\n    }\n\n    #[test]\n    fn test_digest_length() {\n        assert_eq!(DIGEST_LENGTH, 16);\n    }\n\n    #[test]\n    fn test_initial_state() {\n        assert_eq!(\n            INITIAL_STATE,\n            [0x6745_2301, 0xefcd_ab89, 0x98ba_dcfe, 0x1032_5476]\n        );\n    }\n\n    #[test]\n    fn test_shifts() {\n        assert_eq!(\n            SHIFTS,\n            [\n                7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14,\n                20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11,\n                16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_padding() {\n        assert_eq!(\n            PADDING,\n            [\n                0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_t_values() {\n        assert_eq!(\n            T_VALUES,\n            [\n                0xd76a_a478,\n                0xe8c7_b756,\n                0x2420_70db,\n                0xc1bd_ceee,\n                0xf57c_0faf,\n                0x4787_c62a,\n                0xa830_4613,\n                0xfd46_9501,\n                0x6980_98d8,\n                0x8b44_f7af,\n                0xffff_5bb1,\n                0x895c_d7be,\n                0x6b90_1122,\n                0xfd98_7193,\n                0xa679_438e,\n                0x49b4_0821,\n                0xf61e_2562,\n                0xc040_b340,\n                0x265e_5a51,\n                0xe9b6_c7aa,\n                0xd62f_105d,\n                0x0244_1453,\n                0xd8a1_e681,\n                0xe7d3_fbc8,\n                0x21e1_cde6,\n                0xc337_07d6,\n                0xf4d5_0d87,\n                0x455a_14ed,\n                0xa9e3_e905,\n                0xfcef_a3f8,\n                0x676f_02d9,\n                0x8d2a_4c8a,\n                0xfffa_3942,\n                0x8771_f681,\n                0x6d9d_6122,\n                0xfde5_380c,\n                0xa4be_ea44,\n                0x4bde_cfa9,\n                0xf6bb_4b60,\n                0xbebf_bc70,\n                0x289b_7ec6,\n                0xeaa1_27fa,\n                0xd4ef_3085,\n                0x0488_1d05,\n                0xd9d4_d039,\n                0xe6db_99e5,\n                0x1fa2_7cf8,\n                0xc4ac_5665,\n                0xf429_2244,\n                0x432a_ff97,\n                0xab94_23a7,\n                0xfc93_a039,\n                0x655b_59c3,\n                0x8f0c_cc92,\n                0xffef_f47d,\n                0x8584_5dd1,\n                0x6fa8_7e4f,\n                0xfe2c_e6e0,\n                0xa301_4314,\n                0x4e08_11a1,\n                0xf753_7e82,\n                0xbd3a_f235,\n                0x2ad7_d2bb,\n                0xeb86_d391,\n            ]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","digest.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate mdg;\n\n    use mdg::*;\n\n    #[test]\n    fn test_mdg_reset() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        mdg.reset();\n        let digest = mdg::MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_mdg_update() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        let digest = mdg::MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_mdg_hexdigest() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        let digest = mdg::MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n    #[test]\n    fn test_reset_file() {\n        let mut mdg = MD5::new();\n        mdg.update(b\"test\");\n        mdg.reset_file(\"file.txt\");\n        assert_eq!(mdg::MD5::hexdigest(\"\"), \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","lib.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate mdg;\n    use std::cmp;\n\n    use mdg::{Digest, MD5};\n\n    extern crate cjwt;\n    use self::cjwt::{Algorithm, JWT};\n\n    #[test]\n    fn test_mdg_0() {\n        let digest = MD5::hexdigest(\"\");\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_mdg_1() {\n        let digest = MD5::hexdigest(\"a\");\n        assert_eq!(digest, \"0cc175b9c0f1b6a831c399e269772661\");\n    }\n\n    #[test]\n    fn test_mdg_2() {\n        let digest = MD5::hexdigest(\"abc\");\n        assert_eq!(digest, \"900150983cd24fb0d6963f7d28e17f72\");\n    }\n\n    #[test]\n    fn test_mdg_3() {\n        let digest = MD5::hexdigest(\"message digest\");\n        assert_eq!(digest, \"f96b697d7cb7938d525a2f31aaf161d0\");\n    }\n\n    #[test]\n    fn test_mdg_4() {\n        let digest = MD5::hexdigest(\"abcdefghijklmnopqrstuvwxyz\");\n        assert_eq!(digest, \"c3fcd3d76192e4007dfb496cca67e13b\");\n    }\n\n    #[test]\n    fn test_mdg_5() {\n        let digest =\n            MD5::hexdigest(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\");\n        assert_eq!(digest, \"d174ab98d277d9f5a5611c2c9f419d9f\");\n    }\n\n    #[test]\n    fn test_mdg_6() {\n        let digest = MD5::hexdigest(\n            \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n        );\n        assert_eq!(digest, \"57edf4a22be3c955ac49da2e2107b67a\");\n    }\n\n    #[test]\n    fn test_update_mdg_many_times() {\n        let digest = MD5::new()\n            .update(b\"a\")\n            .update(b\"b\")\n            .update(b\"c\")\n            .finalize()\n            .to_string();\n        assert_eq!(digest, \"900150983cd24fb0d6963f7d28e17f72\");\n    }\n\n    #[test]\n    fn test_reset() {\n        let digest = MD5::new().update(b\"a\").reset().finalize().to_string();\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n\n    #[test]\n    fn test_to_string_before_finalize() {\n        let digest = MD5::new().update(b\"a\").to_string();\n        // Is this acceptable? Or make it an Option that can be None?\n        assert_eq!(digest, \"00000000000000000000000000000000\");\n    }\n\n    #[test]\n    fn update_with_len() {\n        let digest = MD5::new().update_with_len(b\"abc\", 3).finalize().to_string();\n        assert_eq!(digest, \"900150983cd24fb0d6963f7d28e17f72\");\n    }\n    #[test]\n    fn update_file() {\n        let digest = MD5::new().update_file(\"update.txt\").finalize().to_string();\n        assert_eq!(digest, \"47353a0e5ed2e1e0d57213a39e9bb7c4\");\n    }\n    #[test]\n    fn hexdigest_file() {\n        let digest = MD5::hexdigest_file(\"update.txt\");\n        assert_eq!(digest, \"47353a0e5ed2e1e0d57213a39e9bb7c4\");\n    }\n    #[test]\n    fn reset_file() {\n        let digest = MD5::new()\n            .update_file(\"update.txt\")\n            .reset()\n            .finalize()\n            .to_string();\n        assert_eq!(digest, \"d41d8cd98f00b204e9800998ecf8427e\");\n    }\n    #[test]\n    fn transform() {\n        let digest = MD5::new().update_file(\"update.txt\").finalize().to_string();\n        assert_eq!(digest, \"47353a0e5ed2e1e0d57213a39e9bb7c4\");\n    }\n    #[test]\n    fn test_algorithm_to_string() {\n        let hs256 = Algorithm::HS256;\n        assert_eq!(hs256.to_string(), \"HS256\");\n\n        let rs512 = Algorithm::RS512;\n        assert_eq!(rs512.to_string(), \"RS512\");\n    }\n\n    #[test]\n    fn test_default_algorithm() {\n        let default_alg = Algorithm::default();\n        assert_eq!(default_alg, Algorithm::HS256);\n    }\n\n    #[test]\n    fn test_default_jwt() {\n        let default_jwt = JWT::default();\n        assert_eq!(default_jwt.header.alg, Some(Algorithm::HS256));\n        assert_eq!(default_jwt.token, String::new());\n    }\n    #[test]\n    fn test_reset_file() {\n        let mut mdg = MD5::new();\n        mdg.finalize();\n        mdg.reset();\n        assert_eq!(mdg.to_string(), \"00000000000000000000000000000000\");\n    }\n    #[test]\n    fn test_default() {\n        let mut mdg = MD5::default();\n        mdg.finalize();\n        mdg.reset();\n        assert_eq!(mdg.to_string(), \"00000000000000000000000000000000\");\n    }\n\n    #[test]\n    fn test_update_with_len() {\n        let mut md5 = MD5::new();\n        let data = b\"test data\";\n        let nbytes = data.len();\n\n        // Test updating with non-empty data\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [72, 0]);\n        assert_eq!(md5.buffer[0..nbytes], data[..]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with empty data\n        md5.update_with_len(b\"\", 0);\n        assert_eq!(md5.count, [0, 0]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with data that is smaller than part_len\n        let data = b\"test\";\n        let nbytes = data.len();\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [32, 0]);\n        assert_eq!(md5.buffer[0..nbytes], data[..]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with data that is larger than part_len\n        let data = b\"test data test data test data\";\n        let nbytes = data.len();\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [232, 0]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Test updating with data that results in overflow of count[0]\n        let data = b\"test data\";\n        let nbytes = data.len();\n        md5.count[0] = u32::max_value();\n        md5.update_with_len(data, nbytes);\n        assert_eq!(md5.count, [71, 1]);\n        // Check the state of the md5 after the update\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n    }\n    #[test]\n    fn test_update_with_len_large_data() {\n        let mut md5 = MD5::new();\n        let data = vec![1; 128];\n        let nbytes = data.len();\n\n        md5.update_with_len(\u0026data, nbytes);\n        assert_eq!(md5.count, [1024, 0]);\n\n        let buffer_len = cmp::min(md5.buffer.len(), nbytes);\n        assert_eq!(md5.buffer[0..buffer_len], data[..buffer_len]);\n\n        let buf = md5.buffer[0..buffer_len].to_vec();\n        md5.transform(\u0026buf);\n        assert_eq!(buffer_len \u003e= 64, true);\n        assert_eq!(md5.count, [1024, 0]);\n\n        let state = md5.state;\n        assert_ne!(state, [0; 4]);\n        md5.reset();\n\n        // Check the state of the md5 after each iteration of the while loop\n        let state1 = md5.state;\n        assert_ne!(state1, [0; 4]);\n\n        let state2 = md5.state;\n        assert_ne!(state2, [0; 4]);\n        assert_eq!(state1, state2);\n\n        md5.reset();\n    }\n    #[test]\n    fn test_transform_with_sufficient_buffer_length() {\n        const NBYTES: usize = 1024;\n        const PART_LEN: usize = 512;\n\n        let mut md5 = MD5::new();\n        md5.count = [NBYTES as u32, 0];\n        let mut buffer = [0; NBYTES];\n\n        // Fill the buffer with some data\n        for i in 0..NBYTES {\n            buffer[i] = i as u8;\n        }\n\n        let mut i = 0;\n        while i \u003c NBYTES - PART_LEN {\n            if NBYTES - i \u003e= PART_LEN {\n                let buf = \u0026buffer[i..(i + PART_LEN)];\n                md5.transform(buf);\n                i += PART_LEN;\n\n                assert_eq!(i, PART_LEN);\n                assert_eq!(md5.count, [1024, 0]);\n            } else {\n                let part_len = NBYTES - i;\n                let buf = \u0026buffer[i..(i + part_len)];\n                md5.transform(buf);\n                i += part_len;\n\n                assert_eq!(i, NBYTES);\n                assert_eq!(md5.count, [1024, 0]);\n            }\n        }\n\n        let mut md5 = MD5::new();\n        md5.count = [NBYTES as u32, 0];\n        let mut buffer = [0; NBYTES];\n\n        // Fill the buffer with some data\n        for i in 0..NBYTES {\n            buffer[i] = i as u8;\n        }\n\n        let mut i = 0;\n        while i \u003c NBYTES - PART_LEN {\n            if NBYTES - i \u003e= PART_LEN {\n                let buf = \u0026buffer[i..(i + PART_LEN)];\n                md5.transform(buf);\n                i += PART_LEN;\n\n                assert_eq!(i, PART_LEN);\n                assert_eq!(md5.count, [1024, 0]);\n            } else {\n                let part_len = NBYTES - i;\n                let buf = \u0026buffer[i..(i + part_len)];\n                md5.transform(buf);\n                i += part_len;\n\n                assert_eq!(i, NBYTES);\n                assert_eq!(md5.count, [1024, 0]);\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","mdg","tests","params.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    extern crate mdg;\n    use mdg::*;\n\n    #[test]\n    fn test_mdg_params_new() {\n        let params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(params.a, 0);\n        assert_eq!(params.b, 1);\n        assert_eq!(params.c, 2);\n        assert_eq!(params.d, 3);\n        assert_eq!(params.x, 4);\n        assert_eq!(params.s, 5);\n    }\n\n    #[test]\n    fn test_f() {\n        let mut params: MD5Params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(f(\u0026mut params), ((!1 \u0026 3) + 1));\n    }\n\n    #[test]\n    fn test_g() {\n        let mut params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(g(\u0026mut params), 1 \u0026 3);\n    }\n\n    #[test]\n    fn test_h() {\n        let mut params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(h(\u0026mut params), 1 ^ 2 ^ (3 - 1));\n    }\n\n    #[test]\n    fn test_i() {\n        let mut params = MD5Params::new(0, 1, 2, 3, 4, 5, 6);\n        assert_eq!(i(\u0026mut params), 2 ^ ((1 | !3) - 1));\n    }\n    #[test]\n    fn test_mdg_f() {\n        assert_eq!(mdg_f(1, 2, 3), (!1 \u0026 3));\n    }\n\n    #[test]\n    fn test_mdg_h() {\n        assert_eq!(mdg_h(1, 2, 3), 1 ^ 2 ^ 3);\n    }\n\n    #[test]\n    fn test_mdg_i() {\n        assert_eq!(mdg_i(1, 2, 3), 2 ^ (1 | !3));\n    }\n\n    #[test]\n    fn test_rotate_left() {\n        assert_eq!(rotate_left(0b1010, 2), 0b101000);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","benches","psph.rs"],"content":"use cmn::constants::*;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse psph::Password;\n\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"Password::new\", |b| {\n        b.iter(|| {\n            Password::new(\n                black_box(4),\n                black_box(\"-\"),\n                black_box(SPECIAL_CHARS.to_vec()),\n            )\n        })\n    });\n}\ncriterion_group!(benches, new_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","examples","psph.rs"],"content":"use cmn::constants::*;\nuse psph::Password;\n\nfn main() {\n    let password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n    println!(\n        \"ðŸ¦€ Password::default():           âœ… {}\",\n        Password::default()\n    );\n    println!(\"ðŸ¦€ Password::new():               âœ… {password}\");\n    println!(\n        \"ðŸ¦€ Password::passphrase():        âœ… {}\",\n        password.passphrase()\n    );\n    let mut password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n    println!(\"ðŸ¦€ Password::set_passphrase\");\n    println!(\n        \"    ðŸ”“ Original passphrase:       âœ… {}\",\n        password.passphrase()\n    );\n    password.set_passphrase(\"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\");\n    println!(\n        \"    ðŸ” Updated passphrase:        âœ… {}\",\n        password.passphrase()\n    );\n    println!(\"ðŸ¦€ Password::len():               âœ… {}\", password.len());\n    println!(\n        \"ðŸ¦€ Password::is_empty():          âœ… {}\",\n        password.is_empty()\n    );\n    println!(\"ðŸ¦€ Password::hash():              âœ… {}\", password.hash());\n    println!(\n        \"ðŸ¦€ Password::password_length():   âœ… {}\",\n        password.password_length()\n    );\n    println!(\n        \"ðŸ¦€ Password::hash_length():       âœ… {}\",\n        password.hash_length()\n    );\n\n    let entropy = Password::entropy(\u0026password) as u64;\n\n    match entropy {\n        x if x \u003c 40 =\u003e println!(\"ðŸ¦€ Password::entropy():  âŒ {entropy} bits (Poor)\"),\n        x if (40..55).contains(\u0026x) =\u003e {\n            println!(\"ðŸ¦€ Password::entropy():  âŒ {entropy} bits (Weak)\")\n        }\n        x if (56..70).contains(\u0026x) =\u003e {\n            println!(\"ðŸ¦€ Password::entropy():           âš ï¸ {entropy} bits (Reasonable)\",)\n        }\n        x if (71..80).contains(\u0026x) =\u003e {\n            println!(\"ðŸ¦€ Password::entropy():  âš ï¸ {entropy} bits (Strong)\")\n        }\n        _ =\u003e println!(\"ðŸ¦€ Password::entropy():           âœ… {entropy} bits (Excellent)\",),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for generating random passwords and passphrases\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-psph.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/psph.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/psph)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/psph)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/psph)\n//! [![License](https://img.shields.io/crates/l/psph.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! PassPhrase (PSPH) is a Rust library that empowers developers to\n//! elevate the security of their applications with ease. `PSPH`\n//! generates secure and strong passphrases using a unique combination\n//! of letters, numbers, cases, and symbols to form an unpredictable\n//! string of characters that doesn't resemble words or names with a\n//! high level of entropy.\n//!\n//! ## Features\n//!\n//! - Generate a random password / passphrase.\n//! - Calculate the entropy of a password.\n//! - Calculate the hash of a password.\n//! - Calculate the hash length of a password.\n//! - Check if a password is empty.\n//! - Get the length of a password.\n//! - Get the generated password / passphrase.\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-psph.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-psph.svg\",\n    html_root_url = \"https://docs.rs/psph\"\n)]\n#![crate_name = \"psph\"]\n#![crate_type = \"lib\"]\n\nextern crate cmn;\n/// constants\npub use cmn::constants::*;\n/// words\npub use cmn::words::WORD_LIST;\n\nextern crate hsh;\npub use hsh::Hash;\n\nextern crate vrd;\npub use vrd::Random;\n\nuse std::collections::{HashMap, HashSet};\nuse std::convert::TryInto;\nuse std::f64;\n\n/// A random password / passphrase generator. The generated password\n/// is a string of three words separated by hyphens. Each word is\n/// between 6 and 8 characters long. The first character of each word\n/// is capitalized.\n#[non_exhaustive]\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\npub struct Password {\n    /// The generated passphrase.\n    passphrase: String,\n    /// The special characters to use for replacing letters in words.\n    special_chars: Vec\u003cchar\u003e,\n    /// The separator to use between words.\n    separator: String,\n}\n\nimpl Password {\n    /// Calculates the entropy of a password based on its length, the\n    /// number of unique characters used in the password and the number\n    /// of bits of the hash generated from the password.\n    ///\n    /// # Arguments\n    ///\n    /// * `\u0026self` - An immutable reference to the password.\n    ///\n    /// # Returns\n    ///\n    /// * `f64` - The calculated entropy of the password.\n    ///\n    /// # Entropy Ranges\n    ///\n    /// The following ranges can give you an idea of how the entropy is\n    /// considered:\n    ///\n    /// - Poor: less than 40 bits\n    /// - Weak: 40-55 bits\n    /// - Reasonable: 56-70 bits\n    /// - Strong: 71-80 bits\n    /// - Excellent: 81 bits and above\n    ///\n    /// Keep in mind that these values are just rough estimates and the\n    /// actual entropy of a password depends on the distribution of\n    /// characters used in the password and the number of unique\n    /// characters in it, and not just its length.\n    ///\n    pub fn entropy(\u0026self) -\u003e f64 {\n        let l = self.len() as f64;\n        l * (94.0_f64.log2()).round()\n    }\n    /// Returns the hash of the generated passphrase.\n    pub fn hash(\u0026self) -\u003e String {\n        let mut hash = Hash::new();\n        hash.set_password(\u0026format!(\n            \"{}{}\",\n            self.passphrase,\n            self.special_chars.iter().collect::\u003cString\u003e()\n        ));\n        let hash_value = hash.hash();\n        hash_value.to_string()\n    }\n    /// Returns the hash length.\n    pub fn hash_length(\u0026self) -\u003e usize {\n        self.hash().len()\n    }\n    /// Returns true if the generated passphrase is empty.\n    /// Returns false if the generated passphrase is not empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.passphrase.is_empty()\n    }\n    /// Returns the length of the generated passphrase.\n    pub fn len(\u0026self) -\u003e usize {\n        self.passphrase.len()\n    }\n    /// Returns the generated passphrase.\n    pub fn new(len: u8, separator: \u0026str, special_chars: Vec\u003cchar\u003e) -\u003e Self {\n        // Setup a random number generator.\n        let mut rng = Random::default();\n\n        // Create a new vector to store the words in the passphrase.\n        let mut words: Vec\u003cString\u003e = Vec::new();\n\n        // Convert the special characters to a vector of chars.\n        let ascii: Vec\u003cchar\u003e = SPECIAL_CHARS.to_vec();\n\n        // Create a new HashSet to store the generated words.\n        let mut word_set = HashSet::new();\n\n        // Create a HashMap for storing seen characters for each word\n        let mut seen_chars = HashMap::new();\n\n        // Generate `len` random words from the word list.\n        while words.len() \u003c len.into() {\n            // Choose a random word from the list.\n            let mut word = if let Some(w) = Random::choose(\u0026mut rng, WORD_LIST) {\n                // If a word was found, return it.\n                w\n            } else {\n                // If no word was found, return an empty string.\n                \"\"\n            };\n\n            // Ensure that the random word is not already present in\n            // the vector of words\n            while words.contains(\u0026word.to_string()) {\n                word = if let Some(w) = Random::choose(\u0026mut rng, WORD_LIST) {\n                    // If a word was found, return it.\n                    w\n                } else {\n                    // If no word was found, return an empty string.\n                    \"\"\n                };\n\n                // Get the HashSet of seen characters for the word\n                let word_seen_chars: \u0026mut HashSet\u003cchar\u003e =\n                    seen_chars.entry(word.to_lowercase()).or_default();\n\n                // Iterate through each character in the word and check if it has been seen before\n                let mut has_repeated_chars = false;\n                for c in word.to_lowercase().chars() {\n                    if !word_seen_chars.insert(c) {\n                        has_repeated_chars = true;\n                        break;\n                    }\n                }\n\n                // If word has repeated characters, skip to the next iteration of the loop\n                if has_repeated_chars {\n                    continue;\n                }\n\n                // Check if the word is already in the HashSet. If it is, skip to the next iteration of the loop.\n                if word_set.contains(\u0026word.to_lowercase()) {\n                    continue;\n                }\n\n                // Add the word to the HashSet.\n                word_set.insert(word.to_lowercase());\n            }\n\n            // Generate a random uppercase or lowercase letter from the\n            // ASCII table.\n            let mut random_letter = Random::char(\u0026mut rng);\n\n            // Ensure that the random letter is not already present in\n            // the word that was chosen.\n            while word.contains(random_letter) {\n                random_letter = Random::char(\u0026mut rng);\n            }\n\n            // Convert the word to title case and add a number to the\n            // end of the word.\n            let mut word = word.to_owned();\n            let chars = word.chars().enumerate().collect::\u003cVec\u003c_\u003e\u003e();\n            for (i, c) in chars {\n                if i == 0 || !c.is_alphabetic() {\n                    continue;\n                }\n                let lower = c.to_lowercase().next().unwrap();\n                word.remove(i);\n                word.insert(i, lower);\n                word.insert(i + 1, lower.to_uppercase().next().unwrap());\n            }\n            let first_letter = word.chars().next().unwrap().to_uppercase().next().unwrap();\n            word.remove(0);\n            word.insert(0, first_letter);\n\n            // Generate a new random number between 0 and 99.\n            let nb = rng.range(HASH_COST.try_into().unwrap(), 99);\n\n            word.push(random_letter);\n            word.push(*Random::choose(\u0026mut rng, \u0026ascii).unwrap());\n            word.push_str(\u0026nb.to_string());\n\n            // Replace a random letter in the word with a special\n            // character from the list.\n            let mut chars: Vec\u003cchar\u003e = word.chars().collect();\n            let index = rng.range(0, (chars.len() - 1).try_into().unwrap()) as usize;\n            chars[index] = *Random::choose(\u0026mut rng, \u0026special_chars).unwrap();\n\n            word = chars.into_iter().collect();\n            words.push(word);\n        }\n        // Return the generated passphrase.\n        Self {\n            passphrase: words.join(separator),\n            special_chars,\n            separator: separator.to_string(),\n        }\n    }\n\n    /// Returns the generated passphrase.\n    pub fn passphrase(\u0026self) -\u003e \u0026str {\n        \u0026self.passphrase\n    }\n    /// Returns the password length.\n    pub fn password_length(\u0026self) -\u003e usize {\n        self.passphrase.len()\n    }\n    /// Sets the generated passphrase.\n    pub fn set_passphrase(\u0026mut self, passphrase: \u0026str) {\n        self.passphrase = passphrase.to_string();\n    }\n}\n\nimpl std::fmt::Display for Password {\n    /// Display the generated passphrase.\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.passphrase)\n    }\n}\n\nimpl Default for Password {\n    /// Default to a passphrase of 4 words.\n    fn default() -\u003e Self {\n        Self::new(4, \"-\", SPECIAL_CHARS.to_vec())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","psph","tests","psph.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n    use cmn::constants::*;\n    use psph::Password;\n    use vrd::Random;\n\n    #[test]\n    fn test_password() {\n        let password = Password::new(3, \"-\", SPECIAL_CHARS.to_vec());\n        assert_eq!(password.passphrase().split('-').count(), 3);\n    }\n\n    #[test]\n    fn test_default() {\n        let default_result = Password::default();\n        let expected_result = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n        assert_ne!(default_result, expected_result);\n    }\n\n    #[test]\n    fn test_set_password() {\n        let mut password = Password::new(3, \"-\", SPECIAL_CHARS.to_vec());\n        password.set_passphrase(\"test\");\n        assert_eq!(password.passphrase(), \"test\");\n    }\n\n    #[test]\n    fn test_password_entropy() {\n        let password = Password::new(4, \"-\", vec!['!', '@', '#']);\n        let entropy = password.entropy();\n        assert!(entropy \u003e 71.0);\n    }\n\n    #[test]\n    fn test_password_hash_length() {\n        let password = Password::new(4, \"-\", vec!['!', '@', '#']);\n        let hash_length = password.hash_length();\n        assert_eq!(hash_length, 64);\n    }\n\n    #[test]\n    fn test_password_is_empty() {\n        let password = Password::new(0, \"-\", vec!['!', '@', '#']);\n        let is_empty = password.is_empty();\n        assert!(is_empty, \"{}\", password.passphrase());\n    }\n\n    #[test]\n    fn test_password_length() {\n        let mut password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n        password.set_passphrase(\"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\");\n        assert_eq!(password.password_length(), 36);\n    }\n\n    #[test]\n    fn test_password_default() {\n        let len = 4;\n        let password = Password::new(len, \"-\", SPECIAL_CHARS.to_vec());\n        assert!(password.passphrase().split('-').count() == len.into());\n    }\n\n    #[test]\n    fn test_password_display() {\n        let mut password = Password::new(4, \"-\", SPECIAL_CHARS.to_vec());\n        password.set_passphrase(\"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\");\n        assert_eq!(\n            format!(\"{password}\"),\n            \"M1n1Funct1()ns-N3wP@s5phr4s3-Ex@mpl3\"\n        );\n    }\n\n    #[test]\n    fn test_wordlist() {\n        let words: Vec\u003cString\u003e = vec![\"mini\".to_string(), \"functions\".to_string()];\n        let mut rng = Random::default();\n        while words.len() \u003c 2 {\n            if let Some(w) = Random::choose(\u0026mut rng, words.as_slice()) {\n                assert!(words.contains(w));\n            } else {\n                assert!(words.is_empty());\n            };\n        }\n    }\n    #[test]\n    fn test_wordlist_is_empty() {\n        let word = \"\";\n        assert!(word.is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","benches","qrc.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse image::Rgba;\nextern crate qrc;\nuse self::qrc::QRCode;\n\n// Benchmark for QRCode::new\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"QRCode::new\", |b| {\n        b.iter(|| QRCode::new(black_box(vec![1, 2, 3])))\n    });\n}\n// Benchmark for QRCode::to_png\nfn to_png_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    c.bench_function(\"QRCode::to_png\", |b| b.iter(|| qrcode.to_png(512)));\n}\n\n// Benchmark for QRCode::from_string\nfn from_string_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"QRCode::from_string\", |b| {\n        b.iter(|| QRCode::from_string(black_box(\"Hello, world!\".to_string())))\n    });\n}\n\n// Benchmark for QRCode::from_bytes\nfn from_bytes_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"QRCode::from_bytes\", |b| {\n        b.iter(|| QRCode::from_bytes(black_box(vec![1, 2, 3])))\n    });\n}\n\n// Benchmark for QRCode::to_svg\nfn to_svg_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    c.bench_function(\"QRCode::to_svg\", |b| {\n        b.iter(|| qrcode.to_svg(black_box(100)))\n    });\n}\n\n// Benchmark for QRCode::colorize\nfn colorize_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    let color = Rgba([0, 0, 0, 0]);\n    c.bench_function(\"QRCode::colorize\", |b| {\n        b.iter(|| qrcode.colorize(black_box(color)))\n    });\n}\n\n// Benchmark for QRCode::resize\nfn resize_benchmark(c: \u0026mut Criterion) {\n    let qrcode = QRCode::new(vec![1, 2, 3]);\n    c.bench_function(\"QRCode::resize\", |b| {\n        b.iter(|| qrcode.resize(black_box(100), black_box(100)))\n    });\n}\n\ncriterion_group!(\n    benches,\n    colorize_benchmark,\n    from_bytes_benchmark,\n    from_string_benchmark,\n    new_benchmark,\n    resize_benchmark,\n    to_png_benchmark,\n    to_svg_benchmark,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","examples","qrc.rs"],"content":"extern crate image;\nuse image::{imageops, ImageBuffer, Rgba, RgbaImage};\nextern crate qrc;\nuse self::qrc::{add_image_watermark, qr_code, qr_code_to, QRCode};\nuse std::fs; // Import the fs module from the standard library // Import the QRCode struct from the mini_functions crate\n\nconst URL: \u0026str = \"https://minifunctions.com/\"; // Define a constant for the URL to be encoded\n\nfn main() {\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation\n    let qrcode = QRCode::from_string(URL.to_string()); // Create a new QRCode using the QRCode::from_string() function\n    let png = qrcode.to_png(512); // Convert the QRCode into a PNG representation\n    let png_data = png.into_raw(); // Convert the PNG representation of the QRCode into a vector of bytes\n    let png_image = ImageBuffer::\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e::from_raw(21, 21, png_data).unwrap();\n    println!(\n        \"ðŸ¦€ fn to_png():                âœ… {:?}\",\n        png_image.save(\"qrcode.png\")\n    ); // Print the PNG representation of the QRCode\n    match png_image.save(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file created:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file created:           âŒ qrcode.png: {e}\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n    match fs::remove_file(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file removed:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file removed:           âŒ qrcode.png: {e}\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom color\n    let qrcode = QRCode::from_string(URL.to_string());\n    let red = Rgba([255, 0, 0, 255]);\n    let red_qrcode = qrcode.colorize(red); // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom color\n    let img: RgbaImage = red_qrcode; // Convert the colorized QR code to a PNG image.\n    let new_width = 512;\n    let new_height = 512;\n    let resized_img = imageops::resize(\u0026img, new_width, new_height, imageops::FilterType::Nearest);\n    let image: ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e = resized_img; // Convert the colorized QR code to a PNG image.\n    println!(\n        \"ðŸ¦€ fn colorize():              âœ… {:?}\",\n        image.save(\"qrcode_colorized.png\")\n    ); // Print the PNG representation of the QRCode\n    match image.save(\"qrcode_colorized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ colorized png file created: âœ… qrcode_colorized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ colorized png file created: âŒ qrcode_colorized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode_colorized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ colorized png file removed: âœ… qrcode_colorized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ colorized png file removed: âŒ qrcode_colorized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to an SVG representation\n    let qrcode = QRCode::from_string(URL.to_string());\n    let qrcode_svg = qrcode.to_svg(512); // Convert the QRCode into an SVG representation\n    match fs::write(\"qrcode.svg\", qrcode_svg) {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file created:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file created:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n    match fs::remove_file(\"qrcode.svg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file removed:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file removed:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom size\n    let qrcode = QRCode::new(vec![0x61, 0x62, 0x63]);\n    let resized_image: RgbaImage = qrcode.resize(512, 512);\n    println!(\n        \"ðŸ¦€ fn resize():                âœ… {:?}\",\n        resized_image.save(\"qrcode_resized.png\")\n    ); // Print the PNG representation of the QRCode\n    match resized_image.save(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file created:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file created:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file removed:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file removed:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n\n    // Create a new QRCode using the QRCode::from_string() function and convert it to a PNG representation with a custom size\n    let qrcode = QRCode::new(vec![0x61, 0x62, 0x63]);\n    let resized_image: RgbaImage = qrcode.resize(512, 512);\n    println!(\n        \"ðŸ¦€ fn resize():                âœ… {:?}\",\n        resized_image.save(\"qrcode_resized.png\")\n    ); // Print the PNG representation of the QRCode with a custom size of 512x512\n    match resized_image.save(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file created:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file created:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode_resized.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ resized file removed:       âœ… qrcode_resized.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ resized file removed:       âŒ qrcode_resized.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    // Create a new QRCode using the macro qr_code and convert it to an SVG representation with a custom size of 512x512\n    let qrcode = qr_code!(URL.into());\n    let qrcode_svg = qrcode.to_svg(512); // Convert the QRCode into an SVG representation with a custom size of 512x512\n    match fs::write(\"qrcode.svg\", qrcode_svg) {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file created:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file created:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n    match fs::remove_file(\"qrcode.svg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ svg file removed:           âœ… qrcode.svg\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ svg file removed:           âŒ qrcode.svg: {e}\"), // Print the path to the SVG representation of the QRCode that was saved to a file called \"qrcode.svg\"\n    }\n    // Create a new QRCode using the macro qr_code_to into a PNG representation with a custom size of 512x512\n    let qrcode = qr_code_to!(URL.into(), \"png\", 512);\n    match qrcode.save(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file created:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file created:           âŒ qrcode.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    match fs::remove_file(\"qrcode.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file removed:           âœ… qrcode.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file removed:           âŒ qrcode.png: {e}\",), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode.png\"\n    }\n    // Create a new QRCode using the macro qr_code_from into a GIF representation with a custom size of 512x512\n    let qrcode = qr_code_to!(URL.into(), \"gif\", 512);\n    match qrcode.save(\"qrcode.gif\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ gif file created:           âœ… qrcode.gif\"), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n        Err(e) =\u003e println!(\"ðŸ¦€ gif file created:           âŒ qrcode.gif: {e}\",), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n    }\n    match fs::remove_file(\"qrcode.gif\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ gif file removed:           âœ… qrcode.gif\"), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n        Err(e) =\u003e println!(\"ðŸ¦€ gif file removed:           âŒ qrcode.gif: {e}\",), // Print the path to the GIF representation of the QRCode that was saved to a file called \"qrcode.gif\"\n    }\n    // Create a new QRCode using the macro qr_code_to into a JPEG representation with a custom size of 512x512\n    let qrcode = qr_code_to!(URL.into(), \"jpg\", 512);\n    match qrcode.save(\"qrcode.jpg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ jpg file created:           âœ… qrcode.jpg\"), // Print the path to the JPG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ jpg file created:          âŒ qrcode.jpg: {e}\",), // Print the path to the JPEG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n    }\n    match fs::remove_file(\"qrcode.jpg\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ jpg file removed:           âœ… qrcode.jpg\"), // Print the path to the JPG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n        Err(e) =\u003e println!(\"ðŸ¦€ jpg file removed:           âŒ qrcode.jpg: {e}\",), // Print the path to the JPEG representation of the QRCode that was saved to a file called \"qrcode.jpg\"\n    }\n\n    // Create a new QRCode add a watermark to it and save it as a PNG file\n    let qrcode = QRCode::from_string(URL.to_string());\n    let mut qrcode_img = qrcode.to_png(512);\n    let watermark_img = image::open(\"bubba.ico\").unwrap().into_rgba8();\n    add_image_watermark!(\u0026mut qrcode_img, \u0026watermark_img);\n    match qrcode_img.save(\"qrcode_watermarked.png\") {\n        Ok(_) =\u003e println!(\"ðŸ¦€ png file with watermark:           âœ… qrcode_watermarked.png\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e println!(\"ðŸ¦€ png file with watermark:           âŒ qrcode_watermarked.png: {e}\"), // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n    match fs::remove_file(\"qrcode_watermarked.png\") {\n        Ok(_) =\u003e {\n            println!(\"ðŸ¦€ png file with watermark removed:           âœ… qrcode_watermarked.png\")\n        } // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n        Err(e) =\u003e {\n            println!(\"ðŸ¦€ png file with watermark removed:           âŒ qrcode_watermarked.png: {e}\")\n        } // Print the path to the PNG representation of the QRCode that was saved to a file called \"qrcode1.png\"\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for generating and manipulating QR code images in various formats\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-qrc.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/qrc.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/qrc/)\n//! [![Docs.rs](https://img.shields.io/badge/docs.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://docs.rs/qrc)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/qrc)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/qrc)\n//! [![License](https://img.shields.io/crates/l/qrc.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! The QR Code Library (QRC) is a versatile tool for generating and\n//! manipulating QR code images in various formats.\n//!\n//! With this library, you can easily convert your data into a QR code,\n//! whether it be in the form of a string or a vector of bytes.\n//!\n//! Choose from popular image formats like PNG, JPG, GIF and SVG, and\n//! even customize the size and color of your QR code.\n//!\n//! ## Features\n//!\n//! `QRC` features a `QRCode` struct that can be constructed with a\n//! `Vec\u003cu8\u003e` of data or a `String` of data that will be converted to\n//! a `Vec\u003cu8\u003e`.\n//!\n//! The QR code can be generated using the zto_qrcode` method, and\n//! specific image formats can be generated using the `to_png`,\n//! `to_jpg`, and `to_gif` methods.\n//!\n//! Each of these methods takes a `width` parameter and returns an\n//! `ImageBuffer` containing the QR code image.\n//!\n//! The library uses the qrcode and image crates to generate the QR\n//! code images.\n//!\n//! As of the current version, the library supports the following\n//! features with the following status:\n//!\n//! | Feature | Description |\n//! | ------- | ----------- |\n//! | Library license | Apache-2.0 OR MIT |\n//! | Library version | 0.0.1 |\n//! | Mode Numeric | not specified |\n//! | Mode Alphanumeric | not specified |\n//! | Mode Byte | not specified |\n//! | Mode Kanji | not specified |\n//! | Mode ECI | not specified |\n//! | Mode FNC1 | not specified |\n//! | Mode Structured Append | not specified |\n//! | Mode Hanzi | not specified |\n//! | Mixing modes | not specified |\n//! | QR Codes version 1 - 40 | not specified |\n//! | Micro QR Codes version M1 - M4 | not specified |\n//! | Find maximal error correction level | not specified |\n//! | Optimize QR Codes | not specified |\n//! | PNG output | supported |\n//! | JPG output | supported |\n//! | GIF output | supported |\n//! | SVG output | supported |\n//! | EPS output | not specified |\n//! | PDF output | not specified |\n//! | BMP output | not specified |\n//! | TIFF output | not specified |\n//! | WebP output | not specified |\n//! | Black and white QR Codes | Yes |\n//! | Colorized QR code | Yes |\n//! | Animated QR Codes (GIF, APNG, WebP) | not specified |\n//! | Changing size of modules (scaling factor) | not specified |\n//! | Command line script | not specified |\n//! | QR code resizing | supported |\n//! | QR code watermarking | supported |\n//! | QR code with logo | supported |\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-qrc.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-qrc.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"qrc\"]\n#![crate_type = \"lib\"]\n\nextern crate image;\nextern crate qrcode;\n\nuse image::{ImageBuffer, Rgba, RgbaImage};\nuse qrcode::render::svg;\nuse qrcode::QrCode;\n\n#[non_exhaustive]\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]\n/// QRCode is a structure that contains data in the form of a vector of\n/// bytes.\npub struct QRCode {\n    /// The `data` field holds the data to be encoded in the QR code.\n    pub data: Vec\u003cu8\u003e,\n}\n/// Implementation of QRCode structure.\nimpl QRCode {\n    /// Creates a new QRCode structure with the given data.\n    pub fn new(data: Vec\u003cu8\u003e) -\u003e Self {\n        QRCode { data }\n    }\n\n    /// The `from_string` method creates a new instance of the QRCode\n    /// struct by converting the given string data into a vector of\n    /// bytes\n    pub fn from_string(data: String) -\u003e Self {\n        QRCode {\n            data: data.into_bytes(),\n        }\n    }\n\n    /// Creates a new QRCode structure from a vector of bytes.\n    pub fn from_bytes(data: Vec\u003cu8\u003e) -\u003e Self {\n        QRCode { data }\n    }\n\n    /// Converts the QRCode structure to a QrCode structure.\n    pub fn to_qrcode(\u0026self) -\u003e QrCode {\n        QrCode::new(\u0026self.data).unwrap()\n    }\n\n    /// Converts the QRCode structure to a PNG image.\n    pub fn to_png(\u0026self, width: u32) -\u003e ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\n        let qrcode = self.to_qrcode();\n        let height = width;\n        let mut img = ImageBuffer::new(width, height);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n            let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n            *pixel = match qrcode[(x_index as usize, y_index as usize)] {\n                qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n            };\n        }\n        img\n    }\n    /// Converts the QRCode structure to a JPG image.\n    pub fn to_jpg(\u0026self, width: u32) -\u003e ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\n        let qrcode = self.to_qrcode();\n        let height = width;\n        let mut img = ImageBuffer::new(width, height);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n            let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n            *pixel = match qrcode[(x_index as usize, y_index as usize)] {\n                qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n            };\n        }\n        img\n    }\n    /// Converts the QRCode structure to a GIF image.\n    pub fn to_gif(\u0026self, width: u32) -\u003e ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\n        let qrcode = self.to_qrcode();\n        let height = width;\n        let mut img = ImageBuffer::new(width, height);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n            let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n            *pixel = match qrcode[(x_index as usize, y_index as usize)] {\n                qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n            };\n        }\n        img\n    }\n\n    /// Converts the QRCode structure to an SVG image.\n    pub fn to_svg(\u0026self, width: u32) -\u003e String {\n        let qrcode = self.to_qrcode();\n        let svg_string = qrcode\n            .render::\u003csvg::Color\u003e()\n            .min_dimensions(width, width)\n            .dark_color(svg::Color(\"#000000\"))\n            .light_color(svg::Color(\"#FFFFFF\"))\n            .build();\n        svg_string\n    }\n\n    /// The `colorize` method creates a new PNG image of the QR code\n    /// using the data stored in the QRCode and the given color value to\n    /// colorize the QR code.\n    pub fn colorize(\u0026self, color: Rgba\u003cu8\u003e) -\u003e RgbaImage {\n        let qrcode = self.to_qrcode();\n        let mut img: RgbaImage = ImageBuffer::new(qrcode.width() as u32, qrcode.width() as u32);\n        for (x, y, pixel) in img.enumerate_pixels_mut() {\n            let c = if qrcode[(x as usize, y as usize)] == qrcode::Color::Dark {\n                color\n            } else {\n                Rgba([255, 255, 255, 255])\n            };\n            *pixel = c;\n        }\n        img\n    }\n\n    /// The `resize` method creates a new PNG image of the QR code using\n    /// the data stored in the QRCode and the given width and height\n    /// values to resize the QR code.\n    pub fn resize(\u0026self, width: u32, height: u32) -\u003e RgbaImage {\n        let qrcode = self.to_qrcode();\n        let mut img: RgbaImage = ImageBuffer::new(width, height);\n        for y in 0..height {\n            for x in 0..width {\n                let x_index = (x as f32 / width as f32) * qrcode.width() as f32;\n                let y_index = (y as f32 / height as f32) * qrcode.width() as f32;\n                let c = match qrcode[(x_index as usize, y_index as usize)] {\n                    qrcode::Color::Dark =\u003e Rgba([0, 0, 0, 0]),\n                    qrcode::Color::Light =\u003e Rgba([255, 255, 255, 255]),\n                };\n                img.put_pixel(x, y, c);\n            }\n        }\n        img\n    }\n    /// The `add_image_watermark` method adds a watermark to the given image.\n    pub fn add_image_watermark(img: \u0026mut RgbaImage, watermark: \u0026RgbaImage) {\n        let (width, height) = img.dimensions();\n        let (watermark_width, watermark_height) = watermark.dimensions();\n\n        // position the watermark in the bottom right corner\n        let x = width - watermark_width;\n        let y = height - watermark_height;\n\n        // draw the watermark on the QR code image\n        for (dx, dy, watermark_pixel) in watermark.enumerate_pixels() {\n            let x = x + dx;\n            let y = y + dy;\n            let qr_pixel = img.get_pixel(x, y);\n\n            let alpha = (watermark_pixel[3] as f32) / 255.0;\n            let new_r = (1.0 - alpha) * (qr_pixel[0] as f32) + alpha * (watermark_pixel[0] as f32);\n            let new_g = (1.0 - alpha) * (qr_pixel[1] as f32) + alpha * (watermark_pixel[1] as f32);\n            let new_b = (1.0 - alpha) * (qr_pixel[2] as f32) + alpha * (watermark_pixel[2] as f32);\n            let new_a = (qr_pixel[3] as f32) + alpha * (255.0 - qr_pixel[3] as f32);\n\n            let new_pixel = [new_r as u8, new_g as u8, new_b as u8, new_a as u8];\n            img.put_pixel(x, y, image::Rgba(new_pixel));\n        }\n    }\n}\n\n#[macro_export]\n/// The `add_emoji_watermark` macro creates a new instance of the QRCode struct\n/// with the given data.\nmacro_rules! add_image_watermark {\n    ($img:expr, $watermark:expr) =\u003e {\n        QRCode::add_image_watermark($img, $watermark)\n    };\n}\n\n#[macro_export]\n/// The `qr_code` macro creates a new instance of the QRCode struct\n/// with the given data.\nmacro_rules! qr_code {\n    ($data:expr) =\u003e {\n        QRCode::new($data)\n    };\n}\n\n#[macro_export]\n/// Define a macro named `qr_code_to`\nmacro_rules! qr_code_to {\n    // This macro takes two expressions: `$data` and `$format`\n    ($data:expr, $format:expr, $width:expr) =\u003e {\n        // Match the value of `$format`\n        match $format {\n            // If `$format` is equal to \"png\", generate a PNG format QR code using `QRCode::from_bytes`\n            \"png\" =\u003e QRCode::from_bytes($data).to_png($width),\n            // If `$format` is equal to \"jpg\", generate a JPG format QR code using `QRCode::from_bytes`\n            \"jpg\" =\u003e QRCode::from_bytes($data).to_jpg($width),\n            // If `$format` is equal to \"gif\", generate a \"gif\" format QR code using `QRCode::from_bytes`\n            \"gif\" =\u003e QRCode::from_bytes($data).to_gif($width),\n            // For any other value, panic with the message \"Invalid format\"\n            _ =\u003e panic!(\"Invalid format\"),\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","qrc","tests","qr.rs"],"content":"#[cfg(test)]\nmod tests {\n    extern crate image;\n    use image::{Rgba, RgbaImage};\n\n    extern crate qrc;\n    use qrc::{add_image_watermark, qr_code, qr_code_to, QRCode};\n\n    const URL: \u0026str = \"https://minifunctions.com/\"; // Define a constant for the URL to be encoded\n\n    #[test]\n    fn test_new() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::new(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n\n    #[test]\n    fn test_from_string() {\n        let data = \"abc\".to_string();\n        let qrcode = QRCode::from_string(data.clone());\n        assert_eq!(qrcode.data, data.into_bytes());\n    }\n\n    #[test]\n    fn test_from_bytes() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n\n    #[test]\n    fn test_to_qrcode() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n\n    #[test]\n    fn test_to_png() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(\"Hello, world!\".to_string());\n        let png = qrcode.to_png(21);\n        assert_eq!(png.dimensions(), (21, 21));\n\n        let png_data = png.into_raw();\n        assert_eq!(png_data.len(), 1764);\n    }\n    #[test]\n    fn test_to_svg() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let qrcode_svg = qrcode.to_svg(512);\n        assert_eq!(qrcode_svg.len(), 6918);\n    }\n    #[test]\n    fn test_to_gif() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let qrcode_gif = qrcode.to_gif(512);\n        assert_eq!(qrcode_gif.len(), 1048576);\n    }\n    #[test]\n    fn test_to_jpg() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let qrcode_jpg = qrcode.to_jpg(512);\n        assert_eq!(qrcode_jpg.len(), 1048576);\n    }\n    #[test]\n    fn test_add_image_watermark() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = QRCode::from_bytes(data.clone());\n        assert_eq!(qrcode.data, data);\n\n        let qrcode = QRCode::from_string(URL.to_string());\n        let mut qrcode_img = qrcode.to_png(512);\n        let watermark_img = image::open(\"bubba.ico\").unwrap().into_rgba8();\n        add_image_watermark!(\u0026mut qrcode_img, \u0026watermark_img);\n        assert_eq!(qrcode_img.dimensions(), (512, 512));\n    }\n    #[test]\n    fn test_colorize() {\n        // Create a new QR code with some data.\n        let qrcode = QRCode::new(vec![0, 1, 2, 3]);\n\n        // Colorize the QR code with a red color.\n        let red_qrcode = qrcode.colorize(Rgba([255, 0, 0, 255]));\n\n        // Convert the QR code to a PNG image and assert that all of the dark cells are red.\n        let image: RgbaImage = red_qrcode;\n        for (x, y, pixel) in image.enumerate_pixels() {\n            let expected_color =\n                if qrcode.to_qrcode()[(x as usize, y as usize)] == qrcode::Color::Dark {\n                    Rgba([255, 0, 0, 255])\n                } else {\n                    Rgba([255, 255, 255, 255])\n                };\n            assert_eq!(*pixel, expected_color);\n        }\n    }\n    #[test]\n    fn test_resize() {\n        // Create a new QR code with some data.\n        let qrcode = QRCode::new(vec![0, 1, 2, 3]);\n\n        // Resize the QR code to 42x42 pixels.\n        let resized_qrcode = qrcode.resize(42, 42);\n\n        // Convert the QR code to a PNG image and assert that the dimensions are correct.\n        let image: RgbaImage = resized_qrcode;\n        assert_eq!(image.dimensions(), (42, 42));\n    }\n\n    #[test]\n    fn test_qr_code() {\n        let data = vec![0x61, 0x62, 0x63];\n        let qrcode = qr_code!(data.clone());\n        assert_eq!(qrcode.data, data);\n    }\n    #[test]\n    fn test_qr_code_from_png() {\n        let data = vec![0x61, 0x62, 0x63];\n        let result = qr_code_to!(data.clone(), \"png\", 512);\n        let expected = QRCode::from_bytes(data).to_png(512);\n        assert_eq!(result, expected);\n    }\n    #[test]\n    #[should_panic(expected = \"Invalid format\")]\n    fn test_qr_code_from_invalid_format() {\n        let data = vec![0u8, 1, 2, 3];\n        let _result = qr_code_to!(data, \"jpeg\", 512);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","benches","rlg.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nextern crate rlg;\nuse rlg::*;\n\nfn new_benchmark(c: \u0026mut Criterion) {\n    c.bench_function(\"new\", |b| {\n        b.iter(|| {\n            let log = Log::new(\n                \"123\",\n                \"2023-01-23 14:04:09.881393 +00:00:00\",\n                \u0026LogLevel::INFO,\n                \"test\",\n                \"test log message\",\n                \u0026LogFormat::CLF,\n            );\n            black_box(log);\n        })\n    });\n}\ncriterion_group!(benches, new_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","examples","rlg.rs"],"content":"extern crate dtt;\nextern crate rlg;\n\nuse self::dtt::DateTime;\nuse self::rlg::{Log, LogFormat, LogLevel};\n\nfn main() {\n    let date = DateTime::new();\n    let iso = date.iso_8601;\n    let log_formats = vec![\n        LogFormat::CLF,\n        LogFormat::JSON,\n        LogFormat::CEF,\n        LogFormat::ELF,\n        LogFormat::GELF,\n        LogFormat::W3C,\n    ];\n\n    for format in log_formats {\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026iso,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026format,\n        );\n        println!(\"ðŸ¦€ Log::new():            âœ… {log}\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library that implements application-level logging with a simple, readable output format\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-rlg.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Rust Logs (RLG) is a library that implements application-level\n//! logging in a simple, readable output format. The library provides\n//! logging APIs and various helper macros that simplify many common\n//! logging tasks.\n\n//!\n//! ## Features\n//!\n//!- Supports many log levels: `ALL`, `DEBUG`, `DISABLED`, `ERROR`,\n//!  `FATAL`, `INFO`, `NONE`, `TRACE`, `VERBOSE` and `WARNING`,\n//!- Provides structured log formats that are easy to parse and filter,\n//!- Compatible with multiple output formats including:\n//!  - Common Event Format (CEF),\n//!  - Extended Log Format (ELF),\n//!  - Graylog Extended Log Format (GELF),\n//!  - JavaScript Object Notation (JSON),\n//!  - NCSA Common Log Format (CLF),\n//!  - W3C Extended Log File Format (W3C),\n//!  - and many more\n//!\n//! ## Usage\n//!\n//! - [`serde`][]: Enable serialization/deserialization via serde\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-rlg.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-rlg.svg\",\n    html_root_url = \"https://docs.rs/rlg\"\n)]\n#![crate_name = \"rlg\"]\n#![crate_type = \"lib\"]\n\nuse std::{\n    fmt::{self, Write},\n    io,\n};\n\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\n/// An enumeration of the different log formats that can be used.\npub enum LogFormat {\n    /// The log format is set to CLF.\n    CLF,\n    /// The log format is set to JSON.\n    JSON,\n    /// The log format is set to CEF.\n    CEF,\n    /// The log format is set to ELF.\n    ELF,\n    /// The log format is set to W3C.\n    W3C,\n    /// The log format is set to GELF.\n    GELF,\n}\n\nimpl fmt::Display for LogFormat {\n    /// Implements [`LogFormat`] to display the log format as a string.\n    /// It allows the LogFormat enumeration to be used with the write!\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            LogFormat::CEF =\u003e write!(f, \"CEF\"),\n            LogFormat::CLF =\u003e write!(f, \"CLF\"),\n            LogFormat::ELF =\u003e write!(f, \"ELF\"),\n            LogFormat::GELF =\u003e write!(f, \"GELF\"),\n            LogFormat::JSON =\u003e write!(f, \"JSON\"),\n            LogFormat::W3C =\u003e write!(f, \"W3C\"),\n        }\n    }\n}\n\n/// Implements [`Log`] to log a message to the console with a simple,\n/// readable output format.\n///\n/// # Arguments\n///\n/// * `session_id` - A string slice that holds a session ID. The session\n///    ID is a unique identifier for the current session. A random GUID\n///    (Globally Unique Identifier) is generated by default.\n/// * `time` - A string slice that holds the timestamp in ISO 8601\n///    format.\n/// * `level` - A string slice that holds the level (INFO, WARN, ERROR,\n///     etc.).\n/// * `component` - A string slice that holds the component name.\n/// * `description` - A string slice that holds the description of the\n///    log message.\n///\n\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\n/// An enumeration of the different levels that a log message can have.\n/// Each variant of the enumeration represents a different level of\n/// importance.\n///\n/// # Arguments\n///\n/// * `ALL` - The log level is set to all.\n/// * `DEBUG` - The log level is set to debug.\n/// * `DISABLED` - The log level is set to disabled.\n/// * `ERROR` - The log level is set to error.\n/// * `FATAL` - The log level is set to fatal.\n/// * `INFO` - The log level is set to info.\n/// * `NONE` - The log level is set to none.\n/// * `TRACE` - The log level is set to trace.\n/// * `VERBOSE` - The log level is set to verbose.\n/// * `WARNING` - The log level is set to warning.\n///\npub enum LogLevel {\n    /// The log level is set to all.\n    ALL,\n    /// The log level is set to debug.\n    DEBUG,\n    /// The log level is set to disabled.\n    DISABLED,\n    /// The log level is set to error.\n    ERROR,\n    /// The log level is set to fatal.\n    FATAL,\n    /// The log level is set to info.\n    INFO,\n    /// The log level is set to none.\n    NONE,\n    /// The log level is set to trace.\n    TRACE,\n    /// The log level is set to verbose.\n    VERBOSE,\n    /// The log level is set to warning.\n    WARNING,\n}\n\n/// Implements [`LogLevel`] to display the log level as a string. It\n/// allows the LogLevel enumeration to be used with the write! and\n/// print! macros. It provides a human-readable string representation of\n/// the variant, that will be used when displaying the log message.\nimpl fmt::Display for LogLevel {\n    /// Implements [`LogLevel`] to display the log level as a string.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            LogLevel::ALL =\u003e write!(f, \"ALL\"),\n            LogLevel::DEBUG =\u003e write!(f, \"DEBUG\"),\n            LogLevel::DISABLED =\u003e write!(f, \"DISABLED\"),\n            LogLevel::ERROR =\u003e write!(f, \"ERROR\"),\n            LogLevel::FATAL =\u003e write!(f, \"FATAL\"),\n            LogLevel::INFO =\u003e write!(f, \"INFO\"),\n            LogLevel::NONE =\u003e write!(f, \"NONE\"),\n            LogLevel::TRACE =\u003e write!(f, \"TRACE\"),\n            LogLevel::VERBOSE =\u003e write!(f, \"VERBOSE\"),\n            LogLevel::WARNING =\u003e write!(f, \"WARNING\"),\n        }\n    }\n}\n\n#[non_exhaustive]\n#[derive(Debug, Clone, PartialEq, PartialOrd)]\n/// The `Log` struct provides an easy way to log a message to the\n/// console. It contains a set of defined fields to create a simple,\n/// log message with a readable output format.\n///\n/// # Arguments\n///\n/// * `session_id` - A string slice that holds a session ID. The session\n///    ID is a unique identifier for the current session. A random GUID\n///    (Globally Unique Identifier) is generated by default.\n/// * `time` - A string slice that holds the timestamp in ISO 8601\n///    format.\n/// * `level` - A string slice that holds the level (INFO, WARN, ERROR,\n///     etc.).\n/// * `component` - A string slice that holds the component name.\n/// * `description` - A string slice that holds the description of the\n///    log message.\n///\npub struct Log {\n    /// A string that holds a session ID. The session ID is a unique\n    /// identifier for the current session. A random GUID (Globally\n    /// Unique Identifier) is generated by default.\n    pub session_id: String,\n    /// A string that holds the timestamp in ISO 8601 format.\n    pub time: String,\n    /// A string that holds the level (INFO, WARN, ERROR, etc.).\n    pub level: LogLevel,\n    /// A string that holds the component name.\n    pub component: String,\n    /// A string that holds the description of the log message.\n    pub description: String,\n    /// A string that holds the log format.\n    pub format: LogFormat,\n}\n\n/// This implementation allows the Log struct to be created with default\n/// values. It creates a new instance of the Log struct with empty\n/// strings for the session_id, time, component and description fields,\n///  and LogLevel::INFO for level field. This is useful when creating a\n/// new instance of the Log struct. It allows the struct to be created\n/// with default values, and then the fields can be set to the desired\n/// values.\nimpl Default for Log {\n    /// This implementation allows the Log struct to be created with\n    /// default values.\n    fn default() -\u003e Log {\n        Log {\n            session_id: String::default(),\n            time: String::default(),\n            level: LogLevel::INFO,\n            component: String::default(),\n            description: String::default(),\n            format: LogFormat::CLF,\n        }\n    }\n}\n\nimpl Log {\n    /// Logs a message to the console using a pre-allocated buffer to\n    /// reduce memory allocation and flush the output buffer to ensure\n    /// that the message is written immediately.\n    ///\n    /// # Errors\n    ///\n    /// This function will panic if an error occurs when writing to the\n    /// pre-allocated buffer or flushing the output buffer.\n    ///\n    pub fn log(\u0026self) {\n        let mut log_message = String::with_capacity(256);\n        match self.format {\n        LogFormat::CLF =\u003e write!(\n        log_message,\n        \"SessionID={} Timestamp={} Description={} Level={} Component={} Format={}\",\n        self.session_id, self.description, self.time, self.level, self.component, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::JSON =\u003e write!(\n        log_message,\n        \"{{\\\"SessionID\\\":\\\"{}\\\",\\\"Timestamp\\\":\\\"{}\\\",\\\"Level\\\":\\\"{}\\\",\\\"Component\\\":\\\"{}\\\",\\\"Description\\\":\\\"{}\\\"}} Format={}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::CEF =\u003e write!(\n        log_message,\n                \"CEF:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::ELF =\u003e write!(\n        log_message,\n        \"ELF:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::W3C =\u003e write!(\n        log_message,\n        \"W3C:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        LogFormat::GELF =\u003e write!(\n        log_message,\n        \"GELF:0|{}|{}|{}|{}|{}|{}\",\n        self.session_id, self.time, self.level, self.component, self.description, self.format\n        )\n        .expect(\"Unable to write log message\"),\n        }\n        println!(\"{log_message}\");\n        io::Write::flush(\u0026mut io::stdout()).expect(\"Unable to flush stdout\");\n    }\n\n    /// Creates a new instance of the `Log` struct with the provided\n    /// parameters.\n    ///\n    /// # Parameters\n    /// * `component`: A string slice representing the component.\n    /// * `description`: A string slice representing the log description.\n    /// * `format`: A string slice representing the log format.\n    /// * `level`: A string slice representing the log level.\n    /// * `session_id`: A string slice representing the session ID.\n    /// * `time`: A string slice representing the timestamp.\n    ///\n    /// # Returns\n    ///\n    /// A new instance of the `Log` struct with the provided parameters.\n    #[must_use]\n    pub fn new(\n        session_id: \u0026str,\n        time: \u0026str,\n        level: \u0026LogLevel,\n        component: \u0026str,\n        description: \u0026str,\n        format: \u0026LogFormat,\n    ) -\u003e Self {\n        Self {\n            session_id: session_id.to_string(),\n            time: time.to_string(),\n            level: level.clone(),\n            component: component.to_string(),\n            description: description.to_string(),\n            format: format.clone(),\n        }\n    }\n}\n\nimpl fmt::Display for Log {\n    /// Formats the value using the given formatter.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self.format {\n            LogFormat::CLF =\u003e {\n                write!(\n                    f,\n                    \"SessionID={} Timestamp={} Description={} Level={} Component={}\",\n                    self.session_id, self.time, self.description, self.level, self.component\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::JSON =\u003e {\n                write!(\n                f,\n                \"{{\\\"SessionID\\\":\\\"{}\\\",\\\"Timestamp\\\":\\\"{}\\\",\\\"Level\\\":\\\"{}\\\",\\\"Component\\\":\\\"{}\\\",\\\"Description\\\":\\\"{}\\\",\\\"Format\\\":\\\"JSON\\\"}}\",\n                self.session_id, self.time, self.level, self.component, self.description)\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::CEF =\u003e {\n                write!(\n                    f,\n                    \"CEF:0|{}|{}|{}|{}|{}|CEF\",\n                    self.session_id, self.time, self.level, self.component, self.description\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::ELF =\u003e {\n                write!(\n                    f,\n                    \"ELF:0|{}|{}|{}|{}|{}|ELF\",\n                    self.session_id, self.time, self.level, self.component, self.description\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::W3C =\u003e {\n                write!(\n                    f,\n                    \"W3C:0|{}|{}|{}|{}|{}|W3C\",\n                    self.session_id, self.time, self.level, self.component, self.description\n                )\n                // self.session_id, self.time, self.level, self.component, self.description)\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n            LogFormat::GELF =\u003e {\n                write!(\n                    f,\n                    r#\"{{\n                            \"version\": \"1.1\",\n                            \"host\": \"{}\",\n                            \"short_message\": \"{}\",\n                            \"level\": \"{:?}\",\n                            \"timestamp\": \"{}\",\n                            \"_component\": \"{}\",\n                            \"_session_id\": \"{}\"\n                        }}\"#,\n                    self.component,\n                    self.description,\n                    self.level,\n                    self.time,\n                    self.component,\n                    self.session_id\n                )\n                .expect(\"Unable to write log message\");\n                Ok(())\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","rlg","tests","rlg.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n\n    extern crate dtt;\n    extern crate rlg;\n\n    use self::dtt::DateTime;\n    use self::rlg::LogLevel::ERROR;\n    use self::rlg::{Log, LogFormat, LogLevel};\n    use rlg::LogFormat::CLF;\n\n    #[test]\n    fn test_log_common_format() {\n        let log = Log::new(\n            \"session_id_123\",\n            \"2022-01-01T00:00:00Z\",\n            \u0026ERROR,\n            \"component_a\",\n            \"description_a\",\n            \u0026CLF,\n        );\n        let expected_output = \"SessionID=session_id_123 Timestamp=2022-01-01T00:00:00Z Description=description_a Level=ERROR Component=component_a\";\n        assert_eq!(log.to_string(), expected_output);\n    }\n\n    #[test]\n    fn test_log_error() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_warn() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_debug() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_trace() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_info() {\n        let date = DateTime::new();\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \u0026date.now,\n            \u0026LogLevel::INFO,\n            \"SystemTrayEvent\",\n            \"Showing main window\",\n            \u0026LogFormat::CLF,\n        );\n        log.log();\n    }\n    #[test]\n    fn test_log_level_display() {\n        let log_level = LogLevel::ERROR;\n        assert_eq!(log_level.to_string(), \"ERROR\");\n\n        let log_level = LogLevel::WARNING;\n        assert_eq!(log_level.to_string(), \"WARNING\");\n    }\n\n    #[test]\n    fn test_log_display() {\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \"2023-01-23 14:03:00.000+0000\",\n            \u0026LogLevel::ERROR,\n            \"Test\",\n            \"This is a test log message\",\n            \u0026LogFormat::CLF,\n        );\n        assert_eq!(\n        log.to_string(),\n        \"SessionID=12345678-1234-1234-1234-1234567890ab Timestamp=2023-01-23 14:03:00.000+0000 Description=This is a test log message Level=ERROR Component=Test\");\n    }\n\n    #[test]\n    fn test_log_default() {\n        let log = Log::default();\n        assert_eq!(log.session_id, \"\");\n        assert_eq!(log.time, \"\");\n        assert_eq!(log.level, LogLevel::INFO);\n        assert_eq!(log.component, \"\");\n        assert_eq!(log.description, \"\");\n    }\n\n    #[test]\n    fn test_log_common() {\n        let log = Log::new(\n            \"12345678-1234-1234-1234-1234567890ab\",\n            \"2023-01-23 14:03:00.000+0000\",\n            \u0026LogLevel::ERROR,\n            \"Test\",\n            \"This is a test log message\",\n            \u0026LogFormat::CLF,\n        );\n        let log_string = format!(\"{log}\");\n        println!(\"{log_string}\");\n        assert_eq!(log_string, \"SessionID=12345678-1234-1234-1234-1234567890ab Timestamp=2023-01-23 14:03:00.000+0000 Description=This is a test log message Level=ERROR Component=Test\");\n    }\n\n    #[test]\n    fn test_log_level_all_display() {\n        let log_level = LogLevel::ALL;\n        assert_eq!(log_level.to_string(), \"ALL\");\n    }\n\n    #[test]\n    fn test_log_level_debug_display() {\n        let log_level = LogLevel::DEBUG;\n        assert_eq!(log_level.to_string(), \"DEBUG\");\n    }\n\n    #[test]\n    fn test_log_level_disabled_display() {\n        let log_level = LogLevel::DISABLED;\n        assert_eq!(log_level.to_string(), \"DISABLED\");\n    }\n\n    #[test]\n    fn test_log_level_error_display() {\n        let log_level = LogLevel::ERROR;\n        assert_eq!(log_level.to_string(), \"ERROR\");\n    }\n\n    #[test]\n    fn test_log_level_fatal_display() {\n        let log_level = LogLevel::FATAL;\n        assert_eq!(log_level.to_string(), \"FATAL\");\n    }\n\n    #[test]\n    fn test_log_level_info_display() {\n        let log_level = LogLevel::INFO;\n        assert_eq!(log_level.to_string(), \"INFO\");\n    }\n\n    #[test]\n    fn test_log_level_none_display() {\n        let log_level = LogLevel::NONE;\n        assert_eq!(log_level.to_string(), \"NONE\");\n    }\n\n    #[test]\n    fn test_log_level_trace_display() {\n        let log_level = LogLevel::TRACE;\n        assert_eq!(log_level.to_string(), \"TRACE\");\n    }\n\n    #[test]\n    fn test_log_level_verbose_display() {\n        let log_level = LogLevel::VERBOSE;\n        assert_eq!(log_level.to_string(), \"VERBOSE\");\n    }\n\n    #[test]\n    fn test_log_level_warning_display() {\n        let log_level = LogLevel::WARNING;\n        assert_eq!(log_level.to_string(), \"WARNING\");\n    }\n    #[test]\n    fn test_common_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::CLF,\n        );\n        let expected_output = \"SessionID=123 Timestamp=2023-01-23 14:04:09.881393 +00:00:00 Description=test log message Level=INFO Component=test\";\n        assert_eq!(log.to_string(), expected_output);\n    }\n\n    #[test]\n    fn test_json_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::JSON,\n        );\n        let expected_output = \"{\\\"SessionID\\\":\\\"123\\\",\\\"Timestamp\\\":\\\"2023-01-23 14:04:09.881393 +00:00:00\\\",\\\"Level\\\":\\\"INFO\\\",\\\"Component\\\":\\\"test\\\",\\\"Description\\\":\\\"test log message\\\",\\\"Format\\\":\\\"JSON\\\"}\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n\n    #[test]\n    fn test_cef_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::CEF,\n        );\n        let expected_output =\n            \"CEF:0|123|2023-01-23 14:04:09.881393 +00:00:00|INFO|test|test log message|CEF\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_elf_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::ELF,\n        );\n        let expected_output =\n            \"ELF:0|123|2023-01-23 14:04:09.881393 +00:00:00|INFO|test|test log message|ELF\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_w3c_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::W3C,\n        );\n        let expected_output =\n            \"W3C:0|123|2023-01-23 14:04:09.881393 +00:00:00|INFO|test|test log message|W3C\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_gelf_log_format() {\n        let log = Log::new(\n            \"123\",\n            \"2023-01-23 14:04:09.881393 +00:00:00\",\n            \u0026LogLevel::INFO,\n            \"test\",\n            \"test log message\",\n            \u0026LogFormat::GELF,\n        );\n        let expected_output =\n            \"{\\n                            \\\"version\\\": \\\"1.1\\\",\\n                            \\\"host\\\": \\\"test\\\",\\n                            \\\"short_message\\\": \\\"test log message\\\",\\n                            \\\"level\\\": \\\"INFO\\\",\\n                            \\\"timestamp\\\": \\\"2023-01-23 14:04:09.881393 +00:00:00\\\",\\n                            \\\"_component\\\": \\\"test\\\",\\n                            \\\"_session_id\\\": \\\"123\\\"\\n                        }\";\n        assert_eq!(expected_output, format!(\"{log}\"));\n    }\n    #[test]\n    fn test_log_format_display() {\n        for (log_format, expected_output) in vec![\n            (LogFormat::CLF, \"CLF\"),\n            (LogFormat::JSON, \"JSON\"),\n            (LogFormat::CEF, \"CEF\"),\n            (LogFormat::ELF, \"ELF\"),\n            (LogFormat::W3C, \"W3C\"),\n            (LogFormat::GELF, \"GELF\"),\n        ] {\n            assert_eq!(log_format.to_string(), expected_output);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! A Rust library of highly performant utility and wrapper functions\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-mini-functions.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions)\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/mini-functions.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/mini-functions)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.8-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/mini-functions)\n//! [![License](https://img.shields.io/crates/l/mini-functions.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! Mini-Functions is a modern Rust library that prioritizes performance\n//! , security, and modularity. It provides a low-overhead access to\n//! functions for common programming tasks.\n//!\n//! ## Features\n//!\n//! - **[Claims](../claims/index.html)** - Provides access to the claims\n//! of a JSON Web Token (JWT).\n//! - **[Common](../common/index.html)** - Provides access to common\n//! functions and constants.\n//! - **[Date](../date/index.html)** - Provides access to the current\n//! date and time.\n//! - **[Errors](../errors/index.html)** - Provides access to error\n//! handling functions.\n//! - **[Hash](../hash/index.html)** - Provides access to hash\n//! functions.\n//! - **[Jot](../cjwt/index.html)** - Provides access to JSON Web Token\n//! (JWT) functions.\n//! - **[rlg](../rlg/index.html)** - Provides access to logging\n//! functions.\n//! - **[MD5](../mdg/index.html)** - Provides access to MD5 functions.\n//! - **[Password](../password/index.html)** - Provides access to\n//! password functions.\n//! - **[QR](../qr/index.html)** - Provides access to QR code functions.\n//! - **[Random](../vrd/index.html)** - Provides access to random\n//! number functions.\n//! - And so much more.\n//!\n//! These components provide a comprehensive set of functionality and\n//! offer powerful new capabilities to help you build better\n//! applications and services in the Rust programming language.\n//!\n//! [**Learn more**](https://minifunctions.com) [â¯](https://minifunctions.com)\n//!\n//!\n//! ## Installation\n//!\n//! Mini Functions is available on both\n//! [Crates.io](https://crates.io/crates/mini_functions) and\n//! [Lib.rs](https://lib.rs/crates/mini_functions).\n//!\n//! Learn more about Mini Functions at \u003chttps://minifunctions.com\u003e.\n//!\n//! Add the following to your `Cargo.toml` file:\n//! ```toml\n//! [dependencies]\n//! mini_functions = \"0.0.8\"\n//! ```\n//! Then, add the following to your crate root:\n//! ```rust\n//! extern crate mini_functions;\n//!\n//! use mini_functions::mini_functions::*;\n//!\n//! ```\n//!\n//!\n#![warn(missing_docs)]\n#![forbid(unsafe_code)]\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mini-functions.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-mini-functions.svg\",\n    html_root_url = \"https://docs.rs/mini-functions\"\n)]\n#![crate_name = \"mini_functions\"]\n#![crate_type = \"dylib\"]\n#![crate_type = \"lib\"]\n#![crate_type = \"rlib\"]\n#![crate_type = \"staticlib\"]\n\n/// Mini-Functions module that provides a variety of features for\n/// building apps, including several major crates that you can use\n/// individually or together to construct the core infrastructure of\n/// your Rust applications.\npub mod mini_functions {\n    /// Provides access to common functions and constants.\n    pub use cmn::*;\n\n    /// Provides access to the claims of a JSON Web Token (JWT).\n    pub use claims::*;\n\n    /// Provides access to Date functions.\n    pub use dtt::*;\n\n    /// Provides access to Error handling functions.\n    pub use idk::*;\n\n    /// Provides access to Hash functions.\n    pub use hsh::*;\n\n    /// Provides access to JSON Web Token (JWT) functions.\n    pub use cjwt::*;\n\n    /// Provides access to Log functions.\n    pub use rlg::*;\n\n    /// Provides access to MD5 functions.\n    pub use mdg::*;\n\n    /// Provides access to QR code functions.\n    pub use qrc::*;\n\n    /// Provides access to Random numbers functions.\n    pub use vrd::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","benches","vrd.rs"],"content":"extern crate criterion;\nextern crate vrd;\nuse self::vrd::Random;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn benchmark_random(c: \u0026mut Criterion) {\n    // Benchmark the random bool function\n    c.bench_function(\"Random bool\", |b| {\n        b.iter(|| Random::bool(\u0026mut Random::new(), black_box(0.5)))\n    });\n\n    // Benchmark the random bytes function\n    c.bench_function(\"Random bytes\", |b| {\n        b.iter(|| Random::bytes(\u0026mut Random::new(), black_box(1000)))\n    });\n\n    // Benchmark the random char function\n    c.bench_function(\"Random char\", |b| {\n        b.iter(|| Random::char(\u0026mut Random::new()))\n    });\n\n    // Benchmark the random choose function\n    c.bench_function(\"Random choose\", |b| {\n        b.iter(|| {\n            let mut rng = Random::new();\n            let values = vec![1, 2, 3, 4, 5];\n            Random::choose(\u0026mut rng, \u0026values);\n        })\n    });\n\n    // Benchmark the random float function\n    c.bench_function(\"Random float\", |b| {\n        b.iter(|| Random::float(\u0026mut Random::new()))\n    });\n\n    // Benchmark the random int function\n    c.bench_function(\"Random int\", |b| {\n        b.iter(|| Random::int(\u0026mut Random::new(), black_box(0), black_box(100)))\n    });\n\n    // Benchmark the random new function\n    c.bench_function(\"Random new\", |b| b.iter(|| Random::new));\n\n    // Benchmark the random pseudo function\n    c.bench_function(\"Random pseudo\", |b| {\n        let mut rng = Random::new();\n        b.iter(|| rng.pseudo())\n    });\n\n    // Benchmark the random function\n    c.bench_function(\"Random random\", |b| {\n        let mut rng = Random::new();\n        b.iter(|| rng.rand())\n    });\n\n    // Benchmark the random range function\n    c.bench_function(\"Random range\", |b| {\n        let mut rng = Random::new();\n        b.iter(|| rng.range(black_box(0), black_box(100)))\n    });\n}\n\ncriterion_group!(benches, benchmark_random);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","build.rs"],"content":"fn main() {\n    // println!(\"cargo:rerun-if-changed=src/lib.rs\");\n    // println!(\"cargo:rerun-if-changed=build.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","examples","vrd.rs"],"content":"extern crate vrd;\nuse self::vrd::Random;\n\nfn main() {\n    // Create a new random boolean\n    let bool: bool = Random::bool(\u0026mut Random::new(), 0.5);\n    println!(\"ðŸ¦€ Random::bool():        âœ… {bool}\");\n\n    // Create a new random number generator\n    let mut rng = Random::new();\n    println!(\"ðŸ¦€ Random::new():         âœ… {rng}\");\n\n    let default = Random::default();\n    println!(\"ðŸ¦€ Random::default():     âœ… {default}\");\n\n    let random = rng.rand();\n    println!(\"ðŸ¦€ Random::random():      âœ… {random}\");\n\n    let pseudo = rng.pseudo();\n    println!(\"ðŸ¦€ Random::pseudo():      âœ… {pseudo}\");\n\n    let bytes = Random::bytes(\u0026mut rng, 1000);\n    println!(\"ðŸ¦€ Random::bytes():       âœ… {bytes:?}\");\n\n    let float = rng.rand() as f32 / 0x7FFF as f32;\n    println!(\"ðŸ¦€ Random::float():       âœ… {float}\");\n\n    let int = rng.rand() as usize;\n    println!(\"ðŸ¦€ Random::int():         âœ… {int}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","src","lib.rs"],"content":"// Copyright Â© 2022-2023 Mini Functions. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n//!\n//! # A Rust library for generating random and pseudo-random numbers based on the Mersenne Twister algorithm\n//!\n//! [![Rust](https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/logo/logo-vrd.svg)](https://minifunctions.com)\n//!\n//! \u003ccenter\u003e\n//!\n//! [![Rust](https://img.shields.io/badge/rust-f04041?style=for-the-badge\u0026labelColor=c0282d\u0026logo=rust)](https://www.rust-lang.org)\n//! [![Crates.io](https://img.shields.io/crates/v/vrd.svg?style=for-the-badge\u0026color=success\u0026labelColor=27A006)](https://crates.io/crates/vrd)\n//! [![Lib.rs](https://img.shields.io/badge/lib.rs-v0.0.1-success.svg?style=for-the-badge\u0026color=8A48FF\u0026labelColor=6F36E4)](https://lib.rs/crates/vrd)\n//! [![GitHub](https://img.shields.io/badge/github-555555?style=for-the-badge\u0026labelColor=000000\u0026logo=github)](https://github.com/sebastienrousseau/mini-functions/tree/main/vrd)\n//! [![License](https://img.shields.io/crates/l/vrd.svg?style=for-the-badge\u0026color=007EC6\u0026labelColor=03589B)](http://opensource.org/licenses/MIT)\n//!\n//! \u003c/center\u003e\n//!\n//! ## Overview\n//!\n//! This crate provides a random number generator based on the Mersenne\n//! Twister algorithm. The Mersenne Twister algorithm is a pseudorandom\n//! number generator (PRNG) developed by Makoto Matsumoto and Takuji\n//! Nishimura in 1997. It is based on a linear feedback shift register\n//! (LFSR) and is designed to have a period of 2^19937-1. It is one of\n//! the most widely used PRNGs in scientific computing.\n//!\n//! ## Features\n//!\n//! - Pseudorandom number generation: The library uses the Mersenne\n//!   Twister algorithm (MT19937) to generate pseudorandom integers\n//!   uniformly distributed in 0 to (2^32 - 1) using an array of\n//!   unsigned 32-bit integers and an index.\n//! - Random number types: The library provides several methods to\n//!   generate different types of random numbers including bool, bytes,\n//!   char, float, and int.\n//! - Range of values: The methods for generating random numbers allow\n//!   the user to specify the range of values for the output.\n//! - Random element selection: The library provides a method to choose\n//!   a random element from a given slice of values.\n//! - Initialization: The library provides a new() method to create a\n//!   new instance of the random number generator.\n//! - Optimization: The library is optimized for performance with the\n//!   number of elements in the array set to 624 and the number of\n//!   elements to skip set to 397.\n//! - Constant values: The library uses several constant values in the\n//!   Mersenne Twister algorithm including MATRIX_A, UPPER_MASK,\n//!   LOWER_MASK, TEMPERING_MASK_B, and TEMPERING_MASK_C.\n//!\n//!\n//! [`serde`]: https://github.com/serde-rs/serde\n//!\n#![cfg_attr(feature = \"bench\", feature(test))]\n#![deny(dead_code)]\n#![deny(missing_debug_implementations)]\n#![deny(missing_docs)]\n#![forbid(unsafe_code)]\n#![warn(unreachable_pub)]\n#![doc(\n    html_favicon_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-vrd.svg\",\n    html_logo_url = \"https://raw.githubusercontent.com/sebastienrousseau/vault/main/assets/mini-functions/icons/ico-vrd.svg\",\n    html_root_url = \"https://docs.rs/vrd\"\n)]\n#![crate_name = \"vrd\"]\n#![crate_type = \"lib\"]\n\nextern crate rand;\nuse rand::{thread_rng, Rng};\n\n/// N is the number of elements in the array used for the Mersenne\n/// Twister algorithm.Its value is set to 624 for optimal performance.\nconst N: usize = 624;\n\n/// M is the number of elements to skip in the array used for the\n/// Mersenne Twister algorithm. Its value is set to 397 for optimal\n/// performance.\nconst M: usize = 397;\n\n/// MATRIX_A is a constant value used in the Mersenne Twister algorithm.\nconst MATRIX_A: u32 = 0x9908b0df;\n\n/// UPPER_MASK is a constant value used in the Mersenne Twister\n/// algorithm.\nconst UPPER_MASK: u32 = 0x80000000;\n\n/// LOWER_MASK is a constant value used in the Mersenne Twister\n/// algorithm.\nconst LOWER_MASK: u32 = 0x7fffffff;\n\n/// TEMPERING_MASK_B is a constant value used in the Mersenne Twister\n/// algorithm.\nconst TEMPERING_MASK_B: u32 = 0x9d2c5680;\n\n/// TEMPERING_MASK_C is a constant value used in the Mersenne Twister\n/// algorithm.\nconst TEMPERING_MASK_C: u32 = 0xefc60000;\n\n#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]\n/// The Random struct is used to generate random numbers using the\n/// Mersenne Twister algorithm. It generates pseudorandom integers\n/// uniformly distributed in 0..(2^32 - 1) starting from any odd seed in\n/// 0..(2^32 - 1).\n///\n/// It contains an array of unsigned 32-bit integers and an index used\n/// to generate random numbers. The array contains 624 elements and the\n/// index is used to generate random numbers from the array.\n///\n/// The index is incremented after each random number is generated.\n/// When the index reaches 624, the array is reinitialized and the index\n/// is reset to 0.\n///\npub struct Random {\n    /// The array of unsigned 32-bit integers used to generate random\n    /// numbers\n    pub mt: [u32; N],\n    /// The current index of the array used in the generation of random\n    /// numbers\n    pub mti: usize,\n}\n\nimpl Random {\n    /// Returns a random bool with a probability that can be set\n    pub fn bool(\u0026mut self, probability: f64) -\u003e bool {\n        thread_rng().gen_bool(probability)\n    }\n\n    /// Returns a vector of random bytes of the given length\n    pub fn bytes(\u0026mut self, len: usize) -\u003e Vec\u003cu8\u003e {\n        let mut res = Vec::with_capacity(len);\n        for _ in 0..len {\n            let byte = self.rand() as u8;\n            res.push(byte);\n        }\n        res\n    }\n\n    /// Returns a random char within the range 'a'..='z'\n    pub fn char(\u0026mut self) -\u003e char {\n        thread_rng().gen_range('a'..='z')\n    }\n\n    /// Returns a random element from a slice of values\n    pub fn choose\u003c'a, T\u003e(\u0026'a mut self, values: \u0026'a [T]) -\u003e Option\u003c\u0026T\u003e {\n        if values.is_empty() {\n            return None;\n        }\n        let mut rng = rand::thread_rng();\n        let index = rng.gen_range(0..values.len());\n        Some(\u0026values[index])\n    }\n\n    /// Returns a random float.\n    pub fn float(\u0026mut self) -\u003e f32 {\n        thread_rng().gen::\u003cf64\u003e() as f32\n    }\n\n    /// Returns a random integer within the given range\n    pub fn int(\u0026mut self, min: i32, max: i32) -\u003e i32 {\n        thread_rng().gen_range(min..=max)\n    }\n    // pub fn int(\u0026mut self, min: i32, max: i32) -\u003e i32 {\n    //     self.range(min, max)\n    // }\n\n    /// Returns new random number generator\n    pub fn new() -\u003e Self {\n        let mut rng = Random {\n            mt: [0; N],\n            mti: N + 1,\n        };\n        let seed = thread_rng().gen();\n        rng.mt[0] = seed;\n        for i in 1..N {\n            rng.mt[i] = 1812433253u32\n                .wrapping_mul(rng.mt[i - 1] ^ (rng.mt[i - 1] \u003e\u003e 30))\n                .wrapping_add(i as u32);\n        }\n        rng.mti = N;\n        rng\n    }\n\n    /// Returns pseudo random number\n    pub fn pseudo(\u0026mut self) -\u003e u32 {\n        let mut res = self.rand();\n        for _ in 0..31 {\n            res ^= self.rand();\n        }\n        res\n    }\n\n    /// Returns a random 32-bit unsigned integer\n    pub fn rand(\u0026mut self) -\u003e u32 {\n        if self.mti \u003e= N {\n            if self.mti == N + 1 {\n                self.seed(5489);\n            }\n            self.twist();\n        }\n\n        let mut y = self.mt[self.mti];\n        self.mti += 1;\n        y ^= y \u003e\u003e 11;\n        y ^= (y \u003c\u003c 7) \u0026 TEMPERING_MASK_B;\n        y ^= (y \u003c\u003c 15) \u0026 TEMPERING_MASK_C;\n        y ^= y \u003e\u003e 18;\n        y\n    }\n\n    /// Returns a random 32-bit unsigned integer within a given range\n    pub fn random_range(\u0026mut self, min: u32, max: u32) -\u003e u32 {\n        min + self.rand() % (max - min)\n    }\n\n    /// Returns a random number within a given range\n    pub fn range(\u0026mut self, min: i32, max: i32) -\u003e i32 {\n        thread_rng().gen_range(min..=max)\n    }\n\n    /// Seeds the random number generator with a given value\n    pub fn seed(\u0026mut self, seed: u32) {\n        self.mt[0] = seed;\n        for i in 1..N {\n            self.mt[i] = match 1812433253u32.checked_mul(self.mt[i - 1] ^ (self.mt[i - 1] \u003e\u003e 30)) {\n                Some(val) =\u003e val + i as u32,\n                None =\u003e return,\n            };\n        }\n        self.mti = N;\n    }\n\n    /// Twists the state of the random number generator\n    pub fn twist(\u0026mut self) {\n        for i in 0..N {\n            let x = (self.mt[i] \u0026 UPPER_MASK) + (self.mt[(i + 1) % N] \u0026 LOWER_MASK);\n            let x_a = x \u003e\u003e 1;\n            if x % 2 != 0 {\n                self.mt[i] = self.mt[(i + M) % N] ^ x_a ^ MATRIX_A;\n            } else {\n                self.mt[i] = self.mt[(i + M) % N] ^ x_a;\n            }\n        }\n        self.mti = 0;\n    }\n}\n\nimpl std::fmt::Display for Random {\n    /// Returns a formatted string\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(f, \"Random {{ mt: {:?}, mti: {:?} }}\", self.mt, self.mti)\n    }\n}\n\nimpl Default for Random {\n    /// Returns a default random number generator\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","seb","Team Rousseau Dropbox","Sebastien Rousseau","Users","seb","Code","mini-functions","vrd","tests","vrd.rs"],"content":"#[cfg(test)]\n\n// TODO: Add more tests to bring the code coverage to 100%\nmod tests {\n\n    extern crate vrd;\n    use self::vrd::Random;\n\n    const N: usize = 624;\n\n    #[test]\n    fn test_bool() {\n        let mut rng = Random::new();\n        let mut count_of_true = 0;\n        for _ in 0..1000 {\n            let b = Random::bool(\u0026mut rng, 0.5);\n            if b {\n                count_of_true += 1;\n            }\n        }\n        assert!((count_of_true as f64 / 1000.0 - 0.5).abs() \u003c= 0.05);\n    }\n    #[test]\n    fn test_bytes() {\n        let mut rng = Random::new();\n        let bytes = Random::bytes(\u0026mut rng, 0);\n        assert_eq!(bytes.len(), 0);\n\n        let bytes = Random::bytes(\u0026mut rng, 10);\n        assert_eq!(bytes.len(), 10);\n\n        let bytes = Random::bytes(\u0026mut rng, 100);\n        assert_eq!(bytes.len(), 100);\n    }\n    #[test]\n    fn test_char() {\n        let mut rng = Random::new();\n        let c = Random::char(\u0026mut rng);\n        assert!(('a'..='z').contains(\u0026c));\n    }\n    #[test]\n    fn test_choose() {\n        let mut rng = Random::new();\n        let values = vec![1, 2, 3, 4, 5];\n        let value = Random::choose(\u0026mut rng, \u0026values);\n        assert!(value.is_some());\n        assert!(value.unwrap() \u003e= \u00261 \u0026\u0026 value.unwrap() \u003c= \u00265);\n        if values.is_empty() {\n            assert!(Random::choose(\u0026mut rng, \u0026values).is_none());\n        }\n    }\n    #[test]\n    fn test_float() {\n        let mut rng = Random::new();\n        let f = Random::float(\u0026mut rng);\n        assert!((0.0..=1.0).contains(\u0026f));\n    }\n    #[test]\n    fn test_int() {\n        let mut rng = Random::new();\n        let i = rng.int(0, 10);\n        assert!((0..=10).contains(\u0026i));\n    }\n    #[test]\n    fn test_pseudo() {\n        let mut rng = Random::new();\n        let p = Random::pseudo(\u0026mut rng);\n        assert!(p \u003c 4294967295);\n    }\n    #[test]\n    fn test_range() {\n        let mut rng = Random::new();\n        let r = Random::range(\u0026mut rng, 0, 10);\n        assert!((0..=10).contains(\u0026r));\n    }\n    #[test]\n    pub fn test_new() {\n        let rng = Random::new();\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt[0] \u003e 0);\n    }\n    #[test]\n    fn test_rand() {\n        let mut rng = Random::new();\n        let r = Random::rand(\u0026mut rng);\n        assert!(r \u003c 4294967295);\n    }\n    #[test]\n    fn test_random_range() {\n        let mut rng = Random::new();\n        let r = Random::random_range(\u0026mut rng, 0, 10);\n        assert!(r \u003c= 10);\n    }\n    #[test]\n    fn test_seed() {\n        let mut rng = Random::new();\n        Random::seed(\u0026mut rng, 0);\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt.iter().any(|\u0026x| x != 0));\n        assert!(rng.mti == N);\n    }\n    #[test]\n    fn test_twist() {\n        let mut rng = Random::new();\n        Random::seed(\u0026mut rng, 0);\n        Random::twist(\u0026mut rng);\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt.iter().any(|\u0026x| x != 0));\n    }\n    #[test]\n    fn test_fmt() {\n        let rng = Random::new();\n        let s = format!(\"{rng}\");\n        assert!(!s.is_empty());\n    }\n    #[test]\n    fn test_default() {\n        let rng = Random::default();\n        assert!(rng.mti \u003c= N);\n        assert!(rng.mt[0] \u003e 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>